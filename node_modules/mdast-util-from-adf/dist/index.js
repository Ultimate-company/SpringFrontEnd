import { u } from "unist-builder";
// Create a new stack entry for the content of an ADF node, if present.
function enter(adf, parent) {
    return adf.content?.map((n) => [n, parent]);
}
// Expand an ADF node into a (linear) MDAST subtree (root-...-leaf).
// Attach the root of this tree to the parent node and continue
// processing of ADF content with the leaf as the new parent.
function expand(transform) {
    return (adf, parent) => {
        const tree = transform(adf);
        parent.children.push(tree.root);
        return enter(adf, tree.leaf);
    };
}
// Produce an MDAST counterpart for this ADF node.
// Continue processing branches in the ADF tree.
function map(transform) {
    return (adf, parent) => {
        const node = transform(adf);
        parent.children.push(node);
        return enter(adf, node);
    };
}
// Produce an MDAST counterpart for this ADF node.
// Stop processing on this branch of the ADF tree.
function put(transform) {
    return (adf, parent) => {
        parent.children.push(transform(adf));
    };
}
// Do not produce an MDAST counterpart for this ADF node.
// Instead, continue with processing its content.
function skip(adf, parent) {
    return enter(adf, parent);
}
const handlers = {
    blockCard: put((adf) => {
        const { attrs } = adf;
        const content = "url" in attrs
            ? u("link", { url: attrs.url }, [u("text", attrs.url)])
            : u("html", `<!-- block card: ${JSON.stringify(attrs.data)} -->`);
        return u("paragraph", [content]);
    }),
    blockquote: map(() => u("blockquote", [])),
    bodiedExtension: undefined,
    bulletList: map(() => u("list", { ordered: false, spread: false }, [])),
    codeBlock: put((adf) => {
        const text = adf.content?.[0]?.text ?? "";
        const lang = adf.attrs?.language;
        return u("code", { lang }, text);
    }),
    date: put((adf) => u("text", adf.attrs.timestamp)),
    decisionItem: expand((adf) => {
        const content = u("paragraph", []);
        const node = u("listItem", { spread: false, checked: adf.attrs.state === "DECIDED" }, [content]);
        return { root: node, leaf: content };
    }),
    decisionList: map(() => u("list", { ordered: false, spread: false }, [])),
    embedCard: put((adf) => {
        const { url } = adf.attrs;
        return u("link", { url }, [u("text", url)]);
    }),
    emoji: put((adf) => {
        const { shortName, text } = adf.attrs;
        return u("text", text ?? shortName);
    }),
    expand: skip,
    extension: undefined,
    hardBreak: put(() => u("break")),
    heading: map((adf) => {
        const depth = adf.attrs.level;
        return u("heading", { depth }, []);
    }),
    inlineCard: put((adf) => {
        const { attrs } = adf;
        const node = "url" in attrs
            ? u("link", { url: attrs.url }, [u("text", attrs.url)])
            : u("html", `<!-- inline card: ${JSON.stringify(attrs.data)} -->`);
        return node;
    }),
    inlineExtension: undefined,
    layoutColumn: skip,
    layoutSection: skip,
    listItem: map(() => u("listItem", { spread: false }, [])),
    media: put((adf) => {
        const key = "url" in adf.attrs ? adf.attrs.url : adf.attrs.id;
        return u("html", `<!-- media: ${adf.attrs.type} ${key} -->`);
    }),
    mediaGroup: skip,
    mediaInline: undefined,
    mediaSingle: skip,
    mention: put((adf) => u("text", `@${adf.attrs.text}`)),
    nestedExpand: skip,
    orderedList: map(() => u("list", { ordered: true, spread: false }, [])),
    panel: skip,
    paragraph: map(() => u("paragraph", [])),
    placeholder: undefined,
    rule: put(() => u("thematicBreak")),
    status: undefined,
    table: map(() => u("table", [])),
    tableCell: map(() => u("tableCell", [])),
    tableHeader: map(() => u("tableCell", [])),
    tableRow: map(() => u("tableRow", [])),
    taskItem: expand((adf) => {
        const content = u("paragraph", []);
        const node = u("listItem", { spread: false, checked: adf.attrs.state === "DONE" }, [content]);
        return { root: node, leaf: content };
    }),
    taskList: map(() => u("list", { ordered: false, spread: false }, [])),
    text: put((adf) => {
        const { text, marks = [] } = adf;
        const leaf = u("text", adf.text);
        let node = leaf;
        marks.forEach((mark) => {
            const { type, attrs } = mark;
            if (type === "code") {
                leaf.type = "inlineCode";
            }
            else {
                if (type === "em") {
                    node = u("emphasis", [node]);
                }
                else if (type === "strong") {
                    node = u("strong", [node]);
                }
                else if (type === "strike") {
                    node = u("delete", [node]);
                }
                else if (type === "link") {
                    node = u("link", { url: attrs.href }, [node]);
                }
                else if (type === "subsup") {
                    node = u("html", `<${attrs.type}>${text}</${attrs.type}>`);
                }
            }
        });
        return node;
    }),
};
class AssertionError extends Error {
}
function assert(value, message = "") {
    if (!value)
        throw new AssertionError(message);
}
function convert(doc) {
    assert(doc.version === 1, `unknown document version ${doc.version}`);
    const tree = u("root", []);
    const stack = [doc.content.map((adf) => [adf, tree])];
    while (stack.length > 0) {
        const index = stack.length - 1;
        const queue = stack[index];
        if (queue.length === 0) {
            stack.pop();
            continue;
        }
        const [adf, parent] = queue.shift();
        const proc = handlers[adf.type];
        assert(proc, `unsupported node type "${adf.type}"`);
        const entry = proc(adf, parent);
        if (entry)
            stack.push(entry);
    }
    return tree;
}
export const fromADF = convert;
//# sourceMappingURL=index.js.map