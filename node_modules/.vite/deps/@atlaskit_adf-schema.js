import {
  css_color_names_default,
  css_color_names_exports,
  require_linkify_it
} from "./chunk-ORZRZFYN.js";
import {
  Fragment,
  Schema
} from "./chunk-AGEANN4K.js";
import {
  __export,
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/index.js
var nodes_exports = {};
__export(nodes_exports, {
  blockCard: () => blockCard,
  blockquote: () => blockquote,
  bodiedExtension: () => bodiedExtension,
  bulletList: () => bulletList,
  bulletListSelector: () => bulletListSelector,
  codeBlock: () => codeBlock,
  codeBlockToJSON: () => toJSON,
  confluenceJiraIssue: () => confluenceJiraIssue,
  confluenceUnsupportedBlock: () => confluenceUnsupportedBlock,
  confluenceUnsupportedInline: () => confluenceUnsupportedInline,
  copyPrivateMediaAttributes: () => copyPrivateAttributes,
  date: () => date,
  decisionItem: () => decisionItem,
  decisionList: () => decisionList,
  decisionListSelector: () => decisionListSelector,
  doc: () => doc,
  emoji: () => emoji,
  expand: () => expand,
  expandToJSON: () => toJSON5,
  extension: () => extension,
  hardBreak: () => hardBreak,
  heading: () => heading,
  image: () => image,
  inlineCard: () => inlineCard,
  inlineExtension: () => inlineExtension,
  layoutColumn: () => layoutColumn,
  layoutSection: () => layoutSection,
  listItem: () => listItem,
  media: () => media,
  mediaGroup: () => mediaGroup,
  mediaSingle: () => mediaSingle,
  mediaSingleToJSON: () => toJSON4,
  mediaToJSON: () => toJSON3,
  mediaWithAltText: () => mediaWithAltText,
  mention: () => mention,
  mentionToJSON: () => toJSON2,
  nestableTaskList: () => nestableTaskList,
  nestedExpand: () => nestedExpand,
  orderedList: () => orderedList,
  orderedListSelector: () => orderedListSelector,
  panel: () => panel,
  paragraph: () => paragraph,
  placeholder: () => placeholder,
  rule: () => rule,
  setCellAttrs: () => setCellAttrs,
  status: () => status,
  table: () => table,
  tableBackgroundBorderColor: () => tableBackgroundBorderColor,
  tableBackgroundColorNames: () => tableBackgroundColorNames,
  tableBackgroundColorPalette: () => tableBackgroundColorPalette,
  tableCell: () => tableCell,
  tableCellContentDomSelector: () => tableCellContentDomSelector,
  tableCellContentWrapperSelector: () => tableCellContentWrapperSelector,
  tableCellSelector: () => tableCellSelector,
  tableHeader: () => tableHeader,
  tableHeaderSelector: () => tableHeaderSelector,
  tablePrefixSelector: () => tablePrefixSelector,
  tableRow: () => tableRow,
  tableToJSON: () => tableToJSON,
  taskItem: () => taskItem,
  taskList: () => taskList,
  taskListSelector: () => taskListSelector,
  text: () => text,
  toJSONTableCell: () => toJSONTableCell,
  toJSONTableHeader: () => toJSONTableHeader,
  unknownBlock: () => unknown_block_default,
  unsupportedBlock: () => unsupportedBlock,
  unsupportedInline: () => unsupportedInline
});

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/confluence-jira-issue.js
var name = "confluenceJiraIssue";
var confluenceJiraIssue = {
  group: "inline",
  inline: true,
  atom: true,
  attrs: {
    issueKey: { default: "" },
    macroId: { default: null },
    schemaVersion: { default: null },
    server: { default: null },
    serverId: { default: null }
  },
  parseDOM: [
    {
      tag: 'span[data-node-type="' + name + '"]',
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          issueKey: dom.textContent,
          macroId: dom.dataset && dom.dataset.macroId,
          schemaVersion: dom.dataset && dom.dataset.schemaVersion,
          server: dom.dataset && dom.dataset.server,
          serverId: dom.dataset && dom.dataset.serverId
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": name,
      "data-macro-id": node.attrs.macroId,
      "data-schema-version": node.attrs.schemaVersion,
      "data-server": node.attrs.server,
      "data-server-id": node.attrs.serverId,
      "data-jira-issue": node.attrs.issueKey
    };
    return ["span", attrs, node.attrs.issueKey];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/confluence-unsupported-block.js
var name2 = "confluenceUnsupportedBlock";
var confluenceUnsupportedBlock = {
  group: "block",
  attrs: { cxhtml: { default: null } },
  toDOM: function(node) {
    var attrs = {
      "data-node-type": name2,
      "data-confluence-unsupported": "block",
      "data-confluence-unsupported-block-cxhtml": node.attrs["cxhtml"]
    };
    return ["div", attrs, "Unsupported content"];
  },
  parseDOM: [
    {
      tag: 'div[data-node-type="' + name2 + '"]',
      getAttrs: function(dom) {
        return {
          cxhtml: dom.getAttribute("data-confluence-unsupported-block-cxhtml")
        };
      }
    }
  ]
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/confluence-unsupported-inline.js
var name3 = "confluenceUnsupportedInline";
var confluenceUnsupportedInline = {
  group: "inline",
  inline: true,
  atom: true,
  attrs: { cxhtml: { default: null } },
  toDOM: function(node) {
    var attrs = {
      "data-node-type": name3,
      "data-confluence-unsupported": "inline",
      "data-confluence-unsupported-inline-cxhtml": node.attrs["cxhtml"]
    };
    return ["div", attrs, "Unsupported content"];
  },
  parseDOM: [
    {
      tag: 'div[data-node-type="' + name3 + '"]',
      getAttrs: function(dom) {
        return {
          cxhtml: dom.getAttribute("data-confluence-unsupported-inline-cxhtml")
        };
      }
    }
  ]
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/doc.js
var doc = {
  content: "(block|layoutSection)+",
  marks: "alignment breakout indentation link"
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/blockquote.js
var blockquote = {
  content: "paragraph+",
  group: "block",
  defining: true,
  selectable: false,
  parseDOM: [{ tag: "blockquote" }],
  toDOM: function() {
    return ["blockquote", 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/bullet-list.js
var bulletListSelector = ".ak-ul";
var bulletList = {
  group: "block",
  content: "listItem+",
  parseDOM: [{ tag: "ul" }],
  toDOM: function() {
    var attrs = {
      class: bulletListSelector.substr(1)
    };
    return ["ul", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/code-block.js
var getLanguageFromEditorStyle = function(dom) {
  return dom.getAttribute("data-language") || void 0;
};
var getLanguageFromBitbucketStyle = function(dom) {
  if (dom && dom.classList.contains("codehilite")) {
    return extractLanguageFromClass(dom.className);
  }
  return;
};
var getLanguageFromCode = function(dom) {
  var firstChild = dom.firstElementChild;
  if (firstChild && firstChild.nodeName === "CODE") {
    return firstChild.getAttribute("data-language") || void 0;
  }
};
var extractLanguageFromClass = function(className) {
  var languageRegex = /(?:^|\s)language-([^\s]+)/;
  var result = languageRegex.exec(className);
  if (result && result[1]) {
    return result[1];
  }
  return;
};
var removeLastNewLine = function(dom) {
  var parent = dom && dom.parentElement;
  if (parent && parent.classList.contains("codehilite")) {
    dom.textContent = dom.textContent.replace(/\n$/, "");
  }
  return dom;
};
var codeBlock = {
  attrs: { language: { default: null }, uniqueId: { default: null } },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: function(domNode) {
        var dom = domNode;
        var language = getLanguageFromBitbucketStyle(dom.parentElement) || getLanguageFromEditorStyle(dom.parentElement) || getLanguageFromCode(dom) || dom.getAttribute("data-language");
        dom = removeLastNewLine(dom);
        return { language };
      }
    },
    // Handle VSCode paste
    // Checking `white-space: pre-wrap` is too aggressive @see ED-2627
    {
      tag: "div[style]",
      preserveWhitespace: "full",
      getAttrs: function(domNode) {
        var dom = domNode;
        if (dom.style.whiteSpace === "pre" || dom.style.fontFamily && dom.style.fontFamily.toLowerCase().indexOf("monospace") > -1) {
          return {};
        }
        return false;
      },
      // @see ED-5682
      getContent: function(domNode, schema) {
        var dom = domNode;
        var code2 = Array.from(dom.children).map(function(child) {
          return child.textContent;
        }).filter(function(x) {
          return x !== void 0;
        }).join("\n");
        return code2 ? Fragment.from(schema.text(code2)) : Fragment.empty;
      }
    },
    // Handle GitHub/Gist paste
    {
      tag: "table[style]",
      preserveWhitespace: "full",
      getAttrs: function(dom) {
        if (dom.querySelector('td[class*="blob-code"]')) {
          return {};
        }
        return false;
      }
    },
    {
      tag: "div.code-block",
      preserveWhitespace: "full",
      getAttrs: function(domNode) {
        var dom = domNode;
        var linesCode = dom.querySelector("code");
        if (linesCode && linesCode.querySelector(".react-syntax-highlighter-line-number")) {
          linesCode.remove();
        }
        return {};
      }
    }
  ],
  toDOM: function(node) {
    return ["pre", ["code", { "data-language": node.attrs.language }, 0]];
  }
};
var toJSON = function(node) {
  return {
    attrs: Object.keys(node.attrs).reduce(function(memo, key) {
      if (key === "uniqueId") {
        return memo;
      }
      if (key === "language" && node.attrs.language === null) {
        return memo;
      }
      memo[key] = node.attrs[key];
      return memo;
    }, {})
  };
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/hard-break.js
var hardBreak = {
  inline: true,
  group: "inline",
  selectable: false,
  parseDOM: [{ tag: "br" }],
  toDOM: function() {
    return ["br"];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/heading.js
var heading = {
  attrs: { level: { default: 1 } },
  content: "inline*",
  group: "block",
  defining: true,
  parseDOM: [
    { tag: "h1", attrs: { level: 1 } },
    { tag: "h2", attrs: { level: 2 } },
    { tag: "h3", attrs: { level: 3 } },
    { tag: "h4", attrs: { level: 4 } },
    { tag: "h5", attrs: { level: 5 } },
    { tag: "h6", attrs: { level: 6 } }
  ],
  toDOM: function(node) {
    return ["h" + node.attrs["level"], 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/rule.js
var hrDOM = ["hr"];
var rule = {
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: function() {
    return hrDOM;
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/ordered-list.js
var orderedListSelector = ".ak-ol";
var orderedList = {
  group: "block",
  content: "listItem+",
  parseDOM: [{ tag: "ol" }],
  toDOM: function() {
    var attrs = {
      class: orderedListSelector.substr(1)
    };
    return ["ol", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/paragraph.js
var pDOM = ["p", 0];
var paragraph = {
  content: "inline*",
  group: "block",
  marks: "strong code em link strike subsup textColor typeAheadQuery underline confluenceInlineComment action annotation",
  parseDOM: [{ tag: "p" }],
  toDOM: function() {
    return pDOM;
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/utils/confluence/emoji.js
var DEFAULT_EMOJI_ID = "2b50";
var DEFAULT_EMOJI_ACNAME = "blue-star";
var HC_EMOTICON_PREFIX = "atlassian-";
var acNameToEmojiMap = {
  smile: ["1f642", ":slight_smile:", "üôÇ"],
  sad: ["1f641", ":slight_frown:", "üôÅ"],
  cheeky: ["1f61b", ":stuck_out_tongue:", "üòõ"],
  laugh: ["1f600", ":grinning:", "üòÄ"],
  wink: ["1f609", ":wink:", "üòâ"],
  information: ["2139", ":information_source:", "‚Ñπ"],
  tick: ["2705", ":white_check_mark:", "‚úÖ"],
  cross: ["274c", ":x:", "‚ùå"],
  warning: ["26a0", ":warning:", "‚ö†"],
  plus: ["2795", ":heavy_plus_sign:", "‚ûï"],
  minus: ["2796", ":heavy_minus_sign:", "‚ûñ"],
  question: ["2753", ":question:", "?"],
  "thumbs-up": ["1f44d", ":thumbsup:", "üëç"],
  "thumbs-down": ["1f44e", ":thumbsdown:", "üëé"],
  "light-on": ["1f4a1", ":bulb:", "üí°"],
  "yellow-star": ["2b50", ":star:", "üíõ"],
  "light-off": ["1f6ab", ":no_entry_sign:", "üö´"],
  "red-star": ["2764", ":heart:", "‚ù§Ô∏è"],
  "green-star": ["1f49a", ":green_heart:", "üíö"],
  "blue-star": ["1f499", ":blue_heart:", "üíô"],
  heart: ["2764", ":heart:", "‚ù§Ô∏è"],
  "broken-heart": ["1f494", ":broken_heart:", "üíî"]
};
function acNameToEmoji(acName) {
  var emojiData = acNameToEmojiMap[acName];
  return emojiData ? {
    id: emojiData[0],
    shortName: emojiData[1],
    text: emojiData[2]
  } : {
    id: DEFAULT_EMOJI_ID,
    shortName: ":" + acName + ":",
    text: ""
  };
}
function emojiIdToAcName(emojiId) {
  var filterEmojis = function(acName) {
    return acNameToEmojiMap[acName] ? acNameToEmojiMap[acName][0] === emojiId : false;
  };
  return Object.keys(acNameToEmojiMap).filter(filterEmojis)[0];
}
function acShortcutToEmoji(hipchatEmoticonShortName) {
  return {
    id: "" + HC_EMOTICON_PREFIX + hipchatEmoticonShortName,
    shortName: ":" + hipchatEmoticonShortName + ":",
    text: ""
  };
}
function getAcNameFromShortName(shortName) {
  return shortName.slice(shortName[0] === ":" ? 1 : 0, shortName[shortName.length - 1] === ":" ? -1 : shortName.length);
}
function getEmojiAcName(_a2) {
  var id = _a2.id, shortName = _a2.shortName;
  if (DEFAULT_EMOJI_ID === id) {
    var possibleName = getAcNameFromShortName(shortName);
    if (possibleName in acNameToEmojiMap) {
      return possibleName;
    }
  }
  return emojiIdToAcName(id) || DEFAULT_EMOJI_ACNAME;
}

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/emoji.js
var emoji = {
  inline: true,
  group: "inline",
  selectable: false,
  attrs: {
    shortName: { default: "" },
    id: { default: "" },
    text: { default: "" }
  },
  parseDOM: [
    {
      tag: "span[data-emoji-short-name]",
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          shortName: dom.getAttribute("data-emoji-short-name") || emoji.attrs.shortName.default,
          id: dom.getAttribute("data-emoji-id") || emoji.attrs.id.default,
          text: dom.getAttribute("data-emoji-text") || emoji.attrs.text.default
        };
      }
    },
    // Handle copy/paste from old <ac:emoticon />
    {
      tag: "img[data-emoticon-name]",
      getAttrs: function(dom) {
        return acNameToEmoji(dom.getAttribute("data-emoticon-name"));
      }
    },
    // Handle copy/paste from old <ac:hipchat-emoticons />
    {
      tag: "img[data-hipchat-emoticon]",
      getAttrs: function(dom) {
        return acShortcutToEmoji(dom.getAttribute("data-hipchat-emoticon"));
      }
    },
    // Handle copy/paste from bitbucket's <img class="emoji" />
    {
      tag: "img.emoji[data-emoji-short-name]",
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          shortName: dom.getAttribute("data-emoji-short-name") || emoji.attrs.shortName.default,
          id: dom.getAttribute("data-emoji-id") || emoji.attrs.id.default,
          text: dom.getAttribute("data-emoji-text") || emoji.attrs.text.default
        };
      }
    }
  ],
  toDOM: function(node) {
    var _a2 = node.attrs, shortName = _a2.shortName, id = _a2.id, text2 = _a2.text;
    var attrs = {
      "data-emoji-short-name": shortName,
      "data-emoji-id": id,
      "data-emoji-text": text2,
      contenteditable: "false"
    };
    return ["span", attrs, text2];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/image.js
var image = {
  group: "inline",
  inline: true,
  attrs: {
    src: { default: "" },
    alt: { default: null },
    title: { default: null }
  },
  draggable: true,
  parseDOM: [
    {
      tag: 'img[src^="data:image/"]',
      ignore: true
    },
    {
      tag: "img[src]",
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          src: dom.getAttribute("src"),
          alt: dom.getAttribute("alt"),
          title: dom.getAttribute("title")
        };
      }
    }
  ],
  toDOM: function(node) {
    return ["img", node.attrs];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/mention.js
var USER_TYPES;
(function(USER_TYPES2) {
  USER_TYPES2["DEFAULT"] = "DEFAULT";
  USER_TYPES2["SPECIAL"] = "SPECIAL";
  USER_TYPES2["APP"] = "APP";
})(USER_TYPES || (USER_TYPES = {}));
var mention = {
  inline: true,
  group: "inline",
  selectable: false,
  attrs: {
    id: { default: "" },
    text: { default: "" },
    accessLevel: { default: "" },
    userType: { default: null }
  },
  parseDOM: [
    {
      tag: "span[data-mention-id]",
      getAttrs: function(domNode) {
        var dom = domNode;
        var attrs = {
          id: dom.getAttribute("data-mention-id") || mention.attrs.id.default,
          text: dom.textContent || mention.attrs.text.default,
          accessLevel: dom.getAttribute("data-access-level") || mention.attrs.accessLevel.default
        };
        var userType = dom.getAttribute("data-user-type");
        if (USER_TYPES[userType]) {
          attrs.userType = userType;
        }
        return attrs;
      }
    }
  ],
  toDOM: function(node) {
    var _a2 = node.attrs, id = _a2.id, accessLevel = _a2.accessLevel, text2 = _a2.text, userType = _a2.userType;
    var attrs = {
      "data-mention-id": id,
      "data-access-level": accessLevel,
      contenteditable: "false"
    };
    if (userType) {
      attrs["data-user-type"] = userType;
    }
    return ["span", attrs, text2];
  }
};
var isOptional = function(key) {
  return ["userType"].indexOf(key) > -1;
};
var toJSON2 = function(node) {
  return {
    attrs: Object.keys(node.attrs).reduce(function(obj, key) {
      if (isOptional(key) && !node.attrs[key]) {
        return obj;
      }
      obj[key] = node.attrs[key];
      return obj;
    }, {})
  };
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/list-item.js
var listItem = {
  content: "(paragraph | mediaSingle | codeBlock) (paragraph | bulletList | orderedList | mediaSingle | codeBlock)*",
  defining: true,
  parseDOM: [{ tag: "li" }],
  toDOM: function() {
    return ["li", 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/panel.js
var panel = {
  group: "block",
  content: "(paragraph | heading | bulletList | orderedList)+",
  attrs: {
    panelType: { default: "info" }
  },
  parseDOM: [
    {
      tag: "div[data-panel-type]",
      getAttrs: function(dom) {
        return {
          panelType: dom.getAttribute("data-panel-type")
        };
      }
    }
  ],
  toDOM: function(node) {
    var panelType = node.attrs["panelType"];
    var attrs = {
      "data-panel-type": panelType
    };
    return ["div", attrs, ["div", {}, 0]];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/text.js
var text = {
  group: "inline",
  toDebugString: (
    // @ts-ignore
    true ? void 0 : function() {
      return "text_node";
    }
  )
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/unknown-block.js
var name4 = "unknownBlock";
var unknown_block_default = {
  group: "block",
  content: "inline+",
  marks: "_",
  toDOM: function() {
    return ["div", { "data-node-type": name4 }, 0];
  },
  parseDOM: [{ tag: 'div[data-node-type="' + name4 + '"]' }]
};

// node_modules/@atlaskit/adf-schema/node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}

// node_modules/@atlaskit/adf-schema/dist/esm/utils/colors.js
var R50 = "#FFEBE6";
var R75 = "#FFBDAD";
var R100 = "#FF8F73";
var R300 = "#FF5630";
var R400 = "#DE350B";
var R500 = "#BF2600";
var Y50 = "#FFFAE6";
var Y75 = "#FFF0B3";
var Y200 = "#FFC400";
var Y400 = "#FF991F";
var Y500 = "#FF8B00";
var G50 = "#E3FCEF";
var G75 = "#ABF5D1";
var G200 = "#57D9A3";
var G300 = "#36B37E";
var G400 = "#00875A";
var G500 = "#006644";
var B50 = "#DEEBFF";
var B75 = "#B3D4FF";
var B100 = "#4C9AFF";
var B400 = "#0052CC";
var B500 = "#0747A6";
var N0 = "#FFFFFF";
var N20 = "#F4F5F7";
var N30 = "#EBECF0";
var N40 = "#DFE1E6";
var N50 = "#C1C7D0";
var N60 = "#B3BAC5";
var N80 = "#97A0AF";
var N90 = "#8993A4";
var N200 = "#6B778C";
var N300 = "#5E6C84";
var N500 = "#42526E";
var N800 = "#172B4D";
var P50 = "#EAE6FF";
var P75 = "#C0B6F2";
var P100 = "#998DD9";
var P300 = "#6554C0";
var P400 = "#5243AA";
var P500 = "#403294";
var T50 = "#E6FCFF";
var T75 = "#B3F5FF";
var T100 = "#79E2F2";
var T300 = "#00B8D9";
var T500 = "#008DA6";
function normalizeHexColor(color, defaultColor) {
  if (!color) {
    return null;
  }
  color = color.trim().toLowerCase();
  if (isHex(color)) {
    if (color.length === 4) {
      color = color.split("").map(function(c) {
        return c === "#" ? "#" : "" + c + c;
      }).join("");
    }
  } else if (isRgb(color)) {
    return rgbToHex(color);
  } else {
    if (css_color_names_default && css_color_names_default[color]) {
      color = css_color_names_default[color];
    } else if (css_color_names_exports && css_color_names_exports[color]) {
      color = css_color_names_exports[color];
    } else {
      return null;
    }
  }
  if (color === defaultColor) {
    return null;
  }
  return color;
}
function hexToRgb(color) {
  if (!isHex(color)) {
    return null;
  }
  var colorBits = color.substring(1).split("");
  if (colorBits.length === 3) {
    colorBits = [
      colorBits[0],
      colorBits[0],
      colorBits[1],
      colorBits[1],
      colorBits[2],
      colorBits[2]
    ];
  }
  var rgb = Number("0x" + colorBits.join(""));
  return "rgb(" + (rgb >> 16 & 255) + "," + (rgb >> 8 & 255) + "," + (rgb & 255) + ")";
}
function hexToRgba(rawColor, alpha) {
  var color = normalizeHexColor(rawColor);
  if (!color) {
    return null;
  }
  var hex2rgb = function(color2) {
    return color2.match(/[a-z0-9]{2}/gi).map(function(hex) {
      return parseInt(hex, 16);
    });
  };
  return "rgba(" + hex2rgb(color).concat(alpha).join(",") + ")";
}
function rgbToHex(value) {
  var matches = value.match(/(0?\.?\d{1,3})%?\b/g);
  if (matches && matches.length >= 3) {
    var _a2 = __read(matches.map(Number), 3), red = _a2[0], green = _a2[1], blue = _a2[2];
    return "#" + (blue | green << 8 | red << 16 | 1 << 24).toString(16).slice(1);
  }
  return null;
}
function isRgb(color) {
  return /rgba?\(/.test(color);
}
function isHex(color) {
  return /^#([A-Fa-f0-9]{3}){1,2}$/.test(color);
}

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media.js
var defaultAttrs = {
  id: { default: "" },
  type: { default: "file" },
  collection: { default: "" },
  occurrenceKey: { default: null },
  width: { default: null },
  height: { default: null },
  url: { default: null },
  __fileName: { default: null },
  __fileSize: { default: null },
  __fileMimeType: { default: null },
  __displayType: { default: null },
  __contextId: { default: null },
  __external: { default: false }
};
var defaultAttrsWithAltText = __assign(__assign({}, defaultAttrs), { alt: { default: null } });
var createMediaSpec = function(attributes) {
  return {
    selectable: true,
    attrs: attributes,
    parseDOM: [
      {
        tag: 'div[data-node-type="media"]',
        getAttrs: function(dom) {
          var attrs = {};
          if (attributes) {
            Object.keys(attributes).forEach(function(k) {
              var key = camelCaseToKebabCase(k).replace(/^__/, "");
              var value = dom.getAttribute("data-" + key) || "";
              if (value) {
                attrs[k] = value;
              }
            });
          }
          if (attrs.__fileSize) {
            attrs.__fileSize = +attrs.__fileSize;
          }
          var width = Number(attrs.width);
          if (typeof width !== "undefined" && !isNaN(width)) {
            attrs.width = width;
          }
          var height = Number(attrs.height);
          if (typeof height !== "undefined" && !isNaN(height)) {
            attrs.height = height;
          }
          return attrs;
        }
      },
      // Don't match data URI
      {
        tag: 'img[src^="data:image"]',
        ignore: true
      },
      {
        tag: "img",
        getAttrs: function(dom) {
          return {
            type: "external",
            url: dom.getAttribute("src") || ""
          };
        }
      }
    ],
    toDOM: function(node) {
      var attrs = {
        "data-id": node.attrs.id,
        "data-node-type": "media",
        "data-type": node.attrs.type,
        "data-collection": node.attrs.collection,
        "data-occurrence-key": node.attrs.occurrenceKey,
        "data-width": node.attrs.width,
        "data-height": node.attrs.height,
        "data-url": node.attrs.url,
        "data-alt": node.attrs.alt,
        // toDOM is used for static rendering as well as editor rendering. This comes into play for
        // emails, copy/paste, etc, so the title and styling here *is* useful (despite a React-based
        // node view being used for editing).
        title: "Attachment",
        // Manually kept in sync with the style of media cards. The goal is to render a plain gray
        // rectangle that provides an affordance for media.
        style: "display: inline-block; border-radius: 3px; background: " + N30 + "; box-shadow: 0 1px 1px rgba(9, 30, 66, 0.2), 0 0 1px 0 rgba(9, 30, 66, 0.24);"
      };
      copyPrivateAttributes(node.attrs, attrs, function(key) {
        return "data-" + camelCaseToKebabCase(key.slice(2));
      });
      return ["div", attrs];
    }
  };
};
var media = createMediaSpec(defaultAttrs);
var mediaWithAltText = createMediaSpec(defaultAttrsWithAltText);
var camelCaseToKebabCase = function(str) {
  return str.replace(/([^A-Z]+)([A-Z])/g, function(_, x, y) {
    return x + "-" + y.toLowerCase();
  });
};
var copyPrivateAttributes = function(from, to, map) {
  if (media.attrs) {
    Object.keys(media.attrs).forEach(function(key) {
      if (key[0] === "_" && key[1] === "_" && from[key]) {
        to[map ? map(key) : key] = from[key];
      }
    });
  }
};
var optionalAttributes = ["occurrenceKey", "width", "height", "url", "alt"];
var externalOnlyAttributes = ["type", "url", "width", "height"];
var toJSON3 = function(node) {
  return {
    attrs: Object.keys(node.attrs).filter(function(key) {
      return !(key[0] === "_" && key[1] === "_");
    }).reduce(function(obj, key) {
      if (node.attrs.type === "external" && externalOnlyAttributes.indexOf(key) === -1) {
        return obj;
      }
      if (optionalAttributes.indexOf(key) > -1 && (node.attrs[key] === null || node.attrs[key] === "")) {
        return obj;
      }
      if (["width", "height"].indexOf(key) !== -1) {
        obj[key] = Number(node.attrs[key]);
        return obj;
      }
      obj[key] = node.attrs[key];
      return obj;
    }, {})
  };
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media-group.js
var mediaGroup = {
  inline: false,
  group: "block",
  content: "media+",
  attrs: {},
  parseDOM: [
    {
      tag: 'div[data-node-type="mediaGroup"]'
    },
    {
      tag: 'div[class="MediaGroup"]'
    }
  ],
  toDOM: function() {
    return [
      "div",
      {
        "data-node-type": "mediaGroup"
      },
      0
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media-single.js
var defaultAttrs2 = {
  width: { default: null },
  layout: { default: "center" }
};
var mediaSingle = {
  inline: false,
  group: "block",
  selectable: true,
  atom: true,
  content: "media",
  attrs: defaultAttrs2,
  parseDOM: [
    {
      tag: 'div[data-node-type="mediaSingle"]',
      getAttrs: function(dom) {
        return {
          layout: dom.getAttribute("data-layout") || "center",
          width: Number(dom.getAttribute("data-width")) || null
        };
      }
    }
  ],
  toDOM: function(node) {
    var _a2 = node.attrs, layout = _a2.layout, width = _a2.width;
    var attrs = {
      "data-node-type": "mediaSingle",
      "data-layout": layout,
      "data-width": ""
    };
    if (width) {
      attrs["data-width"] = isFinite(width) && Math.floor(width) === width ? width : width.toFixed(2);
    }
    return ["div", attrs, 0];
  }
};
var toJSON4 = function(node) {
  return {
    attrs: Object.keys(node.attrs).reduce(function(obj, key) {
      if (node.attrs[key] !== null) {
        obj[key] = node.attrs[key];
      }
      return obj;
    }, {})
  };
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/tableNodes.js
var tablePrefixSelector = "pm-table";
var tableCellSelector = tablePrefixSelector + "-cell-content-wrap";
var tableHeaderSelector = tablePrefixSelector + "-header-content-wrap";
var tableCellContentWrapperSelector = tablePrefixSelector + "-cell-nodeview-wrapper";
var tableCellContentDomSelector = tablePrefixSelector + "-cell-nodeview-content-dom";
var DEFAULT_TABLE_HEADER_CELL_BACKGROUND = N20.toLocaleLowerCase();
var getCellAttrs = function(dom, defaultValues) {
  if (defaultValues === void 0) {
    defaultValues = {};
  }
  var widthAttr = dom.getAttribute("data-colwidth");
  var width = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map(function(str) {
    return Number(str);
  }) : null;
  var colspan = Number(dom.getAttribute("colspan") || 1);
  var backgroundColor = dom.style.backgroundColor;
  if (backgroundColor && isRgb(backgroundColor)) {
    backgroundColor = rgbToHex(backgroundColor);
  }
  return {
    colspan,
    rowspan: Number(dom.getAttribute("rowspan") || 1),
    colwidth: width && width.length === colspan ? width : null,
    background: backgroundColor && backgroundColor !== defaultValues["background"] ? backgroundColor : null
  };
};
var setCellAttrs = function(node, cell) {
  var attrs = {};
  var nodeType = node.type.name;
  var colspan = cell ? parseInt(cell.getAttribute("colspan") || "1", 10) : 1;
  var rowspan = cell ? parseInt(cell.getAttribute("rowspan") || "1", 10) : 1;
  if (node.attrs.colspan !== colspan) {
    attrs.colspan = node.attrs.colspan;
  }
  if (node.attrs.rowspan !== rowspan) {
    attrs.rowspan = node.attrs.rowspan;
  }
  if (node.attrs.colwidth) {
    attrs["data-colwidth"] = node.attrs.colwidth.join(",");
  }
  if (node.attrs.background) {
    var background = node.attrs.background;
    var ignored = nodeType === "tableHeader" && background === tableBackgroundColorNames.get("light gray") || nodeType === "tableCell" && background === tableBackgroundColorNames.get("white");
    if (ignored) {
      attrs.style = "";
    } else {
      var color = isRgb(background) ? rgbToHex(background) : background;
      attrs.style = (attrs.style || "") + "background-color: " + color + ";";
    }
  }
  if (nodeType === "tableHeader") {
    attrs.class = tableHeaderSelector;
  } else {
    attrs.class = tableCellSelector;
  }
  return attrs;
};
var tableBackgroundColorPalette = /* @__PURE__ */ new Map();
var tableBackgroundBorderColor = hexToRgba(N800, 0.12) || N0;
var tableBackgroundColorNames = /* @__PURE__ */ new Map();
[
  [N0, "White"],
  [B50, "Light blue"],
  [T50, "Light teal"],
  [G50, "Light green"],
  [Y50, "Light yellow"],
  [R50, "Light red"],
  [P50, "Light purple"],
  [N20, "Light gray"],
  [B75, "Blue"],
  [T75, "Teal"],
  [G75, "Green"],
  [Y75, "Yellow"],
  [R75, "Red"],
  [P75, "Purple"],
  [N60, "Gray"],
  [B100, "Dark blue"],
  [T100, "Dark teal"],
  [G200, "Dark green"],
  [Y200, "Dark yellow"],
  [R100, "Dark red"],
  [P100, "Dark purple"]
].forEach(function(_a2) {
  var _b = __read(_a2, 2), colorValue = _b[0], colorName = _b[1];
  tableBackgroundColorPalette.set(colorValue.toLowerCase(), colorName);
  tableBackgroundColorNames.set(colorName.toLowerCase(), colorValue.toLowerCase());
});
var table = {
  content: "tableRow+",
  attrs: {
    isNumberColumnEnabled: { default: false },
    layout: { default: "default" },
    __autoSize: { default: false }
  },
  tableRole: "table",
  isolating: true,
  selectable: false,
  group: "block",
  parseDOM: [
    {
      tag: "table",
      getAttrs: function(dom) {
        return {
          isNumberColumnEnabled: dom.getAttribute("data-number-column") === "true" ? true : false,
          layout: dom.getAttribute("data-layout") || "default",
          __autoSize: dom.getAttribute("data-autosize") === "true" ? true : false
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-number-column": node.attrs.isNumberColumnEnabled,
      "data-layout": node.attrs.layout,
      "data-autosize": node.attrs.__autoSize
    };
    return ["table", attrs, ["tbody", 0]];
  }
};
var tableToJSON = function(node) {
  return {
    attrs: Object.keys(node.attrs).filter(function(key) {
      return !key.startsWith("__");
    }).reduce(function(obj, key) {
      obj[key] = node.attrs[key];
      return obj;
    }, {})
  };
};
var tableRow = {
  content: "(tableCell | tableHeader)+",
  tableRole: "row",
  parseDOM: [{ tag: "tr" }],
  toDOM: function() {
    return ["tr", 0];
  }
};
var cellAttrs = {
  colspan: { default: 1 },
  rowspan: { default: 1 },
  colwidth: { default: null },
  background: { default: null }
};
var tableCell = {
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle |  mediaGroup | decisionList | taskList | blockCard | extension | nestedExpand | unsupportedBlock)+",
  attrs: cellAttrs,
  tableRole: "cell",
  marks: "alignment",
  isolating: true,
  parseDOM: [
    // Ignore number cell copied from renderer
    {
      tag: ".ak-renderer-table-number-column",
      ignore: true
    },
    {
      tag: "td",
      getAttrs: function(dom) {
        return getCellAttrs(dom);
      }
    }
  ],
  toDOM: function(node) {
    return ["td", setCellAttrs(node), 0];
  }
};
var toJSONTableCell = function(node) {
  return {
    attrs: Object.keys(node.attrs).reduce(function(obj, key) {
      if (cellAttrs[key].default !== node.attrs[key]) {
        obj[key] = node.attrs[key];
      }
      return obj;
    }, {})
  };
};
var tableHeader = {
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle |  mediaGroup | decisionList | taskList | blockCard | extension | nestedExpand)+",
  attrs: cellAttrs,
  tableRole: "header_cell",
  isolating: true,
  marks: "alignment",
  parseDOM: [
    {
      tag: "th",
      getAttrs: function(dom) {
        return getCellAttrs(dom, { background: DEFAULT_TABLE_HEADER_CELL_BACKGROUND });
      }
    }
  ],
  toDOM: function(node) {
    return ["th", setCellAttrs(node), 0];
  }
};
var toJSONTableHeader = toJSONTableCell;

// node_modules/@atlaskit/adf-schema/dist/esm/utils/uuid.js
var generateUuid = function() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    return (c === "x" ? r : r & 3 | 8).toString(16);
  });
};
var staticValue = false;
var uuid = {
  setStatic: function(value) {
    staticValue = value;
  },
  generate: function() {
    return staticValue || generateUuid();
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/decision-list.js
var name5 = "decisionList";
var decisionListSelector = '[data-node-type="' + name5 + '"]';
var decisionList = {
  group: "block",
  defining: true,
  content: "decisionItem+",
  attrs: {
    localId: { default: "" }
  },
  parseDOM: [
    {
      tag: "ol" + decisionListSelector,
      // Default priority is 50. We normally don't change this but since this node type is
      // also used by ordered-list we need to make sure that we run this parser first.
      priority: 100,
      getAttrs: function() {
        return {
          localId: uuid.generate()
        };
      }
    }
  ],
  toDOM: function(node) {
    var localId = node.attrs.localId;
    var attrs = {
      "data-node-type": name5,
      "data-decision-list-local-id": localId || "local-decision-list",
      style: "list-style: none; padding-left: 0"
    };
    return ["ol", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/decision-item.js
var decisionItem = {
  content: "inline*",
  defining: true,
  marks: "_",
  attrs: {
    localId: { default: "" },
    state: { default: "DECIDED" }
  },
  parseDOM: [
    {
      tag: "li[data-decision-local-id]",
      // Default priority is 50. We normally don't change this but since this node type is
      // also used by list-item we need to make sure that we run this parser first.
      priority: 100,
      getAttrs: function(dom) {
        return {
          localId: uuid.generate(),
          state: dom.getAttribute("data-decision-state")
        };
      }
    }
  ],
  toDOM: function(node) {
    var _a2 = node.attrs, localId = _a2.localId, state = _a2.state;
    var attrs = {
      "data-decision-local-id": localId || "local-decision",
      "data-decision-state": state
    };
    return ["li", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/task-list.js
var name6 = "actionList";
var taskListSelector = '[data-node-type="' + name6 + '"]';
var taskList = {
  group: "block",
  defining: true,
  content: "taskItem+",
  attrs: {
    localId: { default: "" }
  },
  parseDOM: [
    {
      tag: "div" + taskListSelector,
      // Default priority is 50. We normaly don't change this but since this node type is
      // also used by ordered-list we need to make sure that we run this parser first.
      priority: 100,
      getAttrs: function() {
        return {
          localId: uuid.generate()
        };
      }
    }
  ],
  toDOM: function(node) {
    var localId = node.attrs.localId;
    var attrs = {
      "data-node-type": name6,
      "data-task-list-local-id": localId || "local-task-list",
      style: "list-style: none; padding-left: 0"
    };
    return ["div", attrs, 0];
  }
};
var nestableTaskList = __assign(__assign({}, taskList), { content: "taskItem+ (taskItem|taskList)*" });

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/task-item.js
var taskItem = {
  content: "inline*",
  defining: true,
  marks: "_",
  attrs: {
    localId: { default: "" },
    state: { default: "TODO" }
  },
  parseDOM: [
    {
      tag: "div[data-task-local-id]",
      // Default priority is 50. We normally don't change this but since this node type is
      // also used by list-item we need to make sure that we run this parser first.
      priority: 100,
      getAttrs: function(dom) {
        return {
          localId: uuid.generate(),
          state: dom.getAttribute("data-task-state") || "TODO"
        };
      }
    }
  ],
  toDOM: function(node) {
    var _a2 = node.attrs, localId = _a2.localId, state = _a2.state;
    var attrs = {
      "data-task-local-id": localId || "local-task",
      "data-task-state": state || "TODO"
    };
    return ["div", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/extension.js
var extension = {
  inline: false,
  group: "block",
  atom: true,
  selectable: true,
  attrs: {
    extensionType: { default: "" },
    extensionKey: { default: "" },
    parameters: { default: null },
    text: { default: null },
    layout: { default: "default" }
  },
  parseDOM: [
    {
      tag: '[data-node-type="extension"]',
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          extensionType: dom.getAttribute("data-extension-type"),
          extensionKey: dom.getAttribute("data-extension-key"),
          text: dom.getAttribute("data-text"),
          parameters: JSON.parse(dom.getAttribute("data-parameters") || "{}"),
          layout: dom.getAttribute("data-layout") || "default"
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "extension",
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      "data-layout": node.attrs.layout
    };
    return ["div", attrs];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/inline-extension.js
var inlineExtension = {
  inline: true,
  group: "inline",
  selectable: true,
  attrs: {
    extensionType: { default: "" },
    extensionKey: { default: "" },
    parameters: { default: null },
    text: { default: null }
  },
  parseDOM: [
    {
      tag: "span[data-extension-type]",
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          extensionType: dom.getAttribute("data-extension-type"),
          extensionKey: dom.getAttribute("data-extension-key"),
          text: dom.getAttribute("data-text"),
          parameters: JSON.parse(dom.getAttribute("data-parameters") || "{}")
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      contenteditable: "false"
    };
    return ["span", attrs];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/bodied-extension.js
var bodiedExtension = {
  inline: false,
  group: "block",
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | extension | unsupportedBlock)+",
  defining: true,
  selectable: true,
  isolating: true,
  attrs: {
    extensionType: { default: "" },
    extensionKey: { default: "" },
    parameters: { default: null },
    text: { default: null },
    layout: { default: "default" }
  },
  parseDOM: [
    {
      context: "bodiedExtension//",
      tag: '[data-node-type="bodied-extension"]',
      skip: true
    },
    {
      tag: '[data-node-type="bodied-extension"]',
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          extensionType: dom.getAttribute("data-extension-type"),
          extensionKey: dom.getAttribute("data-extension-key"),
          text: dom.getAttribute("data-text"),
          parameters: JSON.parse(dom.getAttribute("data-parameters") || "{}"),
          layout: dom.getAttribute("data-layout") || "default"
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "bodied-extension",
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      "data-layout": node.attrs.layout
    };
    return ["div", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/date.js
var date = {
  inline: true,
  group: "inline",
  selectable: true,
  attrs: {
    timestamp: { default: "" }
  },
  parseDOM: [
    {
      tag: 'span[data-node-type="date"]',
      getAttrs: function(dom) {
        return {
          timestamp: dom.getAttribute("data-timestamp")
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "date",
      "data-timestamp": node.attrs.timestamp
    };
    return ["span", attrs];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/placeholder.js
var placeholder = {
  inline: true,
  group: "inline",
  selectable: false,
  marks: "",
  attrs: {
    text: { default: "" }
  },
  parseDOM: [
    {
      tag: "span[data-placeholder]",
      getAttrs: function(dom) {
        return {
          text: dom.getAttribute("data-placeholder") || placeholder.attrs.text.default
        };
      }
    }
  ],
  toDOM: function(node) {
    var text2 = node.attrs.text;
    var attrs = {
      "data-placeholder": text2,
      contenteditable: "false"
    };
    return ["span", attrs, text2];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/layout-section.js
var layoutSection = {
  content: "layoutColumn{2,3}",
  isolating: true,
  parseDOM: [
    {
      context: "layoutSection//|layoutColumn//",
      tag: "div[data-layout-section]",
      skip: true
    },
    {
      tag: "div[data-layout-section]"
    }
  ],
  toDOM: function() {
    var attrs = { "data-layout-section": "true" };
    return ["div", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/layout-column.js
var layoutColumn = {
  content: "block+",
  isolating: true,
  marks: "alignment",
  attrs: {
    width: {
      default: void 0
    }
  },
  parseDOM: [
    {
      context: "layoutColumn//",
      tag: "div[data-layout-column]",
      skip: true
    },
    {
      tag: "div[data-layout-column]",
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          width: Number(dom.getAttribute("data-column-width")) || void 0
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-layout-column": "true"
    };
    var width = node.attrs.width;
    if (width) {
      attrs["style"] = "flex-basis: " + width + "%";
      attrs["data-column-width"] = width;
    }
    var contentAttrs = {
      "data-layout-content": "true"
    };
    return ["div", attrs, ["div", contentAttrs, 0]];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/inline-card.js
var inlineCard = {
  inline: true,
  group: "inline",
  selectable: true,
  draggable: true,
  attrs: {
    url: { default: null },
    data: { default: null }
  },
  parseDOM: [
    {
      tag: "a[data-inline-card]",
      // bump priority higher than hyperlink
      priority: 100,
      getAttrs: function(dom) {
        var anchor = dom;
        var data = anchor.getAttribute("data-card-data");
        return {
          url: anchor.getAttribute("href") || null,
          data: data ? JSON.parse(data) : null
        };
      }
    },
    // for renderer
    {
      tag: "div[data-inline-card]",
      getAttrs: function(dom) {
        var anchor = dom;
        var data = anchor.getAttribute("data-card-data");
        return {
          url: anchor.getAttribute("data-card-url"),
          data: data ? JSON.parse(data) : null
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-inline-card": "",
      href: node.attrs.url || "",
      "data-card-data": node.attrs.data ? JSON.stringify(node.attrs.data) : ""
    };
    if (node.attrs.url) {
      return ["a", attrs, node.attrs.url];
    } else {
      return ["a", attrs];
    }
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/block-card.js
var blockCard = {
  inline: false,
  group: "block",
  draggable: true,
  selectable: true,
  attrs: {
    url: { default: null },
    data: { default: null }
  },
  parseDOM: [
    {
      tag: "a[data-block-card]",
      // bump priority higher than hyperlink
      priority: 100,
      getAttrs: function(dom) {
        var anchor = dom;
        var data = anchor.getAttribute("data-card-data");
        return {
          url: anchor.getAttribute("href") || null,
          data: data ? JSON.parse(data) : null
        };
      }
    },
    {
      tag: "div[data-block-card]",
      getAttrs: function(dom) {
        var anchor = dom;
        var data = anchor.getAttribute("data-card-data");
        return {
          url: anchor.getAttribute("data-card-url") || null,
          data: data ? JSON.parse(data) : null
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-block-card": "",
      href: node.attrs.url || "",
      "data-card-data": node.attrs.data ? JSON.stringify(node.attrs.data) : ""
    };
    return ["a", attrs];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/unsupported-block.js
var unsupportedBlock = {
  inline: false,
  group: "block",
  atom: true,
  selectable: true,
  attrs: {
    originalValue: { default: {} }
  },
  parseDOM: [
    {
      tag: '[data-node-type="unsupportedBlock"]',
      getAttrs: function(dom) {
        return {
          originalValue: JSON.parse(dom.getAttribute("data-original-value") || "{}")
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "unsupportedBlock",
      "data-original-value": JSON.stringify(node.attrs.originalValue)
    };
    return ["div", attrs, "Unsupported content"];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/unsupported-inline.js
var unsupportedInline = {
  inline: true,
  group: "inline",
  selectable: true,
  attrs: {
    originalValue: { default: {} }
  },
  parseDOM: [
    {
      tag: '[data-node-type="unsupportedInline"]',
      getAttrs: function(dom) {
        return {
          originalValue: JSON.parse(dom.getAttribute("data-original-value") || "{}")
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "unsupportedInline",
      "data-original-value": JSON.stringify(node.attrs.originalValue)
    };
    return ["span", attrs, "Unsupported content"];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/status.js
var status = {
  inline: true,
  group: "inline",
  selectable: true,
  attrs: {
    text: { default: "" },
    color: { default: "" },
    localId: { default: uuid.generate() },
    style: { default: "" }
  },
  parseDOM: [
    {
      tag: 'span[data-node-type="status"]',
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          text: dom.textContent.replace(/\n/, "").trim(),
          color: dom.getAttribute("data-color"),
          localId: uuid.generate(),
          style: dom.getAttribute("data-style")
        };
      }
    }
  ],
  toDOM: function(node) {
    var _a2 = node.attrs, text2 = _a2.text, color = _a2.color, localId = _a2.localId, style = _a2.style;
    var attrs = {
      "data-node-type": "status",
      "data-color": color,
      "data-local-id": localId,
      "data-style": style,
      contenteditable: "false"
    };
    return ["span", attrs, text2];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/expand.js
function getExpandAttrs(domNode) {
  var dom = domNode;
  return {
    title: dom.getAttribute("data-title"),
    __expanded: true
  };
}
var expand = {
  inline: false,
  group: "block",
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | extension | unsupportedBlock)+",
  isolating: true,
  selectable: true,
  attrs: {
    title: { default: "" },
    __expanded: { default: true }
  },
  parseDOM: [
    {
      context: "table//",
      tag: 'div[data-node-type="expand"]',
      getAttrs: getExpandAttrs
    },
    {
      context: "expand//",
      tag: '[data-node-type="expand"]',
      skip: true
    },
    {
      context: "nestedExpand//",
      tag: '[data-node-type="expand"]',
      skip: true
    },
    {
      tag: '[data-node-type="nestedExpand"] button',
      ignore: true
    },
    {
      tag: '[data-node-type="expand"] button',
      ignore: true
    },
    {
      tag: 'div[data-node-type="expand"]',
      getAttrs: getExpandAttrs
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "expand",
      "data-title": node.attrs.title,
      "data-expanded": node.attrs.__expanded
    };
    return ["div", attrs, 0];
  }
};
var toJSON5 = function(node) {
  return {
    attrs: Object.keys(node.attrs).filter(function(key) {
      return !key.startsWith("__");
    }).reduce(function(obj, key) {
      obj[key] = node.attrs[key];
      return obj;
    }, {})
  };
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/nested-expand.js
var nestedExpand = {
  inline: false,
  content: "(paragraph | heading | mediaSingle | mediaGroup | unsupportedBlock)+",
  isolating: true,
  selectable: true,
  attrs: {
    title: { default: "" },
    __expanded: { default: true }
  },
  parseDOM: [
    {
      context: "nestedExpand//",
      tag: '[data-node-type="nestedExpand"]',
      skip: true
    },
    {
      tag: '[data-node-type="nestedExpand"] button',
      ignore: true
    },
    {
      tag: '[data-node-type="expand"] button',
      ignore: true
    },
    {
      tag: 'div[data-node-type="nestedExpand"]',
      getAttrs: function(domNode) {
        var dom = domNode;
        return {
          title: dom.getAttribute("data-title"),
          __expanded: true
        };
      }
    }
  ],
  toDOM: function(node) {
    var attrs = {
      "data-node-type": "nestedExpand",
      "data-title": node.attrs.title,
      "data-expanded": node.attrs.__expanded
    };
    return ["div", attrs, 0];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/groups.js
var FONT_STYLE = "fontStyle";
var SEARCH_QUERY = "searchQuery";
var LINK = "link";
var COLOR = "color";
var ALIGNMENT = "alignment";
var INDENTATION = "indentation";

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/em.js
var emDOM = ["em"];
var em = {
  inclusive: true,
  group: FONT_STYLE,
  parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }],
  toDOM: function() {
    return emDOM;
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/code.js
var code = {
  excludes: FONT_STYLE + " " + LINK + " " + SEARCH_QUERY + " " + COLOR,
  inclusive: true,
  parseDOM: [
    { tag: "span.code", preserveWhitespace: true },
    { tag: "code", preserveWhitespace: true },
    { tag: "tt", preserveWhitespace: true },
    {
      tag: "span",
      preserveWhitespace: true,
      getAttrs: function(domNode) {
        var dom = domNode;
        if (dom.style.whiteSpace === "pre") {
          return {};
        }
        if (dom.style.fontFamily && dom.style.fontFamily.toLowerCase().indexOf("monospace") >= 0) {
          return {};
        }
        return false;
      }
    }
  ],
  toDOM: function() {
    return [
      "span",
      {
        style: "white-space: pre-wrap;",
        class: "code"
      }
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/strike.js
var strike = {
  inclusive: true,
  group: FONT_STYLE,
  parseDOM: [
    { tag: "strike" },
    { tag: "s" },
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: function(value) {
        return value === "line-through" && null;
      }
    }
  ],
  toDOM: function() {
    return ["s"];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/strong.js
var strongDOM = ["strong"];
var strong = {
  inclusive: true,
  group: FONT_STYLE,
  parseDOM: [
    { tag: "strong" },
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: function(node) {
        var element = node;
        return element.style.fontWeight !== "normal" && null;
      }
    },
    {
      style: "font-weight",
      getAttrs: function(value) {
        return typeof value === "string" && /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
      }
    }
  ],
  toDOM: function() {
    return strongDOM;
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/underline.js
var underline = {
  inclusive: true,
  group: FONT_STYLE,
  parseDOM: [
    { tag: "u" },
    {
      style: "text-decoration",
      getAttrs: function(value) {
        return value === "underline" && null;
      }
    }
  ],
  toDOM: function() {
    return ["u"];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/utils/url.js
var import_linkify_it = __toESM(require_linkify_it());
var whitelistedURLPatterns = [
  /^https?:\/\//im,
  /^ftps?:\/\//im,
  /^\//im,
  /^mailto:/im,
  /^skype:/im,
  /^callto:/im,
  /^facetime:/im,
  /^git:/im,
  /^irc6?:/im,
  /^news:/im,
  /^nntp:/im,
  /^feed:/im,
  /^cvs:/im,
  /^svn:/im,
  /^mvn:/im,
  /^ssh:/im,
  /^scp:\/\//im,
  /^sftp:\/\//im,
  /^itms:/im,
  /^notes:/im,
  /^hipchat:\/\//im,
  /^sourcetree:/im,
  /^urn:/im,
  /^tel:/im,
  /^xmpp:/im,
  /^telnet:/im,
  /^vnc:/im,
  /^rdp:/im,
  /^whatsapp:/im,
  /^slack:/im,
  /^sips?:/im,
  /^magnet:/im
];
var isSafeUrl = function(url) {
  return whitelistedURLPatterns.some(function(p) {
    return p.test(url.trim()) === true;
  });
};
var linkify = (0, import_linkify_it.default)();
linkify.add("sourcetree:", "http:");
function getLinkMatch(str) {
  var match = str && linkify.match(str);
  return match && match[0];
}
function normalizeUrl(url) {
  var match = getLinkMatch(url);
  return match && match.url || url;
}

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/link.js
var link = {
  excludes: LINK + " " + COLOR,
  group: LINK,
  attrs: {
    href: {},
    __confluenceMetadata: {
      default: null
    }
  },
  inclusive: false,
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: function(domNode) {
        var dom = domNode;
        var href = dom.getAttribute("href") || "";
        var attrs = {
          __confluenceMetadata: dom.hasAttribute("__confluenceMetadata") ? JSON.parse(dom.getAttribute("__confluenceMetadata") || "") : void 0
        };
        if (isSafeUrl(href)) {
          attrs.href = normalizeUrl(href);
        } else {
          return false;
        }
        return attrs;
      }
    }
  ],
  toDOM: function(node, isInline) {
    var attrs = Object.keys(node.attrs).reduce(function(attrs2, key) {
      if (key === "__confluenceMetadata") {
        if (node.attrs[key] !== null) {
          attrs2[key] = JSON.stringify(node.attrs[key]);
        }
      } else {
        attrs2[key] = node.attrs[key];
      }
      return attrs2;
    }, {});
    if (isInline) {
      return ["a", attrs];
    }
    return [
      "a",
      __assign(__assign({}, attrs), { class: "blockLink" }),
      0
    ];
  }
};
var OPTIONAL_ATTRS = [
  "title",
  "id",
  "collection",
  "occurrenceKey",
  "__confluenceMetadata"
];
var toJSON6 = function(mark) {
  return {
    type: mark.type.name,
    attrs: Object.keys(mark.attrs).reduce(function(attrs, key) {
      if (OPTIONAL_ATTRS.indexOf(key) === -1 || mark.attrs[key] !== null) {
        attrs[key] = mark.attrs[key];
      }
      return attrs;
    }, {})
  };
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/type-ahead-query.js
var typeAheadQuery = {
  inclusive: true,
  group: SEARCH_QUERY,
  parseDOM: [{ tag: "span[data-type-ahead-query]" }],
  toDOM: function(node) {
    return [
      "span",
      {
        "data-type-ahead-query": "true",
        "data-trigger": node.attrs.trigger,
        style: "color: " + B400
      }
    ];
  },
  attrs: {
    trigger: { default: "" }
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/subsup.js
function getAttrFromVerticalAlign(node) {
  if (node.style.verticalAlign) {
    var type = node.style.verticalAlign.slice(0, 3);
    if (type === "sub" || type === "sup") {
      return { type };
    }
  }
  return false;
}
var subsup = {
  inclusive: true,
  group: FONT_STYLE,
  attrs: { type: { default: "sub" } },
  parseDOM: [
    { tag: "sub", attrs: { type: "sub" } },
    { tag: "sup", attrs: { type: "sup" } },
    {
      // Special case for pasting from Google Docs
      // Google Docs uses vertical align to denote subscript and super script
      tag: "span",
      style: "vertical-align=super",
      getAttrs: function(node) {
        return getAttrFromVerticalAlign(node);
      }
    },
    {
      tag: "span",
      style: "vertical-align=sub",
      getAttrs: function(node) {
        return getAttrFromVerticalAlign(node);
      }
    }
  ],
  toDOM: function(mark) {
    return [mark.attrs.type];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/text-color.js
var _a;
var borderColorPalette = (_a = {}, _a[N80] = N90, _a[P300] = P500, _a[T300] = T500, _a[G300] = G500, _a[R300] = R500, _a[Y400] = Y500, _a);
var colorPalette = /* @__PURE__ */ new Map();
var colorArrayPalette = [
  // [N800, default],
  [N80, "Light gray"],
  [P300, "Purple"],
  [T300, "Teal"],
  [G300, "Green"],
  [R300, "Red"],
  [Y400, "Orange"]
];
colorArrayPalette.forEach(function(_a2) {
  var _b = __read(_a2, 2), color = _b[0], label = _b[1];
  return colorPalette.set(color.toLowerCase(), label);
});
var textColor = {
  attrs: { color: {} },
  inclusive: true,
  group: COLOR,
  parseDOM: [
    {
      style: "color",
      getAttrs: function(maybeValue) {
        var value = maybeValue;
        var hexColor;
        if (value.match(/^rgb/i)) {
          hexColor = rgbToHex(value);
        } else if (value[0] === "#") {
          hexColor = value.toLowerCase();
        }
        return hexColor && colorPalette.has(hexColor) ? { color: hexColor } : false;
      }
    }
  ],
  toDOM: function(mark) {
    return [
      "span",
      {
        style: "color: " + mark.attrs.color
      }
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/confluence-inline-comment.js
var confluenceInlineComment = {
  inclusive: false,
  excludes: "",
  attrs: {
    reference: {
      default: ""
    }
  },
  parseDOM: [{ tag: 'span[data-mark-type="confluenceInlineComment"]' }],
  toDOM: function(node) {
    return [
      "span",
      {
        "data-mark-type": "confluenceInlineComment",
        "data-reference": node.attrs.reference
      }
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/breakout.js
var allowedTypes = ["wide", "full-width"];
var breakout = {
  spanning: false,
  parseDOM: [
    {
      tag: "div.fabric-editor-breakout-mark",
      getAttrs: function(dom) {
        var mode = dom.getAttribute("data-mode");
        return {
          mode: allowedTypes.indexOf(mode || "") === -1 ? "wide" : mode
        };
      }
    }
  ],
  attrs: {
    mode: { default: "wide" }
  },
  toDOM: function(mark) {
    return [
      "div",
      { class: "fabric-editor-breakout-mark", "data-mode": mark.attrs.mode },
      0
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/alignment.js
var alignmentPositionMap = {
  end: "right",
  right: "end",
  center: "center"
};
var alignment = {
  excludes: "alignment " + INDENTATION,
  group: ALIGNMENT,
  attrs: {
    align: {}
  },
  parseDOM: [
    {
      tag: "div.fabric-editor-block-mark",
      getAttrs: function(dom) {
        var align = dom.getAttribute("data-align");
        return align ? { align } : false;
      }
    }
  ],
  toDOM: function(mark) {
    return [
      "div",
      {
        class: "fabric-editor-block-mark fabric-editor-align-" + mark.attrs.align,
        "data-align": mark.attrs.align
      },
      0
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/indentation.js
var indentation = {
  excludes: "indentation " + ALIGNMENT,
  group: INDENTATION,
  attrs: {
    level: {}
  },
  parseDOM: [
    {
      tag: "div.fabric-editor-indentation-mark",
      getAttrs: function(dom) {
        var level = +(dom.getAttribute("data-level") || "0");
        return {
          level: level > 6 ? 6 : level < 1 ? false : level
        };
      }
    }
  ],
  toDOM: function(mark) {
    return [
      "div",
      {
        class: "fabric-editor-block-mark fabric-editor-indentation-mark",
        "data-level": mark.attrs.level
      },
      0
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/annotation.js
var INLINE_COMMENT = "inlineComment";
var annotation = {
  inclusive: false,
  group: "annotation",
  excludes: "",
  attrs: {
    id: {
      default: ""
    },
    annotationType: {
      default: INLINE_COMMENT
    }
  },
  parseDOM: [
    {
      tag: 'span[data-mark-type="annotation"]',
      getAttrs: function(dom) {
        var elem = dom;
        var annotationType = elem.getAttribute("data-mark-annotation-type");
        if (!annotationType) {
          return false;
        }
        return {
          id: elem.getAttribute("data-id"),
          annotationType
        };
      }
    }
  ],
  toDOM: function(node) {
    return [
      "span",
      {
        // Prettier will remove the quotes around class. This would cause some browsers
        // to not add this attribute properly, as its a reserved word.
        // prettier-ignore
        "class": "fabric-editor-annotation",
        "data-mark-type": "annotation",
        "data-mark-annotation-type": node.attrs.annotationType,
        "data-id": node.attrs.id
      },
      0
    ];
  }
};

// node_modules/@atlaskit/adf-schema/dist/esm/schema/unsupported.js
var unsupportedNodeTypesForMediaCards = /* @__PURE__ */ new Set([
  "decisionItem",
  "taskItem"
]);

// node_modules/@atlaskit/adf-schema/dist/esm/schema/inline-nodes.js
var typedNodes = nodes_exports;
var inlineNodes = new Set(Object.keys(typedNodes).filter(function(key) {
  return typedNodes[key] && typedNodes[key].group === "inline";
}));

// node_modules/@atlaskit/adf-schema/dist/esm/schema/create-schema.js
function addItems(builtInItems, config, customSpecs) {
  if (customSpecs === void 0) {
    customSpecs = {};
  }
  if (!config) {
    return {};
  }
  var items = builtInItems.reduce(function(items2, _a2) {
    var name7 = _a2.name, spec = _a2.spec;
    if (config.indexOf(name7) !== -1) {
      items2[name7] = customSpecs[name7] || spec;
    }
    return items2;
  }, {});
  return Object.keys(customSpecs).reduce(function(items2, name7) {
    if (items2[name7]) {
      return items2;
    }
    items2[name7] = customSpecs[name7];
    return items2;
  }, items);
}
function groupDeclaration(name7) {
  return {
    name: "__" + name7 + "GroupDeclaration",
    spec: {
      group: name7
    }
  };
}
var markGroupDeclarations = [
  groupDeclaration(COLOR),
  groupDeclaration(FONT_STYLE),
  groupDeclaration(SEARCH_QUERY),
  groupDeclaration(LINK)
];
var markGroupDeclarationsNames = markGroupDeclarations.map(function(groupMark) {
  return groupMark.name;
});
var nodesInOrder = [
  { name: "doc", spec: doc },
  { name: "paragraph", spec: paragraph },
  { name: "text", spec: text },
  { name: "bulletList", spec: bulletList },
  { name: "orderedList", spec: orderedList },
  { name: "listItem", spec: listItem },
  { name: "heading", spec: heading },
  { name: "blockquote", spec: blockquote },
  { name: "codeBlock", spec: codeBlock },
  { name: "panel", spec: panel },
  { name: "rule", spec: rule },
  { name: "image", spec: image },
  { name: "mention", spec: mention },
  { name: "media", spec: media },
  { name: "mediaGroup", spec: mediaGroup },
  { name: "mediaSingle", spec: mediaSingle },
  { name: "placeholder", spec: placeholder },
  { name: "layoutSection", spec: layoutSection },
  { name: "layoutColumn", spec: layoutColumn },
  { name: "hardBreak", spec: hardBreak },
  { name: "emoji", spec: emoji },
  { name: "table", spec: table },
  { name: "tableCell", spec: tableCell },
  { name: "tableRow", spec: tableRow },
  { name: "tableHeader", spec: tableHeader },
  { name: "confluenceJiraIssue", spec: confluenceJiraIssue },
  { name: "confluenceUnsupportedInline", spec: confluenceUnsupportedInline },
  { name: "confluenceUnsupportedBlock", spec: confluenceUnsupportedBlock },
  { name: "decisionList", spec: decisionList },
  { name: "decisionItem", spec: decisionItem },
  { name: "taskList", spec: taskList },
  { name: "taskList", spec: nestableTaskList },
  { name: "taskItem", spec: taskItem },
  { name: "date", spec: date },
  { name: "status", spec: status },
  { name: "expand", spec: expand },
  { name: "nestedExpand", spec: nestedExpand },
  { name: "extension", spec: extension },
  { name: "inlineExtension", spec: inlineExtension },
  { name: "bodiedExtension", spec: bodiedExtension },
  { name: "inlineCard", spec: inlineCard },
  { name: "blockCard", spec: blockCard },
  { name: "unknownBlock", spec: unknown_block_default },
  { name: "unsupportedBlock", spec: unsupportedBlock },
  { name: "unsupportedInline", spec: unsupportedInline }
];
var marksInOrder = __spread([
  { name: "link", spec: link },
  { name: "em", spec: em },
  { name: "strong", spec: strong },
  { name: "textColor", spec: textColor },
  { name: "strike", spec: strike },
  { name: "subsup", spec: subsup },
  { name: "underline", spec: underline },
  { name: "code", spec: code },
  { name: "typeAheadQuery", spec: typeAheadQuery },
  { name: "alignment", spec: alignment },
  { name: "annotation", spec: annotation },
  { name: "confluenceInlineComment", spec: confluenceInlineComment }
], markGroupDeclarations, [
  { name: "breakout", spec: breakout },
  { name: "indentation", spec: indentation }
]);
function createSchema(config) {
  var customNodeSpecs = config.customNodeSpecs, customMarkSpecs = config.customMarkSpecs;
  var nodesConfig = Object.keys(customNodeSpecs || {}).concat(config.nodes);
  var marksConfig = Object.keys(customMarkSpecs || {}).concat(config.marks || []).concat(markGroupDeclarationsNames);
  var nodes2 = addItems(nodesInOrder, nodesConfig, customNodeSpecs);
  var marks2 = addItems(marksInOrder, marksConfig, customMarkSpecs);
  nodes2 = sanitizeNodes(nodes2, marks2);
  return new Schema({
    nodes: nodes2,
    marks: marks2
  });
}
function sanitizeNodes(nodes2, supportedMarks) {
  var nodeNames = Object.keys(nodes2);
  nodeNames.forEach(function(nodeKey) {
    var nodeSpec = __assign({}, nodes2[nodeKey]);
    if (nodeSpec.marks && nodeSpec.marks !== "_") {
      nodeSpec.marks = nodeSpec.marks.split(" ").filter(function(mark) {
        return !!supportedMarks[mark];
      }).join(" ");
    }
    if (nodeSpec.content) {
      var content = nodeSpec.content.replace(/\W/g, " ");
      var contentKeys = content.split(" ");
      var unsupportedContentKeys = contentKeys.filter(function(contentKey) {
        return !isContentSupported(nodes2, contentKey);
      });
      nodeSpec.content = unsupportedContentKeys.reduce(function(newContent, nodeName) {
        return sanitizedContent(newContent, nodeName);
      }, nodeSpec.content);
    }
    nodes2[nodeKey] = nodeSpec;
  });
  return nodes2;
}
function sanitizedContent(content, invalidContent) {
  if (!invalidContent.length) {
    return content || "";
  }
  if (!content || !content.match(/\w/)) {
    return "";
  }
  var newContent = content.replace(new RegExp("(" + invalidContent + "((\\s)*\\|)+)|((\\|(\\s)*)+" + invalidContent + ")|(" + invalidContent + "$)", "g"), "").replace("  ", " ").trim();
  return newContent;
}
function isContentSupported(nodes2, contentKey) {
  var nodeKeys = Object.keys(nodes2);
  if (nodeKeys.indexOf(contentKey) > -1) {
    return true;
  }
  for (var supportedKey in nodes2) {
    var nodeSpec = nodes2[supportedKey];
    if (nodeSpec && nodeSpec.group === contentKey) {
      return true;
    }
  }
  return false;
}

// node_modules/@atlaskit/adf-schema/dist/esm/schema/bitbucket-schema.js
var bitbucketSchema = createSchema({
  nodes: [
    "doc",
    "paragraph",
    "text",
    "bulletList",
    "orderedList",
    "listItem",
    "heading",
    "blockquote",
    "codeBlock",
    "hardBreak",
    "rule",
    "image",
    "media",
    "mediaSingle",
    "mention",
    "emoji",
    "table",
    "tableCell",
    "tableHeader",
    "tableRow"
  ],
  marks: ["em", "strong", "strike", "link", "code"]
});

// node_modules/@atlaskit/adf-schema/dist/esm/schema/confluence-schema.js
var nodes = [
  "doc",
  "paragraph",
  "blockquote",
  "codeBlock",
  "panel",
  "hardBreak",
  "orderedList",
  "bulletList",
  "heading",
  "mediaGroup",
  "mediaSingle",
  "media",
  "confluenceUnsupportedBlock",
  "confluenceJiraIssue",
  "expand",
  "nestedExpand",
  "extension",
  "inlineExtension",
  "bodiedExtension",
  "listItem",
  "mention",
  "text",
  "confluenceUnsupportedInline",
  "media",
  "rule",
  "table",
  "tableCell",
  "tableHeader",
  "tableRow",
  "emoji",
  "taskList",
  "taskItem",
  "date",
  "placeholder",
  "decisionList",
  "decisionItem",
  "layoutSection",
  "layoutColumn",
  "inlineCard",
  "unsupportedBlock",
  "unsupportedInline"
];
var marks = [
  "link",
  "em",
  "strong",
  "strike",
  "subsup",
  "underline",
  "mentionQuery",
  "code",
  "textColor",
  "confluenceInlineComment",
  "annotation"
];
var confluenceSchema = createSchema({ nodes, marks });
var confluenceSchemaWithMediaSingle = createSchema({
  nodes: nodes.concat("mediaSingle"),
  marks
});

// node_modules/@atlaskit/adf-schema/dist/esm/schema/default-schema.js
var getSchemaBasedOnStage = function(stage) {
  if (stage === void 0) {
    stage = "final";
  }
  var config = {
    nodes: [
      "doc",
      "paragraph",
      "text",
      "bulletList",
      "orderedList",
      "listItem",
      "heading",
      "blockquote",
      "codeBlock",
      "panel",
      "rule",
      "image",
      "mention",
      "media",
      "mediaGroup",
      "mediaSingle",
      "confluenceUnsupportedBlock",
      "confluenceUnsupportedInline",
      "confluenceJiraIssue",
      "expand",
      "nestedExpand",
      "extension",
      "inlineExtension",
      "bodiedExtension",
      "hardBreak",
      "emoji",
      "table",
      "tableCell",
      "tableHeader",
      "tableRow",
      "decisionList",
      "decisionItem",
      "taskList",
      "taskItem",
      "unknownBlock",
      "date",
      "status",
      "placeholder",
      "layoutSection",
      "layoutColumn",
      "inlineCard",
      "blockCard",
      "unsupportedBlock",
      "unsupportedInline"
    ],
    marks: [
      "link",
      "em",
      "strong",
      "strike",
      "subsup",
      "underline",
      "code",
      "textColor",
      "confluenceInlineComment",
      "breakout",
      "alignment",
      "indentation",
      "annotation"
    ]
  };
  if (stage === "stage0") {
    config.customNodeSpecs = {
      media: mediaWithAltText
    };
  }
  return createSchema(config);
};
var defaultSchema = getSchemaBasedOnStage();

// node_modules/@atlaskit/adf-schema/dist/esm/schema/jira-schema.js
function makeSchema(config) {
  var nodes2 = ["doc", "paragraph", "text", "hardBreak", "heading", "rule"];
  var marks2 = ["strong", "em", "underline", "typeAheadQuery"];
  if (config.allowLinks) {
    marks2.push("link");
  }
  if (config.allowLists) {
    nodes2.push("orderedList", "bulletList", "listItem");
  }
  if (config.allowMentions) {
    nodes2.push("mention");
    marks2.push("mentionQuery");
  }
  if (config.allowEmojis) {
    nodes2.push("emoji");
  }
  if (config.allowAdvancedTextFormatting) {
    marks2.push("strike", "code");
  }
  if (config.allowSubSup) {
    marks2.push("subsup");
  }
  if (config.allowCodeBlock) {
    nodes2.push("codeBlock");
  }
  if (config.allowBlockQuote) {
    nodes2.push("blockquote");
  }
  if (config.allowMedia) {
    nodes2.push("mediaGroup", "mediaSingle", "media");
  }
  if (config.allowTextColor) {
    marks2.push("textColor");
  }
  if (config.allowTables) {
    nodes2.push("table", "tableCell", "tableHeader", "tableRow");
  }
  return createSchema({ nodes: nodes2, marks: marks2 });
}
function isSchemaWithLists(schema) {
  return !!schema.nodes.bulletList;
}
function isSchemaWithMentions(schema) {
  return !!schema.nodes.mention;
}
function isSchemaWithEmojis(schema) {
  return !!schema.nodes.emoji;
}
function isSchemaWithLinks(schema) {
  return !!schema.marks.link;
}
function isSchemaWithAdvancedTextFormattingMarks(schema) {
  return !!schema.marks.code && !!schema.marks.strike;
}
function isSchemaWithSubSupMark(schema) {
  return !!schema.marks.subsup;
}
function isSchemaWithCodeBlock(schema) {
  return !!schema.nodes.codeBlock;
}
function isSchemaWithBlockQuotes(schema) {
  return !!schema.nodes.blockquote;
}
function isSchemaWithMedia(schema) {
  return !!schema.nodes.mediaGroup && !!schema.nodes.media;
}
function isSchemaWithTextColor(schema) {
  return !!schema.marks.textColor;
}
function isSchemaWithTables(schema) {
  return !!schema.nodes.table && !!schema.nodes.tableCell && !!schema.nodes.tableHeader && !!schema.nodes.tableRow;
}

// node_modules/@atlaskit/adf-schema/dist/esm/utils/languageList.js
var DEFAULT_LANGUAGES = [
  { name: "ABAP", alias: ["abap"] },
  { name: "ActionScript", alias: ["actionscript", "actionscript3", "as"] },
  { name: "Ada", alias: ["ada", "ada95", "ada2005"] },
  { name: "AppleScript", alias: ["applescript"] },
  { name: "Arduino", alias: ["arduino"] },
  { name: "Autoit", alias: ["autoit"] },
  { name: "C", alias: ["c"] },
  { name: "C++", alias: ["c++", "cpp"] },
  { name: "Clojure", alias: ["clojure", "clj"] },
  { name: "CoffeeScript", alias: ["coffeescript", "coffee-script", "coffee"] },
  { name: "ColdFusion", alias: ["coldfusion"] },
  { name: "CSharp", alias: ["csharp", "c#"] },
  { name: "CSS", alias: ["css"] },
  { name: "CUDA", alias: ["cuda", "cu"] },
  { name: "D", alias: ["d"] },
  { name: "Dart", alias: ["dart"] },
  { name: "Delphi", alias: ["delphi", "pas", "pascal", "objectpascal"] },
  { name: "Diff", alias: ["diff"] },
  { name: "Elixir", alias: ["elixir", "ex", "exs"] },
  { name: "Erlang", alias: ["erlang", "erl"] },
  { name: "Fortran", alias: ["fortran"] },
  { name: "FoxPro", alias: ["foxpro", "vfp", "clipper", "xbase"] },
  { name: "Go", alias: ["go"] },
  { name: "GraphQL", alias: ["graphql"] },
  { name: "Groovy", alias: ["groovy"] },
  { name: "Haskell", alias: ["haskell", "hs"] },
  { name: "Haxe", alias: ["haxe", "hx", "hxsl"] },
  { name: "Html", alias: ["html"] },
  { name: "Java", alias: ["java"] },
  { name: "JavaFX", alias: ["javafx", "jfx"] },
  { name: "JavaScript", alias: ["javascript", "js"] },
  { name: "JSON", alias: ["json"] },
  { name: "Julia", alias: ["julia", "jl"] },
  { name: "Kotlin", alias: ["kotlin"] },
  { name: "LiveScript", alias: ["livescript", "live-script"] },
  { name: "Lua", alias: ["lua"] },
  { name: "Mathematica", alias: ["mathematica", "mma", "nb"] },
  { name: "MATLAB", alias: ["matlab"] },
  {
    name: "Objective-C",
    alias: ["objective-c", "objectivec", "obj-c", "objc"]
  },
  {
    name: "Objective-J",
    alias: ["objective-j", "objectivej", "obj-j", "objj"]
  },
  { name: "ObjectPascal", alias: ["objectpascal"] },
  { name: "OCaml", alias: ["ocaml"] },
  { name: "Octave", alias: ["octave"] },
  { name: "Perl", alias: ["perl", "pl"] },
  { name: "PHP", alias: ["php", "php3", "php4", "php5"] },
  { name: "PlainText", alias: ["plaintext", "text"] },
  { name: "PowerShell", alias: ["powershell", "posh", "ps1", "psm1"] },
  { name: "Prolog", alias: ["prolog"] },
  { name: "Puppet", alias: ["puppet"] },
  { name: "Python", alias: ["python", "py"] },
  { name: "QML", alias: ["qbs"] },
  { name: "R", alias: ["r"] },
  { name: "Racket", alias: ["racket", "rkt"] },
  { name: "reStructuredText", alias: ["restructuredtext", "rst", "rest"] },
  { name: "Ruby", alias: ["ruby", "rb", "duby"] },
  { name: "Rust", alias: ["rust"] },
  { name: "Sass", alias: ["sass"] },
  { name: "Scala", alias: ["scala"] },
  { name: "Scheme", alias: ["scheme", "scm"] },
  { name: "Shell", alias: ["shell", "bash", "sh", "ksh", "zsh"] },
  { name: "Smalltalk", alias: ["smalltalk", "squeak", "st"] },
  {
    name: "SQL",
    alias: [
      "sql",
      "postgresql",
      "postgres",
      "plpgsql",
      "psql",
      "postgresql-console",
      "postgres-console",
      "tsql",
      "t-sql",
      "mysql",
      "sqlite"
    ]
  },
  { name: "StandardML", alias: ["standardmL", "sml"] },
  { name: "Swift", alias: ["swift"] },
  { name: "Tcl", alias: ["tcl"] },
  { name: "TeX", alias: ["tex", "latex"] },
  { name: "TypeScript", alias: ["typescript", "ts"] },
  { name: "Vala", alias: ["vala", "vapi"] },
  { name: "VbNet", alias: ["vbnet", "vb.net"] },
  { name: "Verilog", alias: ["verilog", "v"] },
  { name: "VHDL", alias: ["vhdl"] },
  { name: "VisualBasic", alias: ["visualbasic", "vb"] },
  { name: "XML", alias: ["xml"] },
  { name: "XQuery", alias: ["xquery", "xqy", "xq", "xql", "xqm"] },
  { name: "YAML", alias: ["yaml", "yml"] }
];
function findMatchedLanguage(supportedLanguages, language) {
  if (!language) {
    return void 0;
  }
  var matches = supportedLanguages.filter(function(supportedLanguage) {
    return supportedLanguage.alias.indexOf(language.toLowerCase()) !== -1;
  });
  if (matches.length > 0) {
    return matches[0];
  }
  return void 0;
}
function filterSupportedLanguages(supportedLanguages) {
  if (!supportedLanguages || !supportedLanguages.length) {
    return DEFAULT_LANGUAGES;
  }
  return DEFAULT_LANGUAGES.filter(function(language) {
    var i = language.alias.length;
    while (i--) {
      if (supportedLanguages.indexOf(language.alias[i]) > -1) {
        return true;
      }
    }
    return false;
  });
}
function getLanguageIdentifier(language) {
  return language.alias[0];
}
function createLanguageList(supportedLanguages) {
  return supportedLanguages.sort(function(left, right) {
    if (left.name > right.name) {
      return 1;
    }
    if (left.name < right.name) {
      return -1;
    }
    return 0;
  });
}
export {
  B100,
  B400,
  B50,
  B500,
  B75,
  DEFAULT_LANGUAGES,
  G200,
  G300,
  G400,
  G50,
  G500,
  G75,
  INLINE_COMMENT,
  N0,
  N20,
  N200,
  N30,
  N300,
  N40,
  N50,
  N500,
  N60,
  N80,
  N800,
  N90,
  P100,
  P300,
  P400,
  P50,
  P500,
  P75,
  R100,
  R300,
  R400,
  R50,
  R500,
  R75,
  T100,
  T300,
  T50,
  T500,
  T75,
  Y200,
  Y400,
  Y50,
  Y500,
  Y75,
  acNameToEmoji,
  acShortcutToEmoji,
  alignment,
  alignmentPositionMap,
  annotation,
  bitbucketSchema,
  blockCard,
  blockquote,
  bodiedExtension,
  borderColorPalette,
  breakout,
  bulletList,
  bulletListSelector,
  code,
  codeBlock,
  toJSON as codeBlockToJSON,
  colorPalette,
  confluenceInlineComment,
  confluenceJiraIssue,
  confluenceSchema,
  confluenceSchemaWithMediaSingle,
  confluenceUnsupportedBlock,
  confluenceUnsupportedInline,
  copyPrivateAttributes as copyPrivateMediaAttributes,
  makeSchema as createJIRASchema,
  createLanguageList,
  createSchema,
  date,
  decisionItem,
  decisionList,
  decisionListSelector,
  defaultSchema,
  doc,
  em,
  emoji,
  emojiIdToAcName,
  expand,
  toJSON5 as expandToJSON,
  extension,
  filterSupportedLanguages,
  findMatchedLanguage,
  generateUuid,
  getEmojiAcName,
  getLanguageIdentifier,
  getLinkMatch,
  getSchemaBasedOnStage,
  hardBreak,
  heading,
  hexToRgb,
  hexToRgba,
  image,
  indentation,
  inlineCard,
  inlineExtension,
  inlineNodes,
  isHex,
  isRgb,
  isSafeUrl,
  isSchemaWithAdvancedTextFormattingMarks,
  isSchemaWithBlockQuotes,
  isSchemaWithCodeBlock,
  isSchemaWithEmojis,
  isSchemaWithLinks,
  isSchemaWithLists,
  isSchemaWithMedia,
  isSchemaWithMentions,
  isSchemaWithSubSupMark,
  isSchemaWithTables,
  isSchemaWithTextColor,
  layoutColumn,
  layoutSection,
  link,
  toJSON6 as linkToJSON,
  listItem,
  media,
  mediaGroup,
  mediaSingle,
  toJSON4 as mediaSingleToJSON,
  toJSON3 as mediaToJSON,
  mediaWithAltText,
  mention,
  toJSON2 as mentionToJSON,
  nestableTaskList,
  nestedExpand,
  normalizeHexColor,
  normalizeUrl,
  orderedList,
  orderedListSelector,
  panel,
  paragraph,
  placeholder,
  rgbToHex,
  rule,
  sanitizeNodes,
  setCellAttrs,
  status,
  strike,
  strong,
  subsup,
  table,
  tableBackgroundBorderColor,
  tableBackgroundColorNames,
  tableBackgroundColorPalette,
  tableCell,
  tableCellContentDomSelector,
  tableCellContentWrapperSelector,
  tableCellSelector,
  tableHeader,
  tableHeaderSelector,
  tablePrefixSelector,
  tableRow,
  tableToJSON,
  taskItem,
  taskList,
  taskListSelector,
  text,
  textColor,
  toJSONTableCell,
  toJSONTableHeader,
  typeAheadQuery,
  underline,
  unknown_block_default as unknownBlock,
  unsupportedBlock,
  unsupportedInline,
  unsupportedNodeTypesForMediaCards,
  uuid
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@atlaskit_adf-schema.js.map
