import {
  _arrayLikeToArray,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _slicedToArray,
  _unsupportedIterableToArray,
  getBooleanFF,
  memoizeOne
} from "./chunk-GYHOKJMO.js";
import {
  css_color_names_default,
  css_color_names_exports,
  require_linkify_it,
  require_regex,
  require_regex2,
  require_regex3,
  require_regex4
} from "./chunk-ORZRZFYN.js";
import {
  Fragment,
  Mark,
  Schema
} from "./chunk-AGEANN4K.js";
import "./chunk-LHMD4SLY.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "Ã", aacute: "Ã¡", Abreve: "Ä‚", abreve: "Äƒ", ac: "âˆ¾", acd: "âˆ¿", acE: "âˆ¾Ì³", Acirc: "Ã‚", acirc: "Ã¢", acute: "Â´", Acy: "Ğ", acy: "Ğ°", AElig: "Ã†", aelig: "Ã¦", af: "â¡", Afr: "ğ”„", afr: "ğ”", Agrave: "Ã€", agrave: "Ã ", alefsym: "â„µ", aleph: "â„µ", Alpha: "Î‘", alpha: "Î±", Amacr: "Ä€", amacr: "Ä", amalg: "â¨¿", amp: "&", AMP: "&", andand: "â©•", And: "â©“", and: "âˆ§", andd: "â©œ", andslope: "â©˜", andv: "â©š", ang: "âˆ ", ange: "â¦¤", angle: "âˆ ", angmsdaa: "â¦¨", angmsdab: "â¦©", angmsdac: "â¦ª", angmsdad: "â¦«", angmsdae: "â¦¬", angmsdaf: "â¦­", angmsdag: "â¦®", angmsdah: "â¦¯", angmsd: "âˆ¡", angrt: "âˆŸ", angrtvb: "âŠ¾", angrtvbd: "â¦", angsph: "âˆ¢", angst: "Ã…", angzarr: "â¼", Aogon: "Ä„", aogon: "Ä…", Aopf: "ğ”¸", aopf: "ğ•’", apacir: "â©¯", ap: "â‰ˆ", apE: "â©°", ape: "â‰Š", apid: "â‰‹", apos: "'", ApplyFunction: "â¡", approx: "â‰ˆ", approxeq: "â‰Š", Aring: "Ã…", aring: "Ã¥", Ascr: "ğ’œ", ascr: "ğ’¶", Assign: "â‰”", ast: "*", asymp: "â‰ˆ", asympeq: "â‰", Atilde: "Ãƒ", atilde: "Ã£", Auml: "Ã„", auml: "Ã¤", awconint: "âˆ³", awint: "â¨‘", backcong: "â‰Œ", backepsilon: "Ï¶", backprime: "â€µ", backsim: "âˆ½", backsimeq: "â‹", Backslash: "âˆ–", Barv: "â«§", barvee: "âŠ½", barwed: "âŒ…", Barwed: "âŒ†", barwedge: "âŒ…", bbrk: "âµ", bbrktbrk: "â¶", bcong: "â‰Œ", Bcy: "Ğ‘", bcy: "Ğ±", bdquo: "â€", becaus: "âˆµ", because: "âˆµ", Because: "âˆµ", bemptyv: "â¦°", bepsi: "Ï¶", bernou: "â„¬", Bernoullis: "â„¬", Beta: "Î’", beta: "Î²", beth: "â„¶", between: "â‰¬", Bfr: "ğ”…", bfr: "ğ”Ÿ", bigcap: "â‹‚", bigcirc: "â—¯", bigcup: "â‹ƒ", bigodot: "â¨€", bigoplus: "â¨", bigotimes: "â¨‚", bigsqcup: "â¨†", bigstar: "â˜…", bigtriangledown: "â–½", bigtriangleup: "â–³", biguplus: "â¨„", bigvee: "â‹", bigwedge: "â‹€", bkarow: "â¤", blacklozenge: "â§«", blacksquare: "â–ª", blacktriangle: "â–´", blacktriangledown: "â–¾", blacktriangleleft: "â—‚", blacktriangleright: "â–¸", blank: "â£", blk12: "â–’", blk14: "â–‘", blk34: "â–“", block: "â–ˆ", bne: "=âƒ¥", bnequiv: "â‰¡âƒ¥", bNot: "â«­", bnot: "âŒ", Bopf: "ğ”¹", bopf: "ğ•“", bot: "âŠ¥", bottom: "âŠ¥", bowtie: "â‹ˆ", boxbox: "â§‰", boxdl: "â”", boxdL: "â••", boxDl: "â•–", boxDL: "â•—", boxdr: "â”Œ", boxdR: "â•’", boxDr: "â•“", boxDR: "â•”", boxh: "â”€", boxH: "â•", boxhd: "â”¬", boxHd: "â•¤", boxhD: "â•¥", boxHD: "â•¦", boxhu: "â”´", boxHu: "â•§", boxhU: "â•¨", boxHU: "â•©", boxminus: "âŠŸ", boxplus: "âŠ", boxtimes: "âŠ ", boxul: "â”˜", boxuL: "â•›", boxUl: "â•œ", boxUL: "â•", boxur: "â””", boxuR: "â•˜", boxUr: "â•™", boxUR: "â•š", boxv: "â”‚", boxV: "â•‘", boxvh: "â”¼", boxvH: "â•ª", boxVh: "â•«", boxVH: "â•¬", boxvl: "â”¤", boxvL: "â•¡", boxVl: "â•¢", boxVL: "â•£", boxvr: "â”œ", boxvR: "â•", boxVr: "â•Ÿ", boxVR: "â• ", bprime: "â€µ", breve: "Ë˜", Breve: "Ë˜", brvbar: "Â¦", bscr: "ğ’·", Bscr: "â„¬", bsemi: "â", bsim: "âˆ½", bsime: "â‹", bsolb: "â§…", bsol: "\\", bsolhsub: "âŸˆ", bull: "â€¢", bullet: "â€¢", bump: "â‰", bumpE: "âª®", bumpe: "â‰", Bumpeq: "â‰", bumpeq: "â‰", Cacute: "Ä†", cacute: "Ä‡", capand: "â©„", capbrcup: "â©‰", capcap: "â©‹", cap: "âˆ©", Cap: "â‹’", capcup: "â©‡", capdot: "â©€", CapitalDifferentialD: "â……", caps: "âˆ©ï¸€", caret: "â", caron: "Ë‡", Cayleys: "â„­", ccaps: "â©", Ccaron: "ÄŒ", ccaron: "Ä", Ccedil: "Ã‡", ccedil: "Ã§", Ccirc: "Äˆ", ccirc: "Ä‰", Cconint: "âˆ°", ccups: "â©Œ", ccupssm: "â©", Cdot: "ÄŠ", cdot: "Ä‹", cedil: "Â¸", Cedilla: "Â¸", cemptyv: "â¦²", cent: "Â¢", centerdot: "Â·", CenterDot: "Â·", cfr: "ğ” ", Cfr: "â„­", CHcy: "Ğ§", chcy: "Ñ‡", check: "âœ“", checkmark: "âœ“", Chi: "Î§", chi: "Ï‡", circ: "Ë†", circeq: "â‰—", circlearrowleft: "â†º", circlearrowright: "â†»", circledast: "âŠ›", circledcirc: "âŠš", circleddash: "âŠ", CircleDot: "âŠ™", circledR: "Â®", circledS: "â“ˆ", CircleMinus: "âŠ–", CirclePlus: "âŠ•", CircleTimes: "âŠ—", cir: "â—‹", cirE: "â§ƒ", cire: "â‰—", cirfnint: "â¨", cirmid: "â«¯", cirscir: "â§‚", ClockwiseContourIntegral: "âˆ²", CloseCurlyDoubleQuote: "â€", CloseCurlyQuote: "â€™", clubs: "â™£", clubsuit: "â™£", colon: ":", Colon: "âˆ·", Colone: "â©´", colone: "â‰”", coloneq: "â‰”", comma: ",", commat: "@", comp: "âˆ", compfn: "âˆ˜", complement: "âˆ", complexes: "â„‚", cong: "â‰…", congdot: "â©­", Congruent: "â‰¡", conint: "âˆ®", Conint: "âˆ¯", ContourIntegral: "âˆ®", copf: "ğ•”", Copf: "â„‚", coprod: "âˆ", Coproduct: "âˆ", copy: "Â©", COPY: "Â©", copysr: "â„—", CounterClockwiseContourIntegral: "âˆ³", crarr: "â†µ", cross: "âœ—", Cross: "â¨¯", Cscr: "ğ’", cscr: "ğ’¸", csub: "â«", csube: "â«‘", csup: "â«", csupe: "â«’", ctdot: "â‹¯", cudarrl: "â¤¸", cudarrr: "â¤µ", cuepr: "â‹", cuesc: "â‹Ÿ", cularr: "â†¶", cularrp: "â¤½", cupbrcap: "â©ˆ", cupcap: "â©†", CupCap: "â‰", cup: "âˆª", Cup: "â‹“", cupcup: "â©Š", cupdot: "âŠ", cupor: "â©…", cups: "âˆªï¸€", curarr: "â†·", curarrm: "â¤¼", curlyeqprec: "â‹", curlyeqsucc: "â‹Ÿ", curlyvee: "â‹", curlywedge: "â‹", curren: "Â¤", curvearrowleft: "â†¶", curvearrowright: "â†·", cuvee: "â‹", cuwed: "â‹", cwconint: "âˆ²", cwint: "âˆ±", cylcty: "âŒ­", dagger: "â€ ", Dagger: "â€¡", daleth: "â„¸", darr: "â†“", Darr: "â†¡", dArr: "â‡“", dash: "â€", Dashv: "â«¤", dashv: "âŠ£", dbkarow: "â¤", dblac: "Ë", Dcaron: "Ä", dcaron: "Ä", Dcy: "Ğ”", dcy: "Ğ´", ddagger: "â€¡", ddarr: "â‡Š", DD: "â……", dd: "â…†", DDotrahd: "â¤‘", ddotseq: "â©·", deg: "Â°", Del: "âˆ‡", Delta: "Î”", delta: "Î´", demptyv: "â¦±", dfisht: "â¥¿", Dfr: "ğ”‡", dfr: "ğ”¡", dHar: "â¥¥", dharl: "â‡ƒ", dharr: "â‡‚", DiacriticalAcute: "Â´", DiacriticalDot: "Ë™", DiacriticalDoubleAcute: "Ë", DiacriticalGrave: "`", DiacriticalTilde: "Ëœ", diam: "â‹„", diamond: "â‹„", Diamond: "â‹„", diamondsuit: "â™¦", diams: "â™¦", die: "Â¨", DifferentialD: "â…†", digamma: "Ï", disin: "â‹²", div: "Ã·", divide: "Ã·", divideontimes: "â‹‡", divonx: "â‹‡", DJcy: "Ğ‚", djcy: "Ñ’", dlcorn: "âŒ", dlcrop: "âŒ", dollar: "$", Dopf: "ğ”»", dopf: "ğ••", Dot: "Â¨", dot: "Ë™", DotDot: "âƒœ", doteq: "â‰", doteqdot: "â‰‘", DotEqual: "â‰", dotminus: "âˆ¸", dotplus: "âˆ”", dotsquare: "âŠ¡", doublebarwedge: "âŒ†", DoubleContourIntegral: "âˆ¯", DoubleDot: "Â¨", DoubleDownArrow: "â‡“", DoubleLeftArrow: "â‡", DoubleLeftRightArrow: "â‡”", DoubleLeftTee: "â«¤", DoubleLongLeftArrow: "âŸ¸", DoubleLongLeftRightArrow: "âŸº", DoubleLongRightArrow: "âŸ¹", DoubleRightArrow: "â‡’", DoubleRightTee: "âŠ¨", DoubleUpArrow: "â‡‘", DoubleUpDownArrow: "â‡•", DoubleVerticalBar: "âˆ¥", DownArrowBar: "â¤“", downarrow: "â†“", DownArrow: "â†“", Downarrow: "â‡“", DownArrowUpArrow: "â‡µ", DownBreve: "Ì‘", downdownarrows: "â‡Š", downharpoonleft: "â‡ƒ", downharpoonright: "â‡‚", DownLeftRightVector: "â¥", DownLeftTeeVector: "â¥", DownLeftVectorBar: "â¥–", DownLeftVector: "â†½", DownRightTeeVector: "â¥Ÿ", DownRightVectorBar: "â¥—", DownRightVector: "â‡", DownTeeArrow: "â†§", DownTee: "âŠ¤", drbkarow: "â¤", drcorn: "âŒŸ", drcrop: "âŒŒ", Dscr: "ğ’Ÿ", dscr: "ğ’¹", DScy: "Ğ…", dscy: "Ñ•", dsol: "â§¶", Dstrok: "Ä", dstrok: "Ä‘", dtdot: "â‹±", dtri: "â–¿", dtrif: "â–¾", duarr: "â‡µ", duhar: "â¥¯", dwangle: "â¦¦", DZcy: "Ğ", dzcy: "ÑŸ", dzigrarr: "âŸ¿", Eacute: "Ã‰", eacute: "Ã©", easter: "â©®", Ecaron: "Äš", ecaron: "Ä›", Ecirc: "ÃŠ", ecirc: "Ãª", ecir: "â‰–", ecolon: "â‰•", Ecy: "Ğ­", ecy: "Ñ", eDDot: "â©·", Edot: "Ä–", edot: "Ä—", eDot: "â‰‘", ee: "â…‡", efDot: "â‰’", Efr: "ğ”ˆ", efr: "ğ”¢", eg: "âªš", Egrave: "Ãˆ", egrave: "Ã¨", egs: "âª–", egsdot: "âª˜", el: "âª™", Element: "âˆˆ", elinters: "â§", ell: "â„“", els: "âª•", elsdot: "âª—", Emacr: "Ä’", emacr: "Ä“", empty: "âˆ…", emptyset: "âˆ…", EmptySmallSquare: "â—»", emptyv: "âˆ…", EmptyVerySmallSquare: "â–«", emsp13: "â€„", emsp14: "â€…", emsp: "â€ƒ", ENG: "ÅŠ", eng: "Å‹", ensp: "â€‚", Eogon: "Ä˜", eogon: "Ä™", Eopf: "ğ”¼", eopf: "ğ•–", epar: "â‹•", eparsl: "â§£", eplus: "â©±", epsi: "Îµ", Epsilon: "Î•", epsilon: "Îµ", epsiv: "Ïµ", eqcirc: "â‰–", eqcolon: "â‰•", eqsim: "â‰‚", eqslantgtr: "âª–", eqslantless: "âª•", Equal: "â©µ", equals: "=", EqualTilde: "â‰‚", equest: "â‰Ÿ", Equilibrium: "â‡Œ", equiv: "â‰¡", equivDD: "â©¸", eqvparsl: "â§¥", erarr: "â¥±", erDot: "â‰“", escr: "â„¯", Escr: "â„°", esdot: "â‰", Esim: "â©³", esim: "â‰‚", Eta: "Î—", eta: "Î·", ETH: "Ã", eth: "Ã°", Euml: "Ã‹", euml: "Ã«", euro: "â‚¬", excl: "!", exist: "âˆƒ", Exists: "âˆƒ", expectation: "â„°", exponentiale: "â…‡", ExponentialE: "â…‡", fallingdotseq: "â‰’", Fcy: "Ğ¤", fcy: "Ñ„", female: "â™€", ffilig: "ï¬ƒ", fflig: "ï¬€", ffllig: "ï¬„", Ffr: "ğ”‰", ffr: "ğ”£", filig: "ï¬", FilledSmallSquare: "â—¼", FilledVerySmallSquare: "â–ª", fjlig: "fj", flat: "â™­", fllig: "ï¬‚", fltns: "â–±", fnof: "Æ’", Fopf: "ğ”½", fopf: "ğ•—", forall: "âˆ€", ForAll: "âˆ€", fork: "â‹”", forkv: "â«™", Fouriertrf: "â„±", fpartint: "â¨", frac12: "Â½", frac13: "â…“", frac14: "Â¼", frac15: "â…•", frac16: "â…™", frac18: "â…›", frac23: "â…”", frac25: "â…–", frac34: "Â¾", frac35: "â…—", frac38: "â…œ", frac45: "â…˜", frac56: "â…š", frac58: "â…", frac78: "â…", frasl: "â„", frown: "âŒ¢", fscr: "ğ’»", Fscr: "â„±", gacute: "Çµ", Gamma: "Î“", gamma: "Î³", Gammad: "Ïœ", gammad: "Ï", gap: "âª†", Gbreve: "Ä", gbreve: "ÄŸ", Gcedil: "Ä¢", Gcirc: "Äœ", gcirc: "Ä", Gcy: "Ğ“", gcy: "Ğ³", Gdot: "Ä ", gdot: "Ä¡", ge: "â‰¥", gE: "â‰§", gEl: "âªŒ", gel: "â‹›", geq: "â‰¥", geqq: "â‰§", geqslant: "â©¾", gescc: "âª©", ges: "â©¾", gesdot: "âª€", gesdoto: "âª‚", gesdotol: "âª„", gesl: "â‹›ï¸€", gesles: "âª”", Gfr: "ğ”Š", gfr: "ğ”¤", gg: "â‰«", Gg: "â‹™", ggg: "â‹™", gimel: "â„·", GJcy: "Ğƒ", gjcy: "Ñ“", gla: "âª¥", gl: "â‰·", glE: "âª’", glj: "âª¤", gnap: "âªŠ", gnapprox: "âªŠ", gne: "âªˆ", gnE: "â‰©", gneq: "âªˆ", gneqq: "â‰©", gnsim: "â‹§", Gopf: "ğ”¾", gopf: "ğ•˜", grave: "`", GreaterEqual: "â‰¥", GreaterEqualLess: "â‹›", GreaterFullEqual: "â‰§", GreaterGreater: "âª¢", GreaterLess: "â‰·", GreaterSlantEqual: "â©¾", GreaterTilde: "â‰³", Gscr: "ğ’¢", gscr: "â„Š", gsim: "â‰³", gsime: "âª", gsiml: "âª", gtcc: "âª§", gtcir: "â©º", gt: ">", GT: ">", Gt: "â‰«", gtdot: "â‹—", gtlPar: "â¦•", gtquest: "â©¼", gtrapprox: "âª†", gtrarr: "â¥¸", gtrdot: "â‹—", gtreqless: "â‹›", gtreqqless: "âªŒ", gtrless: "â‰·", gtrsim: "â‰³", gvertneqq: "â‰©ï¸€", gvnE: "â‰©ï¸€", Hacek: "Ë‡", hairsp: "â€Š", half: "Â½", hamilt: "â„‹", HARDcy: "Ğª", hardcy: "ÑŠ", harrcir: "â¥ˆ", harr: "â†”", hArr: "â‡”", harrw: "â†­", Hat: "^", hbar: "â„", Hcirc: "Ä¤", hcirc: "Ä¥", hearts: "â™¥", heartsuit: "â™¥", hellip: "â€¦", hercon: "âŠ¹", hfr: "ğ”¥", Hfr: "â„Œ", HilbertSpace: "â„‹", hksearow: "â¤¥", hkswarow: "â¤¦", hoarr: "â‡¿", homtht: "âˆ»", hookleftarrow: "â†©", hookrightarrow: "â†ª", hopf: "ğ•™", Hopf: "â„", horbar: "â€•", HorizontalLine: "â”€", hscr: "ğ’½", Hscr: "â„‹", hslash: "â„", Hstrok: "Ä¦", hstrok: "Ä§", HumpDownHump: "â‰", HumpEqual: "â‰", hybull: "âƒ", hyphen: "â€", Iacute: "Ã", iacute: "Ã­", ic: "â£", Icirc: "Ã", icirc: "Ã®", Icy: "Ğ˜", icy: "Ğ¸", Idot: "Ä°", IEcy: "Ğ•", iecy: "Ğµ", iexcl: "Â¡", iff: "â‡”", ifr: "ğ”¦", Ifr: "â„‘", Igrave: "ÃŒ", igrave: "Ã¬", ii: "â…ˆ", iiiint: "â¨Œ", iiint: "âˆ­", iinfin: "â§œ", iiota: "â„©", IJlig: "Ä²", ijlig: "Ä³", Imacr: "Äª", imacr: "Ä«", image: "â„‘", ImaginaryI: "â…ˆ", imagline: "â„", imagpart: "â„‘", imath: "Ä±", Im: "â„‘", imof: "âŠ·", imped: "Æµ", Implies: "â‡’", incare: "â„…", in: "âˆˆ", infin: "âˆ", infintie: "â§", inodot: "Ä±", intcal: "âŠº", int: "âˆ«", Int: "âˆ¬", integers: "â„¤", Integral: "âˆ«", intercal: "âŠº", Intersection: "â‹‚", intlarhk: "â¨—", intprod: "â¨¼", InvisibleComma: "â£", InvisibleTimes: "â¢", IOcy: "Ğ", iocy: "Ñ‘", Iogon: "Ä®", iogon: "Ä¯", Iopf: "ğ•€", iopf: "ğ•š", Iota: "Î™", iota: "Î¹", iprod: "â¨¼", iquest: "Â¿", iscr: "ğ’¾", Iscr: "â„", isin: "âˆˆ", isindot: "â‹µ", isinE: "â‹¹", isins: "â‹´", isinsv: "â‹³", isinv: "âˆˆ", it: "â¢", Itilde: "Ä¨", itilde: "Ä©", Iukcy: "Ğ†", iukcy: "Ñ–", Iuml: "Ã", iuml: "Ã¯", Jcirc: "Ä´", jcirc: "Äµ", Jcy: "Ğ™", jcy: "Ğ¹", Jfr: "ğ”", jfr: "ğ”§", jmath: "È·", Jopf: "ğ•", jopf: "ğ•›", Jscr: "ğ’¥", jscr: "ğ’¿", Jsercy: "Ğˆ", jsercy: "Ñ˜", Jukcy: "Ğ„", jukcy: "Ñ”", Kappa: "Îš", kappa: "Îº", kappav: "Ï°", Kcedil: "Ä¶", kcedil: "Ä·", Kcy: "Ğš", kcy: "Ğº", Kfr: "ğ”", kfr: "ğ”¨", kgreen: "Ä¸", KHcy: "Ğ¥", khcy: "Ñ…", KJcy: "ĞŒ", kjcy: "Ñœ", Kopf: "ğ•‚", kopf: "ğ•œ", Kscr: "ğ’¦", kscr: "ğ“€", lAarr: "â‡š", Lacute: "Ä¹", lacute: "Äº", laemptyv: "â¦´", lagran: "â„’", Lambda: "Î›", lambda: "Î»", lang: "âŸ¨", Lang: "âŸª", langd: "â¦‘", langle: "âŸ¨", lap: "âª…", Laplacetrf: "â„’", laquo: "Â«", larrb: "â‡¤", larrbfs: "â¤Ÿ", larr: "â†", Larr: "â†", lArr: "â‡", larrfs: "â¤", larrhk: "â†©", larrlp: "â†«", larrpl: "â¤¹", larrsim: "â¥³", larrtl: "â†¢", latail: "â¤™", lAtail: "â¤›", lat: "âª«", late: "âª­", lates: "âª­ï¸€", lbarr: "â¤Œ", lBarr: "â¤", lbbrk: "â²", lbrace: "{", lbrack: "[", lbrke: "â¦‹", lbrksld: "â¦", lbrkslu: "â¦", Lcaron: "Ä½", lcaron: "Ä¾", Lcedil: "Ä»", lcedil: "Ä¼", lceil: "âŒˆ", lcub: "{", Lcy: "Ğ›", lcy: "Ğ»", ldca: "â¤¶", ldquo: "â€œ", ldquor: "â€", ldrdhar: "â¥§", ldrushar: "â¥‹", ldsh: "â†²", le: "â‰¤", lE: "â‰¦", LeftAngleBracket: "âŸ¨", LeftArrowBar: "â‡¤", leftarrow: "â†", LeftArrow: "â†", Leftarrow: "â‡", LeftArrowRightArrow: "â‡†", leftarrowtail: "â†¢", LeftCeiling: "âŒˆ", LeftDoubleBracket: "âŸ¦", LeftDownTeeVector: "â¥¡", LeftDownVectorBar: "â¥™", LeftDownVector: "â‡ƒ", LeftFloor: "âŒŠ", leftharpoondown: "â†½", leftharpoonup: "â†¼", leftleftarrows: "â‡‡", leftrightarrow: "â†”", LeftRightArrow: "â†”", Leftrightarrow: "â‡”", leftrightarrows: "â‡†", leftrightharpoons: "â‡‹", leftrightsquigarrow: "â†­", LeftRightVector: "â¥", LeftTeeArrow: "â†¤", LeftTee: "âŠ£", LeftTeeVector: "â¥š", leftthreetimes: "â‹‹", LeftTriangleBar: "â§", LeftTriangle: "âŠ²", LeftTriangleEqual: "âŠ´", LeftUpDownVector: "â¥‘", LeftUpTeeVector: "â¥ ", LeftUpVectorBar: "â¥˜", LeftUpVector: "â†¿", LeftVectorBar: "â¥’", LeftVector: "â†¼", lEg: "âª‹", leg: "â‹š", leq: "â‰¤", leqq: "â‰¦", leqslant: "â©½", lescc: "âª¨", les: "â©½", lesdot: "â©¿", lesdoto: "âª", lesdotor: "âªƒ", lesg: "â‹šï¸€", lesges: "âª“", lessapprox: "âª…", lessdot: "â‹–", lesseqgtr: "â‹š", lesseqqgtr: "âª‹", LessEqualGreater: "â‹š", LessFullEqual: "â‰¦", LessGreater: "â‰¶", lessgtr: "â‰¶", LessLess: "âª¡", lesssim: "â‰²", LessSlantEqual: "â©½", LessTilde: "â‰²", lfisht: "â¥¼", lfloor: "âŒŠ", Lfr: "ğ”", lfr: "ğ”©", lg: "â‰¶", lgE: "âª‘", lHar: "â¥¢", lhard: "â†½", lharu: "â†¼", lharul: "â¥ª", lhblk: "â–„", LJcy: "Ğ‰", ljcy: "Ñ™", llarr: "â‡‡", ll: "â‰ª", Ll: "â‹˜", llcorner: "âŒ", Lleftarrow: "â‡š", llhard: "â¥«", lltri: "â—º", Lmidot: "Ä¿", lmidot: "Å€", lmoustache: "â°", lmoust: "â°", lnap: "âª‰", lnapprox: "âª‰", lne: "âª‡", lnE: "â‰¨", lneq: "âª‡", lneqq: "â‰¨", lnsim: "â‹¦", loang: "âŸ¬", loarr: "â‡½", lobrk: "âŸ¦", longleftarrow: "âŸµ", LongLeftArrow: "âŸµ", Longleftarrow: "âŸ¸", longleftrightarrow: "âŸ·", LongLeftRightArrow: "âŸ·", Longleftrightarrow: "âŸº", longmapsto: "âŸ¼", longrightarrow: "âŸ¶", LongRightArrow: "âŸ¶", Longrightarrow: "âŸ¹", looparrowleft: "â†«", looparrowright: "â†¬", lopar: "â¦…", Lopf: "ğ•ƒ", lopf: "ğ•", loplus: "â¨­", lotimes: "â¨´", lowast: "âˆ—", lowbar: "_", LowerLeftArrow: "â†™", LowerRightArrow: "â†˜", loz: "â—Š", lozenge: "â—Š", lozf: "â§«", lpar: "(", lparlt: "â¦“", lrarr: "â‡†", lrcorner: "âŒŸ", lrhar: "â‡‹", lrhard: "â¥­", lrm: "â€", lrtri: "âŠ¿", lsaquo: "â€¹", lscr: "ğ“", Lscr: "â„’", lsh: "â†°", Lsh: "â†°", lsim: "â‰²", lsime: "âª", lsimg: "âª", lsqb: "[", lsquo: "â€˜", lsquor: "â€š", Lstrok: "Å", lstrok: "Å‚", ltcc: "âª¦", ltcir: "â©¹", lt: "<", LT: "<", Lt: "â‰ª", ltdot: "â‹–", lthree: "â‹‹", ltimes: "â‹‰", ltlarr: "â¥¶", ltquest: "â©»", ltri: "â—ƒ", ltrie: "âŠ´", ltrif: "â—‚", ltrPar: "â¦–", lurdshar: "â¥Š", luruhar: "â¥¦", lvertneqq: "â‰¨ï¸€", lvnE: "â‰¨ï¸€", macr: "Â¯", male: "â™‚", malt: "âœ ", maltese: "âœ ", Map: "â¤…", map: "â†¦", mapsto: "â†¦", mapstodown: "â†§", mapstoleft: "â†¤", mapstoup: "â†¥", marker: "â–®", mcomma: "â¨©", Mcy: "Ğœ", mcy: "Ğ¼", mdash: "â€”", mDDot: "âˆº", measuredangle: "âˆ¡", MediumSpace: "âŸ", Mellintrf: "â„³", Mfr: "ğ”", mfr: "ğ”ª", mho: "â„§", micro: "Âµ", midast: "*", midcir: "â«°", mid: "âˆ£", middot: "Â·", minusb: "âŠŸ", minus: "âˆ’", minusd: "âˆ¸", minusdu: "â¨ª", MinusPlus: "âˆ“", mlcp: "â«›", mldr: "â€¦", mnplus: "âˆ“", models: "âŠ§", Mopf: "ğ•„", mopf: "ğ•", mp: "âˆ“", mscr: "ğ“‚", Mscr: "â„³", mstpos: "âˆ¾", Mu: "Îœ", mu: "Î¼", multimap: "âŠ¸", mumap: "âŠ¸", nabla: "âˆ‡", Nacute: "Åƒ", nacute: "Å„", nang: "âˆ âƒ’", nap: "â‰‰", napE: "â©°Ì¸", napid: "â‰‹Ì¸", napos: "Å‰", napprox: "â‰‰", natural: "â™®", naturals: "â„•", natur: "â™®", nbsp: "Â ", nbump: "â‰Ì¸", nbumpe: "â‰Ì¸", ncap: "â©ƒ", Ncaron: "Å‡", ncaron: "Åˆ", Ncedil: "Å…", ncedil: "Å†", ncong: "â‰‡", ncongdot: "â©­Ì¸", ncup: "â©‚", Ncy: "Ğ", ncy: "Ğ½", ndash: "â€“", nearhk: "â¤¤", nearr: "â†—", neArr: "â‡—", nearrow: "â†—", ne: "â‰ ", nedot: "â‰Ì¸", NegativeMediumSpace: "â€‹", NegativeThickSpace: "â€‹", NegativeThinSpace: "â€‹", NegativeVeryThinSpace: "â€‹", nequiv: "â‰¢", nesear: "â¤¨", nesim: "â‰‚Ì¸", NestedGreaterGreater: "â‰«", NestedLessLess: "â‰ª", NewLine: "\n", nexist: "âˆ„", nexists: "âˆ„", Nfr: "ğ”‘", nfr: "ğ”«", ngE: "â‰§Ì¸", nge: "â‰±", ngeq: "â‰±", ngeqq: "â‰§Ì¸", ngeqslant: "â©¾Ì¸", nges: "â©¾Ì¸", nGg: "â‹™Ì¸", ngsim: "â‰µ", nGt: "â‰«âƒ’", ngt: "â‰¯", ngtr: "â‰¯", nGtv: "â‰«Ì¸", nharr: "â†®", nhArr: "â‡", nhpar: "â«²", ni: "âˆ‹", nis: "â‹¼", nisd: "â‹º", niv: "âˆ‹", NJcy: "ĞŠ", njcy: "Ñš", nlarr: "â†š", nlArr: "â‡", nldr: "â€¥", nlE: "â‰¦Ì¸", nle: "â‰°", nleftarrow: "â†š", nLeftarrow: "â‡", nleftrightarrow: "â†®", nLeftrightarrow: "â‡", nleq: "â‰°", nleqq: "â‰¦Ì¸", nleqslant: "â©½Ì¸", nles: "â©½Ì¸", nless: "â‰®", nLl: "â‹˜Ì¸", nlsim: "â‰´", nLt: "â‰ªâƒ’", nlt: "â‰®", nltri: "â‹ª", nltrie: "â‹¬", nLtv: "â‰ªÌ¸", nmid: "âˆ¤", NoBreak: "â ", NonBreakingSpace: "Â ", nopf: "ğ•Ÿ", Nopf: "â„•", Not: "â«¬", not: "Â¬", NotCongruent: "â‰¢", NotCupCap: "â‰­", NotDoubleVerticalBar: "âˆ¦", NotElement: "âˆ‰", NotEqual: "â‰ ", NotEqualTilde: "â‰‚Ì¸", NotExists: "âˆ„", NotGreater: "â‰¯", NotGreaterEqual: "â‰±", NotGreaterFullEqual: "â‰§Ì¸", NotGreaterGreater: "â‰«Ì¸", NotGreaterLess: "â‰¹", NotGreaterSlantEqual: "â©¾Ì¸", NotGreaterTilde: "â‰µ", NotHumpDownHump: "â‰Ì¸", NotHumpEqual: "â‰Ì¸", notin: "âˆ‰", notindot: "â‹µÌ¸", notinE: "â‹¹Ì¸", notinva: "âˆ‰", notinvb: "â‹·", notinvc: "â‹¶", NotLeftTriangleBar: "â§Ì¸", NotLeftTriangle: "â‹ª", NotLeftTriangleEqual: "â‹¬", NotLess: "â‰®", NotLessEqual: "â‰°", NotLessGreater: "â‰¸", NotLessLess: "â‰ªÌ¸", NotLessSlantEqual: "â©½Ì¸", NotLessTilde: "â‰´", NotNestedGreaterGreater: "âª¢Ì¸", NotNestedLessLess: "âª¡Ì¸", notni: "âˆŒ", notniva: "âˆŒ", notnivb: "â‹¾", notnivc: "â‹½", NotPrecedes: "âŠ€", NotPrecedesEqual: "âª¯Ì¸", NotPrecedesSlantEqual: "â‹ ", NotReverseElement: "âˆŒ", NotRightTriangleBar: "â§Ì¸", NotRightTriangle: "â‹«", NotRightTriangleEqual: "â‹­", NotSquareSubset: "âŠÌ¸", NotSquareSubsetEqual: "â‹¢", NotSquareSuperset: "âŠÌ¸", NotSquareSupersetEqual: "â‹£", NotSubset: "âŠ‚âƒ’", NotSubsetEqual: "âŠˆ", NotSucceeds: "âŠ", NotSucceedsEqual: "âª°Ì¸", NotSucceedsSlantEqual: "â‹¡", NotSucceedsTilde: "â‰¿Ì¸", NotSuperset: "âŠƒâƒ’", NotSupersetEqual: "âŠ‰", NotTilde: "â‰", NotTildeEqual: "â‰„", NotTildeFullEqual: "â‰‡", NotTildeTilde: "â‰‰", NotVerticalBar: "âˆ¤", nparallel: "âˆ¦", npar: "âˆ¦", nparsl: "â«½âƒ¥", npart: "âˆ‚Ì¸", npolint: "â¨”", npr: "âŠ€", nprcue: "â‹ ", nprec: "âŠ€", npreceq: "âª¯Ì¸", npre: "âª¯Ì¸", nrarrc: "â¤³Ì¸", nrarr: "â†›", nrArr: "â‡", nrarrw: "â†Ì¸", nrightarrow: "â†›", nRightarrow: "â‡", nrtri: "â‹«", nrtrie: "â‹­", nsc: "âŠ", nsccue: "â‹¡", nsce: "âª°Ì¸", Nscr: "ğ’©", nscr: "ğ“ƒ", nshortmid: "âˆ¤", nshortparallel: "âˆ¦", nsim: "â‰", nsime: "â‰„", nsimeq: "â‰„", nsmid: "âˆ¤", nspar: "âˆ¦", nsqsube: "â‹¢", nsqsupe: "â‹£", nsub: "âŠ„", nsubE: "â«…Ì¸", nsube: "âŠˆ", nsubset: "âŠ‚âƒ’", nsubseteq: "âŠˆ", nsubseteqq: "â«…Ì¸", nsucc: "âŠ", nsucceq: "âª°Ì¸", nsup: "âŠ…", nsupE: "â«†Ì¸", nsupe: "âŠ‰", nsupset: "âŠƒâƒ’", nsupseteq: "âŠ‰", nsupseteqq: "â«†Ì¸", ntgl: "â‰¹", Ntilde: "Ã‘", ntilde: "Ã±", ntlg: "â‰¸", ntriangleleft: "â‹ª", ntrianglelefteq: "â‹¬", ntriangleright: "â‹«", ntrianglerighteq: "â‹­", Nu: "Î", nu: "Î½", num: "#", numero: "â„–", numsp: "â€‡", nvap: "â‰âƒ’", nvdash: "âŠ¬", nvDash: "âŠ­", nVdash: "âŠ®", nVDash: "âŠ¯", nvge: "â‰¥âƒ’", nvgt: ">âƒ’", nvHarr: "â¤„", nvinfin: "â§", nvlArr: "â¤‚", nvle: "â‰¤âƒ’", nvlt: "<âƒ’", nvltrie: "âŠ´âƒ’", nvrArr: "â¤ƒ", nvrtrie: "âŠµâƒ’", nvsim: "âˆ¼âƒ’", nwarhk: "â¤£", nwarr: "â†–", nwArr: "â‡–", nwarrow: "â†–", nwnear: "â¤§", Oacute: "Ã“", oacute: "Ã³", oast: "âŠ›", Ocirc: "Ã”", ocirc: "Ã´", ocir: "âŠš", Ocy: "Ğ", ocy: "Ğ¾", odash: "âŠ", Odblac: "Å", odblac: "Å‘", odiv: "â¨¸", odot: "âŠ™", odsold: "â¦¼", OElig: "Å’", oelig: "Å“", ofcir: "â¦¿", Ofr: "ğ”’", ofr: "ğ”¬", ogon: "Ë›", Ograve: "Ã’", ograve: "Ã²", ogt: "â§", ohbar: "â¦µ", ohm: "Î©", oint: "âˆ®", olarr: "â†º", olcir: "â¦¾", olcross: "â¦»", oline: "â€¾", olt: "â§€", Omacr: "ÅŒ", omacr: "Å", Omega: "Î©", omega: "Ï‰", Omicron: "ÎŸ", omicron: "Î¿", omid: "â¦¶", ominus: "âŠ–", Oopf: "ğ•†", oopf: "ğ• ", opar: "â¦·", OpenCurlyDoubleQuote: "â€œ", OpenCurlyQuote: "â€˜", operp: "â¦¹", oplus: "âŠ•", orarr: "â†»", Or: "â©”", or: "âˆ¨", ord: "â©", order: "â„´", orderof: "â„´", ordf: "Âª", ordm: "Âº", origof: "âŠ¶", oror: "â©–", orslope: "â©—", orv: "â©›", oS: "â“ˆ", Oscr: "ğ’ª", oscr: "â„´", Oslash: "Ã˜", oslash: "Ã¸", osol: "âŠ˜", Otilde: "Ã•", otilde: "Ãµ", otimesas: "â¨¶", Otimes: "â¨·", otimes: "âŠ—", Ouml: "Ã–", ouml: "Ã¶", ovbar: "âŒ½", OverBar: "â€¾", OverBrace: "â", OverBracket: "â´", OverParenthesis: "âœ", para: "Â¶", parallel: "âˆ¥", par: "âˆ¥", parsim: "â«³", parsl: "â«½", part: "âˆ‚", PartialD: "âˆ‚", Pcy: "ĞŸ", pcy: "Ğ¿", percnt: "%", period: ".", permil: "â€°", perp: "âŠ¥", pertenk: "â€±", Pfr: "ğ”“", pfr: "ğ”­", Phi: "Î¦", phi: "Ï†", phiv: "Ï•", phmmat: "â„³", phone: "â˜", Pi: "Î ", pi: "Ï€", pitchfork: "â‹”", piv: "Ï–", planck: "â„", planckh: "â„", plankv: "â„", plusacir: "â¨£", plusb: "âŠ", pluscir: "â¨¢", plus: "+", plusdo: "âˆ”", plusdu: "â¨¥", pluse: "â©²", PlusMinus: "Â±", plusmn: "Â±", plussim: "â¨¦", plustwo: "â¨§", pm: "Â±", Poincareplane: "â„Œ", pointint: "â¨•", popf: "ğ•¡", Popf: "â„™", pound: "Â£", prap: "âª·", Pr: "âª»", pr: "â‰º", prcue: "â‰¼", precapprox: "âª·", prec: "â‰º", preccurlyeq: "â‰¼", Precedes: "â‰º", PrecedesEqual: "âª¯", PrecedesSlantEqual: "â‰¼", PrecedesTilde: "â‰¾", preceq: "âª¯", precnapprox: "âª¹", precneqq: "âªµ", precnsim: "â‹¨", pre: "âª¯", prE: "âª³", precsim: "â‰¾", prime: "â€²", Prime: "â€³", primes: "â„™", prnap: "âª¹", prnE: "âªµ", prnsim: "â‹¨", prod: "âˆ", Product: "âˆ", profalar: "âŒ®", profline: "âŒ’", profsurf: "âŒ“", prop: "âˆ", Proportional: "âˆ", Proportion: "âˆ·", propto: "âˆ", prsim: "â‰¾", prurel: "âŠ°", Pscr: "ğ’«", pscr: "ğ“…", Psi: "Î¨", psi: "Ïˆ", puncsp: "â€ˆ", Qfr: "ğ””", qfr: "ğ”®", qint: "â¨Œ", qopf: "ğ•¢", Qopf: "â„š", qprime: "â—", Qscr: "ğ’¬", qscr: "ğ“†", quaternions: "â„", quatint: "â¨–", quest: "?", questeq: "â‰Ÿ", quot: '"', QUOT: '"', rAarr: "â‡›", race: "âˆ½Ì±", Racute: "Å”", racute: "Å•", radic: "âˆš", raemptyv: "â¦³", rang: "âŸ©", Rang: "âŸ«", rangd: "â¦’", range: "â¦¥", rangle: "âŸ©", raquo: "Â»", rarrap: "â¥µ", rarrb: "â‡¥", rarrbfs: "â¤ ", rarrc: "â¤³", rarr: "â†’", Rarr: "â† ", rArr: "â‡’", rarrfs: "â¤", rarrhk: "â†ª", rarrlp: "â†¬", rarrpl: "â¥…", rarrsim: "â¥´", Rarrtl: "â¤–", rarrtl: "â†£", rarrw: "â†", ratail: "â¤š", rAtail: "â¤œ", ratio: "âˆ¶", rationals: "â„š", rbarr: "â¤", rBarr: "â¤", RBarr: "â¤", rbbrk: "â³", rbrace: "}", rbrack: "]", rbrke: "â¦Œ", rbrksld: "â¦", rbrkslu: "â¦", Rcaron: "Å˜", rcaron: "Å™", Rcedil: "Å–", rcedil: "Å—", rceil: "âŒ‰", rcub: "}", Rcy: "Ğ ", rcy: "Ñ€", rdca: "â¤·", rdldhar: "â¥©", rdquo: "â€", rdquor: "â€", rdsh: "â†³", real: "â„œ", realine: "â„›", realpart: "â„œ", reals: "â„", Re: "â„œ", rect: "â–­", reg: "Â®", REG: "Â®", ReverseElement: "âˆ‹", ReverseEquilibrium: "â‡‹", ReverseUpEquilibrium: "â¥¯", rfisht: "â¥½", rfloor: "âŒ‹", rfr: "ğ”¯", Rfr: "â„œ", rHar: "â¥¤", rhard: "â‡", rharu: "â‡€", rharul: "â¥¬", Rho: "Î¡", rho: "Ï", rhov: "Ï±", RightAngleBracket: "âŸ©", RightArrowBar: "â‡¥", rightarrow: "â†’", RightArrow: "â†’", Rightarrow: "â‡’", RightArrowLeftArrow: "â‡„", rightarrowtail: "â†£", RightCeiling: "âŒ‰", RightDoubleBracket: "âŸ§", RightDownTeeVector: "â¥", RightDownVectorBar: "â¥•", RightDownVector: "â‡‚", RightFloor: "âŒ‹", rightharpoondown: "â‡", rightharpoonup: "â‡€", rightleftarrows: "â‡„", rightleftharpoons: "â‡Œ", rightrightarrows: "â‡‰", rightsquigarrow: "â†", RightTeeArrow: "â†¦", RightTee: "âŠ¢", RightTeeVector: "â¥›", rightthreetimes: "â‹Œ", RightTriangleBar: "â§", RightTriangle: "âŠ³", RightTriangleEqual: "âŠµ", RightUpDownVector: "â¥", RightUpTeeVector: "â¥œ", RightUpVectorBar: "â¥”", RightUpVector: "â†¾", RightVectorBar: "â¥“", RightVector: "â‡€", ring: "Ëš", risingdotseq: "â‰“", rlarr: "â‡„", rlhar: "â‡Œ", rlm: "â€", rmoustache: "â±", rmoust: "â±", rnmid: "â«®", roang: "âŸ­", roarr: "â‡¾", robrk: "âŸ§", ropar: "â¦†", ropf: "ğ•£", Ropf: "â„", roplus: "â¨®", rotimes: "â¨µ", RoundImplies: "â¥°", rpar: ")", rpargt: "â¦”", rppolint: "â¨’", rrarr: "â‡‰", Rrightarrow: "â‡›", rsaquo: "â€º", rscr: "ğ“‡", Rscr: "â„›", rsh: "â†±", Rsh: "â†±", rsqb: "]", rsquo: "â€™", rsquor: "â€™", rthree: "â‹Œ", rtimes: "â‹Š", rtri: "â–¹", rtrie: "âŠµ", rtrif: "â–¸", rtriltri: "â§", RuleDelayed: "â§´", ruluhar: "â¥¨", rx: "â„", Sacute: "Åš", sacute: "Å›", sbquo: "â€š", scap: "âª¸", Scaron: "Å ", scaron: "Å¡", Sc: "âª¼", sc: "â‰»", sccue: "â‰½", sce: "âª°", scE: "âª´", Scedil: "Å", scedil: "ÅŸ", Scirc: "Åœ", scirc: "Å", scnap: "âªº", scnE: "âª¶", scnsim: "â‹©", scpolint: "â¨“", scsim: "â‰¿", Scy: "Ğ¡", scy: "Ñ", sdotb: "âŠ¡", sdot: "â‹…", sdote: "â©¦", searhk: "â¤¥", searr: "â†˜", seArr: "â‡˜", searrow: "â†˜", sect: "Â§", semi: ";", seswar: "â¤©", setminus: "âˆ–", setmn: "âˆ–", sext: "âœ¶", Sfr: "ğ”–", sfr: "ğ”°", sfrown: "âŒ¢", sharp: "â™¯", SHCHcy: "Ğ©", shchcy: "Ñ‰", SHcy: "Ğ¨", shcy: "Ñˆ", ShortDownArrow: "â†“", ShortLeftArrow: "â†", shortmid: "âˆ£", shortparallel: "âˆ¥", ShortRightArrow: "â†’", ShortUpArrow: "â†‘", shy: "Â­", Sigma: "Î£", sigma: "Ïƒ", sigmaf: "Ï‚", sigmav: "Ï‚", sim: "âˆ¼", simdot: "â©ª", sime: "â‰ƒ", simeq: "â‰ƒ", simg: "âª", simgE: "âª ", siml: "âª", simlE: "âªŸ", simne: "â‰†", simplus: "â¨¤", simrarr: "â¥²", slarr: "â†", SmallCircle: "âˆ˜", smallsetminus: "âˆ–", smashp: "â¨³", smeparsl: "â§¤", smid: "âˆ£", smile: "âŒ£", smt: "âªª", smte: "âª¬", smtes: "âª¬ï¸€", SOFTcy: "Ğ¬", softcy: "ÑŒ", solbar: "âŒ¿", solb: "â§„", sol: "/", Sopf: "ğ•Š", sopf: "ğ•¤", spades: "â™ ", spadesuit: "â™ ", spar: "âˆ¥", sqcap: "âŠ“", sqcaps: "âŠ“ï¸€", sqcup: "âŠ”", sqcups: "âŠ”ï¸€", Sqrt: "âˆš", sqsub: "âŠ", sqsube: "âŠ‘", sqsubset: "âŠ", sqsubseteq: "âŠ‘", sqsup: "âŠ", sqsupe: "âŠ’", sqsupset: "âŠ", sqsupseteq: "âŠ’", square: "â–¡", Square: "â–¡", SquareIntersection: "âŠ“", SquareSubset: "âŠ", SquareSubsetEqual: "âŠ‘", SquareSuperset: "âŠ", SquareSupersetEqual: "âŠ’", SquareUnion: "âŠ”", squarf: "â–ª", squ: "â–¡", squf: "â–ª", srarr: "â†’", Sscr: "ğ’®", sscr: "ğ“ˆ", ssetmn: "âˆ–", ssmile: "âŒ£", sstarf: "â‹†", Star: "â‹†", star: "â˜†", starf: "â˜…", straightepsilon: "Ïµ", straightphi: "Ï•", strns: "Â¯", sub: "âŠ‚", Sub: "â‹", subdot: "âª½", subE: "â«…", sube: "âŠ†", subedot: "â«ƒ", submult: "â«", subnE: "â«‹", subne: "âŠŠ", subplus: "âª¿", subrarr: "â¥¹", subset: "âŠ‚", Subset: "â‹", subseteq: "âŠ†", subseteqq: "â«…", SubsetEqual: "âŠ†", subsetneq: "âŠŠ", subsetneqq: "â«‹", subsim: "â«‡", subsub: "â«•", subsup: "â«“", succapprox: "âª¸", succ: "â‰»", succcurlyeq: "â‰½", Succeeds: "â‰»", SucceedsEqual: "âª°", SucceedsSlantEqual: "â‰½", SucceedsTilde: "â‰¿", succeq: "âª°", succnapprox: "âªº", succneqq: "âª¶", succnsim: "â‹©", succsim: "â‰¿", SuchThat: "âˆ‹", sum: "âˆ‘", Sum: "âˆ‘", sung: "â™ª", sup1: "Â¹", sup2: "Â²", sup3: "Â³", sup: "âŠƒ", Sup: "â‹‘", supdot: "âª¾", supdsub: "â«˜", supE: "â«†", supe: "âŠ‡", supedot: "â«„", Superset: "âŠƒ", SupersetEqual: "âŠ‡", suphsol: "âŸ‰", suphsub: "â«—", suplarr: "â¥»", supmult: "â«‚", supnE: "â«Œ", supne: "âŠ‹", supplus: "â«€", supset: "âŠƒ", Supset: "â‹‘", supseteq: "âŠ‡", supseteqq: "â«†", supsetneq: "âŠ‹", supsetneqq: "â«Œ", supsim: "â«ˆ", supsub: "â«”", supsup: "â«–", swarhk: "â¤¦", swarr: "â†™", swArr: "â‡™", swarrow: "â†™", swnwar: "â¤ª", szlig: "ÃŸ", Tab: "	", target: "âŒ–", Tau: "Î¤", tau: "Ï„", tbrk: "â´", Tcaron: "Å¤", tcaron: "Å¥", Tcedil: "Å¢", tcedil: "Å£", Tcy: "Ğ¢", tcy: "Ñ‚", tdot: "âƒ›", telrec: "âŒ•", Tfr: "ğ”—", tfr: "ğ”±", there4: "âˆ´", therefore: "âˆ´", Therefore: "âˆ´", Theta: "Î˜", theta: "Î¸", thetasym: "Ï‘", thetav: "Ï‘", thickapprox: "â‰ˆ", thicksim: "âˆ¼", ThickSpace: "âŸâ€Š", ThinSpace: "â€‰", thinsp: "â€‰", thkap: "â‰ˆ", thksim: "âˆ¼", THORN: "Ã", thorn: "Ã¾", tilde: "Ëœ", Tilde: "âˆ¼", TildeEqual: "â‰ƒ", TildeFullEqual: "â‰…", TildeTilde: "â‰ˆ", timesbar: "â¨±", timesb: "âŠ ", times: "Ã—", timesd: "â¨°", tint: "âˆ­", toea: "â¤¨", topbot: "âŒ¶", topcir: "â«±", top: "âŠ¤", Topf: "ğ•‹", topf: "ğ•¥", topfork: "â«š", tosa: "â¤©", tprime: "â€´", trade: "â„¢", TRADE: "â„¢", triangle: "â–µ", triangledown: "â–¿", triangleleft: "â—ƒ", trianglelefteq: "âŠ´", triangleq: "â‰œ", triangleright: "â–¹", trianglerighteq: "âŠµ", tridot: "â—¬", trie: "â‰œ", triminus: "â¨º", TripleDot: "âƒ›", triplus: "â¨¹", trisb: "â§", tritime: "â¨»", trpezium: "â¢", Tscr: "ğ’¯", tscr: "ğ“‰", TScy: "Ğ¦", tscy: "Ñ†", TSHcy: "Ğ‹", tshcy: "Ñ›", Tstrok: "Å¦", tstrok: "Å§", twixt: "â‰¬", twoheadleftarrow: "â†", twoheadrightarrow: "â† ", Uacute: "Ãš", uacute: "Ãº", uarr: "â†‘", Uarr: "â†Ÿ", uArr: "â‡‘", Uarrocir: "â¥‰", Ubrcy: "Ğ", ubrcy: "Ñ", Ubreve: "Å¬", ubreve: "Å­", Ucirc: "Ã›", ucirc: "Ã»", Ucy: "Ğ£", ucy: "Ñƒ", udarr: "â‡…", Udblac: "Å°", udblac: "Å±", udhar: "â¥®", ufisht: "â¥¾", Ufr: "ğ”˜", ufr: "ğ”²", Ugrave: "Ã™", ugrave: "Ã¹", uHar: "â¥£", uharl: "â†¿", uharr: "â†¾", uhblk: "â–€", ulcorn: "âŒœ", ulcorner: "âŒœ", ulcrop: "âŒ", ultri: "â—¸", Umacr: "Åª", umacr: "Å«", uml: "Â¨", UnderBar: "_", UnderBrace: "âŸ", UnderBracket: "âµ", UnderParenthesis: "â", Union: "â‹ƒ", UnionPlus: "âŠ", Uogon: "Å²", uogon: "Å³", Uopf: "ğ•Œ", uopf: "ğ•¦", UpArrowBar: "â¤’", uparrow: "â†‘", UpArrow: "â†‘", Uparrow: "â‡‘", UpArrowDownArrow: "â‡…", updownarrow: "â†•", UpDownArrow: "â†•", Updownarrow: "â‡•", UpEquilibrium: "â¥®", upharpoonleft: "â†¿", upharpoonright: "â†¾", uplus: "âŠ", UpperLeftArrow: "â†–", UpperRightArrow: "â†—", upsi: "Ï…", Upsi: "Ï’", upsih: "Ï’", Upsilon: "Î¥", upsilon: "Ï…", UpTeeArrow: "â†¥", UpTee: "âŠ¥", upuparrows: "â‡ˆ", urcorn: "âŒ", urcorner: "âŒ", urcrop: "âŒ", Uring: "Å®", uring: "Å¯", urtri: "â—¹", Uscr: "ğ’°", uscr: "ğ“Š", utdot: "â‹°", Utilde: "Å¨", utilde: "Å©", utri: "â–µ", utrif: "â–´", uuarr: "â‡ˆ", Uuml: "Ãœ", uuml: "Ã¼", uwangle: "â¦§", vangrt: "â¦œ", varepsilon: "Ïµ", varkappa: "Ï°", varnothing: "âˆ…", varphi: "Ï•", varpi: "Ï–", varpropto: "âˆ", varr: "â†•", vArr: "â‡•", varrho: "Ï±", varsigma: "Ï‚", varsubsetneq: "âŠŠï¸€", varsubsetneqq: "â«‹ï¸€", varsupsetneq: "âŠ‹ï¸€", varsupsetneqq: "â«Œï¸€", vartheta: "Ï‘", vartriangleleft: "âŠ²", vartriangleright: "âŠ³", vBar: "â«¨", Vbar: "â««", vBarv: "â«©", Vcy: "Ğ’", vcy: "Ğ²", vdash: "âŠ¢", vDash: "âŠ¨", Vdash: "âŠ©", VDash: "âŠ«", Vdashl: "â«¦", veebar: "âŠ»", vee: "âˆ¨", Vee: "â‹", veeeq: "â‰š", vellip: "â‹®", verbar: "|", Verbar: "â€–", vert: "|", Vert: "â€–", VerticalBar: "âˆ£", VerticalLine: "|", VerticalSeparator: "â˜", VerticalTilde: "â‰€", VeryThinSpace: "â€Š", Vfr: "ğ”™", vfr: "ğ”³", vltri: "âŠ²", vnsub: "âŠ‚âƒ’", vnsup: "âŠƒâƒ’", Vopf: "ğ•", vopf: "ğ•§", vprop: "âˆ", vrtri: "âŠ³", Vscr: "ğ’±", vscr: "ğ“‹", vsubnE: "â«‹ï¸€", vsubne: "âŠŠï¸€", vsupnE: "â«Œï¸€", vsupne: "âŠ‹ï¸€", Vvdash: "âŠª", vzigzag: "â¦š", Wcirc: "Å´", wcirc: "Åµ", wedbar: "â©Ÿ", wedge: "âˆ§", Wedge: "â‹€", wedgeq: "â‰™", weierp: "â„˜", Wfr: "ğ”š", wfr: "ğ”´", Wopf: "ğ•", wopf: "ğ•¨", wp: "â„˜", wr: "â‰€", wreath: "â‰€", Wscr: "ğ’²", wscr: "ğ“Œ", xcap: "â‹‚", xcirc: "â—¯", xcup: "â‹ƒ", xdtri: "â–½", Xfr: "ğ”›", xfr: "ğ”µ", xharr: "âŸ·", xhArr: "âŸº", Xi: "Î", xi: "Î¾", xlarr: "âŸµ", xlArr: "âŸ¸", xmap: "âŸ¼", xnis: "â‹»", xodot: "â¨€", Xopf: "ğ•", xopf: "ğ•©", xoplus: "â¨", xotime: "â¨‚", xrarr: "âŸ¶", xrArr: "âŸ¹", Xscr: "ğ’³", xscr: "ğ“", xsqcup: "â¨†", xuplus: "â¨„", xutri: "â–³", xvee: "â‹", xwedge: "â‹€", Yacute: "Ã", yacute: "Ã½", YAcy: "Ğ¯", yacy: "Ñ", Ycirc: "Å¶", ycirc: "Å·", Ycy: "Ğ«", ycy: "Ñ‹", yen: "Â¥", Yfr: "ğ”œ", yfr: "ğ”¶", YIcy: "Ğ‡", yicy: "Ñ—", Yopf: "ğ•", yopf: "ğ•ª", Yscr: "ğ’´", yscr: "ğ“", YUcy: "Ğ®", yucy: "Ñ", yuml: "Ã¿", Yuml: "Å¸", Zacute: "Å¹", zacute: "Åº", Zcaron: "Å½", zcaron: "Å¾", Zcy: "Ğ—", zcy: "Ğ·", Zdot: "Å»", zdot: "Å¼", zeetrf: "â„¨", ZeroWidthSpace: "â€‹", Zeta: "Î–", zeta: "Î¶", zfr: "ğ”·", Zfr: "â„¨", ZHcy: "Ğ–", zhcy: "Ğ¶", zigrarr: "â‡", zopf: "ğ•«", Zopf: "â„¤", Zscr: "ğ’µ", zscr: "ğ“", zwj: "â€", zwnj: "â€Œ" };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    "use strict";
    module.exports = require_entities();
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module) {
    "use strict";
    var encodeCache2 = {};
    function getEncodeCache2(exclude) {
      var i, ch, cache = encodeCache2[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache2[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode4(string, exclude, keepEscaped) {
      var i, l, code4, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode4.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache2(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code4 = string.charCodeAt(i);
        if (keepEscaped && code4 === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code4 < 128) {
          result += cache[code4];
          continue;
        }
        if (code4 >= 55296 && code4 <= 57343) {
          if (code4 >= 55296 && code4 <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode4.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode4.componentChars = "-_.!~*'()";
    module.exports = encode4;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module) {
    "use strict";
    var decodeCache2 = {};
    function getDecodeCache2(exclude) {
      var i, ch, cache = decodeCache2[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache2[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode4(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode4.defaultChars;
      }
      cache = getDecodeCache2(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l, b1, b2, b3, b4, chr, result = "";
        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "ï¿½ï¿½";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "ï¿½ï¿½ï¿½";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "ï¿½ï¿½ï¿½ï¿½";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "ï¿½";
        }
        return result;
      });
    }
    decode4.defaultChars = ";/?:@&=+$,#";
    decode4.componentChars = "";
    module.exports = decode4;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module) {
    "use strict";
    module.exports = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module) {
    "use strict";
    function Url2() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern2 = /^([a-z0-9.+-]+:)/i;
    var portPattern2 = /:[0-9]*$/;
    var simplePathPattern2 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims2 = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise2 = ["{", "}", "|", "\\", "^", "`"].concat(delims2);
    var autoEscape2 = ["'"].concat(unwise2);
    var nonHostChars2 = ["%", "/", "?", ";", "#"].concat(autoEscape2);
    var hostEndingChars2 = ["/", "?", "#"];
    var hostnameMaxLen2 = 255;
    var hostnamePartPattern2 = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart2 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol2 = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol2 = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse2(url, slashesDenoteHost) {
      if (url && url instanceof Url2) {
        return url;
      }
      var u = new Url2();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url2.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern2.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern2.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol2[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol2[proto] && (slashes || proto && !slashedProtocol2[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars2.length; i++) {
          hec = rest.indexOf(hostEndingChars2[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars2.length; i++) {
          hec = rest.indexOf(nonHostChars2[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern2)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern2)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart2);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen2) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol2[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url2.prototype.parseHost = function(host) {
      var port = portPattern2.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse2;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module) {
    "use strict";
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex();
    exports.Cc = require_regex2();
    exports.Cf = require_regex5();
    exports.P = require_regex4();
    exports.Z = require_regex3();
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class3(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString3(obj) {
      return _class3(obj) === "[object String]";
    }
    var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function has2(object, key) {
      return _hasOwnProperty2.call(object, key);
    }
    function assign3(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt2(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode2(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint3(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE2 = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE2 = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE2 = new RegExp(UNESCAPE_MD_RE2.source + "|" + ENTITY_RE2.source, "gi");
    var DIGITAL_ENTITY_TEST_RE2 = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
    var entities = require_entities2();
    function replaceEntityPattern2(match2, name7) {
      var code4;
      if (has2(entities, name7)) {
        return entities[name7];
      }
      if (name7.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE2.test(name7)) {
        code4 = name7[1].toLowerCase() === "x" ? parseInt(name7.slice(2), 16) : parseInt(name7.slice(1), 10);
        if (isValidEntityCode2(code4)) {
          return fromCodePoint3(code4);
        }
      }
      return match2;
    }
    function unescapeMd2(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE2, "$1");
    }
    function unescapeAll2(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE2, function(match2, escaped, entity2) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern2(match2, entity2);
      });
    }
    var HTML_ESCAPE_TEST_RE2 = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE2 = /[&<>"]/g;
    var HTML_REPLACEMENTS2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar2(ch) {
      return HTML_REPLACEMENTS2[ch];
    }
    function escapeHtml2(str) {
      if (HTML_ESCAPE_TEST_RE2.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE2, replaceUnsafeChar2);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE2 = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE3(str) {
      return str.replace(REGEXP_ESCAPE_RE2, "\\$&");
    }
    function isSpace2(code4) {
      switch (code4) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace2(code4) {
      if (code4 >= 8192 && code4 <= 8202) {
        return true;
      }
      switch (code4) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex4();
    function isPunctChar2(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct2(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference2(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("áº".toLowerCase() === "á¹¾") {
        str = str.replace(/áº/g, "ÃŸ");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign3;
    exports.isString = isString3;
    exports.has = has2;
    exports.unescapeMd = unescapeMd2;
    exports.unescapeAll = unescapeAll2;
    exports.isValidEntityCode = isValidEntityCode2;
    exports.fromCodePoint = fromCodePoint3;
    exports.escapeHtml = escapeHtml2;
    exports.arrayReplaceAt = arrayReplaceAt2;
    exports.isSpace = isSpace2;
    exports.isWhiteSpace = isWhiteSpace2;
    exports.isMdAsciiPunct = isMdAsciiPunct2;
    exports.isPunctChar = isPunctChar2;
    exports.escapeRE = escapeRE3;
    exports.normalizeReference = normalizeReference2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    "use strict";
    module.exports = function parseLinkLabel2(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    "use strict";
    var unescapeAll2 = require_utils().unescapeAll;
    module.exports = function parseLinkDestination2(str, start, max) {
      var code4, level, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code4 = str.charCodeAt(pos);
          if (code4 === 10) {
            return result;
          }
          if (code4 === 60) {
            return result;
          }
          if (code4 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll2(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code4 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code4 = str.charCodeAt(pos);
        if (code4 === 32) {
          break;
        }
        if (code4 < 32 || code4 === 127) {
          break;
        }
        if (code4 === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code4 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code4 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll2(str.slice(start, pos));
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    "use strict";
    var unescapeAll2 = require_utils().unescapeAll;
    module.exports = function parseLinkTitle2(str, start, max) {
      var code4, marker, lines = 0, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code4 = str.charCodeAt(pos);
        if (code4 === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll2(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code4 === 40 && marker === 41) {
          return result;
        } else if (code4 === 10) {
          lines++;
        } else if (code4 === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/renderer.js"(exports, module) {
    "use strict";
    var assign3 = require_utils().assign;
    var unescapeAll2 = require_utils().unescapeAll;
    var escapeHtml2 = require_utils().escapeHtml;
    var default_rules2 = {};
    default_rules2.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml2(token.content) + "</code>";
    };
    default_rules2.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules2.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll2(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);
      } else {
        highlighted = escapeHtml2(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules2.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules2.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules2.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules2.text = function(tokens, idx) {
      return escapeHtml2(tokens[idx].content);
    };
    default_rules2.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules2.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer2() {
      this.rules = assign3({}, default_rules2);
    }
    Renderer2.prototype.renderAttrs = function renderAttrs2(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml2(token.attrs[i][0]) + '="' + escapeHtml2(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer2.prototype.renderToken = function renderToken2(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer2.prototype.renderInline = function(tokens, options, env) {
      var type, result = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer2.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer2.prototype.render = function(tokens, options, env) {
      var i, len, type, result = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/ruler.js"(exports, module) {
    "use strict";
    function Ruler2() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler2.prototype.__find__ = function(name7) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name7) {
          return i;
        }
      }
      return -1;
    };
    Ruler2.prototype.__compile__ = function() {
      var self = this;
      var chains = [""];
      self.__rules__.forEach(function(rule3) {
        if (!rule3.enabled) {
          return;
        }
        rule3.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self.__cache__ = {};
      chains.forEach(function(chain) {
        self.__cache__[chain] = [];
        self.__rules__.forEach(function(rule3) {
          if (!rule3.enabled) {
            return;
          }
          if (chain && rule3.alt.indexOf(chain) < 0) {
            return;
          }
          self.__cache__[chain].push(rule3.fn);
        });
      });
    };
    Ruler2.prototype.at = function(name7, fn, options) {
      var index = this.__find__(name7);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name7);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler2.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler2.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler2.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler2.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name7) {
        var idx = this.__find__(name7);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name7);
        }
        this.__rules__[idx].enabled = true;
        result.push(name7);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler2.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule3) {
        rule3.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler2.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name7) {
        var idx = this.__find__(name7);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name7);
        }
        this.__rules__[idx].enabled = false;
        result.push(name7);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler2.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    "use strict";
    var NEWLINES_RE2 = /\r\n?|\n/g;
    var NULL_RE2 = /\0/g;
    module.exports = function normalize3(state) {
      var str;
      str = state.src.replace(NEWLINES_RE2, "\n");
      str = str.replace(NULL_RE2, "ï¿½");
      state.src = str;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    "use strict";
    module.exports = function block2(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    "use strict";
    module.exports = function inline2(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    "use strict";
    var arrayReplaceAt2 = require_utils().arrayReplaceAt;
    function isLinkOpen3(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose3(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify4(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text4, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen3(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose3(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text4 = currentToken.content;
            links = state.md.linkify.match(text4);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text4.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text4.length) {
              token = new state.Token("text", "", 0);
              token.content = text4.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt2(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    "use strict";
    var RARE_RE2 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE2 = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE2 = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR2 = {
      c: "Â©",
      r: "Â®",
      tm: "â„¢"
    };
    function replaceFn2(match2, name7) {
      return SCOPED_ABBR2[name7.toLowerCase()];
    }
    function replace_scoped2(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE2, replaceFn2);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare2(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE2.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE2.test(state.tokens[blkIdx].content)) {
          replace_scoped2(state.tokens[blkIdx].children);
        }
        if (RARE_RE2.test(state.tokens[blkIdx].content)) {
          replace_rare2(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    "use strict";
    var isWhiteSpace2 = require_utils().isWhiteSpace;
    var isPunctChar2 = require_utils().isPunctChar;
    var isMdAsciiPunct2 = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE2 = /['"]/;
    var QUOTE_RE2 = /['"]/g;
    var APOSTROPHE2 = "â€™";
    function replaceAt2(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines2(tokens, state) {
      var i, token, text4, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text4 = token.content;
        pos = 0;
        max = text4.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE2.lastIndex = pos;
            t = QUOTE_RE2.exec(text4);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text4.charCodeAt(t.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text4.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct2(lastChar) || isPunctChar2(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct2(nextChar) || isPunctChar2(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace2(lastChar);
            isNextWhiteSpace = isWhiteSpace2(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt2(token.content, t.index, APOSTROPHE2);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt2(token.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt2(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text4 = token.content;
                  max = text4.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt2(token.content, t.index, APOSTROPHE2);
            }
          }
      }
    }
    module.exports = function smartquotes2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE2.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines2(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/text_join.js"(exports, module) {
    "use strict";
    module.exports = function text_join2(state) {
      var j, l, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/token.js"(exports, module) {
    "use strict";
    function Token2(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token2.prototype.attrIndex = function attrIndex2(name7) {
      var attrs10, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs10 = this.attrs;
      for (i = 0, len = attrs10.length; i < len; i++) {
        if (attrs10[i][0] === name7) {
          return i;
        }
      }
      return -1;
    };
    Token2.prototype.attrPush = function attrPush2(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token2.prototype.attrSet = function attrSet2(name7, value) {
      var idx = this.attrIndex(name7), attrData = [name7, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token2.prototype.attrGet = function attrGet2(name7) {
      var idx = this.attrIndex(name7), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token2.prototype.attrJoin = function attrJoin2(name7, value) {
      var idx = this.attrIndex(name7);
      if (idx < 0) {
        this.attrPush([name7, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module.exports = Token2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    function StateCore2(src, md2, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md2;
    }
    StateCore2.prototype.Token = Token2;
    module.exports = StateCore2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    "use strict";
    var Ruler2 = require_ruler();
    var _rules4 = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", require_text_join()]
    ];
    function Core2() {
      this.ruler = new Ruler2();
      for (var i = 0; i < _rules4.length; i++) {
        this.ruler.push(_rules4[i][0], _rules4[i][1]);
      }
    }
    Core2.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core2.prototype.State = require_state_core();
    module.exports = Core2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    function getLine2(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit2(str) {
      var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module.exports = function table5(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace2(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace2(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace2(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit2(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit2(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    "use strict";
    module.exports = function code4(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    "use strict";
    module.exports = function fence2(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    module.exports = function blockquote4(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldBMarks = [];
      oldBSCount = [];
      oldSCount = [];
      oldTShift = [];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + initial) % 4 === 3) {
              pos++;
              initial++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          offset = initial;
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace2(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    module.exports = function hr2(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace2(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    function skipBulletListMarker2(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace2(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker2(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace2(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs2(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module.exports = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, nextLine = startLine, isTerminatingParagraph = false, tight = true;
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[nextLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker2(state, nextLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker2(state, nextLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
          return false;
      }
      if (silent) {
        return true;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [nextLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [nextLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[nextLine];
        oldSCount = state.sCount[nextLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
        state.sCount[nextLine] = offset;
        if (contentStart >= max && state.isEmpty(nextLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, nextLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[nextLine] = oldTShift;
        state.sCount[nextLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = state.line;
        itemLines[1] = nextLine;
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker2(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker2(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs2(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    "use strict";
    var normalizeReference2 = require_utils().normalizeReference;
    var isSpace2 = require_utils().isSpace;
    module.exports = function reference2(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace2(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace2(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace2(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace2(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference2(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    "use strict";
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    "use strict";
    var attr_name2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted2 = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted2 = "'[^']*'";
    var double_quoted2 = '"[^"]*"';
    var attr_value2 = "(?:" + unquoted2 + "|" + single_quoted2 + "|" + double_quoted2 + ")";
    var attribute2 = "(?:\\s+" + attr_name2 + "(?:\\s*=\\s*" + attr_value2 + ")?)";
    var open_tag2 = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute2 + "*\\s*\\/?>";
    var close_tag2 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing2 = "<[?][\\s\\S]*?[?]>";
    var declaration2 = "<![A-Z]+\\s+[^>]*>";
    var cdata2 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE2 = new RegExp("^(?:" + open_tag2 + "|" + close_tag2 + "|" + comment2 + "|" + processing2 + "|" + declaration2 + "|" + cdata2 + ")");
    var HTML_OPEN_CLOSE_TAG_RE2 = new RegExp("^(?:" + open_tag2 + "|" + close_tag2 + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE2;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE2 = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES2 = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE2.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block2(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i = 0; i < HTML_SEQUENCES2.length; i++) {
        if (HTML_SEQUENCES2[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES2.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES2[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES2[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES2[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    module.exports = function heading4(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace2(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace2(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    "use strict";
    module.exports = function lheading2(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    "use strict";
    module.exports = function paragraph4(state, startLine, endLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    var isSpace2 = require_utils().isSpace;
    function StateBlock2(src, md2, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md2;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace2(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock2.prototype.push = function(type, tag, nesting) {
      var token = new Token2(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock2.prototype.isEmpty = function isEmpty2(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock2.prototype.skipEmptyLines = function skipEmptyLines2(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock2.prototype.skipSpaces = function skipSpaces2(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace2(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock2.prototype.skipSpacesBack = function skipSpacesBack2(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace2(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock2.prototype.skipChars = function skipChars2(pos, code4) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code4) {
          break;
        }
      }
      return pos;
    };
    StateBlock2.prototype.skipCharsBack = function skipCharsBack2(pos, code4, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code4 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock2.prototype.getLines = function getLines2(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace2(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock2.prototype.Token = Token2;
    module.exports = StateBlock2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    "use strict";
    var Ruler2 = require_ruler();
    var _rules4 = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock2() {
      this.ruler = new Ruler2();
      for (var i = 0; i < _rules4.length; i++) {
        this.ruler.push(_rules4[i][0], _rules4[i][1], { alt: (_rules4[i][2] || []).slice() });
      }
    }
    ParserBlock2.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, prevLine, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        prevLine = state.line;
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            if (prevLine >= state.line) {
              throw new Error("block rule didn't increment state.line");
            }
            break;
          }
        }
        if (!ok)
          throw new Error("none of the block rules matched");
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock2.prototype.parse = function(src, md2, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md2, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock2.prototype.State = require_state_block();
    module.exports = ParserBlock2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    "use strict";
    function isTerminatorChar2(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text4(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar2(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/linkify.js"(exports, module) {
    "use strict";
    var SCHEME_RE2 = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module.exports = function linkify4(state, silent) {
      var pos, max, match2, proto, link4, url, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match2 = state.pending.match(SCHEME_RE2);
      if (!match2)
        return false;
      proto = match2[1];
      link4 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link4)
        return false;
      url = link4.url;
      if (url.length <= proto.length)
        return false;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    module.exports = function newline2(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace2(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    "use strict";
    var isSpace2 = require_utils().isSpace;
    var ESCAPED2 = [];
    for (i = 0; i < 256; i++) {
      ESCAPED2.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED2[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape3(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace2(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED2[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    "use strict";
    module.exports = function backtick2(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess3(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess3(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess3(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess3(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess3(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess3(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    "use strict";
    var normalizeReference2 = require_utils().normalizeReference;
    var isSpace2 = require_utils().isSpace;
    module.exports = function link4(state, silent) {
      var attrs10, code4, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code4 = state.src.charCodeAt(pos);
          if (!isSpace2(code4) && code4 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code4 = state.src.charCodeAt(pos);
            if (!isSpace2(code4) && code4 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code4 = state.src.charCodeAt(pos);
              if (!isSpace2(code4) && code4 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference2(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs10 = [["href", href]];
        if (title) {
          attrs10.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    "use strict";
    var normalizeReference2 = require_utils().normalizeReference;
    var isSpace2 = require_utils().isSpace;
    module.exports = function image4(state, silent) {
      var attrs10, code4, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code4 = state.src.charCodeAt(pos);
          if (!isSpace2(code4) && code4 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code4 = state.src.charCodeAt(pos);
          if (!isSpace2(code4) && code4 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code4 = state.src.charCodeAt(pos);
            if (!isSpace2(code4) && code4 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference2(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs10 = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs10.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    "use strict";
    var EMAIL_RE2 = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE2 = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink2(state, silent) {
      var url, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE2.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE2.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    "use strict";
    var HTML_TAG_RE2 = require_html_re().HTML_TAG_RE;
    function isLinkOpen3(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose3(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter2(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline2(state, silent) {
      var ch, match2, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter2(ch)) {
        return false;
      }
      match2 = state.src.slice(pos).match(HTML_TAG_RE2);
      if (!match2) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = match2[0];
        if (isLinkOpen3(token.content))
          state.linkLevel++;
        if (isLinkClose3(token.content))
          state.linkLevel--;
      }
      state.pos += match2[0].length;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    "use strict";
    var entities = require_entities2();
    var has2 = require_utils().has;
    var isValidEntityCode2 = require_utils().isValidEntityCode;
    var fromCodePoint3 = require_utils().fromCodePoint;
    var DIGITAL_RE2 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE2 = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity2(state, silent) {
      var ch, code4, match2, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match2 = state.src.slice(pos).match(DIGITAL_RE2);
        if (match2) {
          if (!silent) {
            code4 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode2(code4) ? fromCodePoint3(code4) : fromCodePoint3(65533);
            token.markup = match2[0];
            token.info = "entity";
          }
          state.pos += match2[0].length;
          return true;
        }
      } else {
        match2 = state.src.slice(pos).match(NAMED_RE2);
        if (match2) {
          if (has2(entities, match2[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities[match2[1]];
              token.markup = match2[0];
              token.info = "entity";
            }
            state.pos += match2[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    "use strict";
    function processDelimiters2(delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters2(state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters2(tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports, module) {
    "use strict";
    module.exports = function fragments_join2(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    var isWhiteSpace2 = require_utils().isWhiteSpace;
    var isPunctChar2 = require_utils().isPunctChar;
    var isMdAsciiPunct2 = require_utils().isMdAsciiPunct;
    function StateInline2(src, md2, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md2;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline2.prototype.pushPending = function() {
      var token = new Token2("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline2.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token2(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline2.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct2(lastChar) || isPunctChar2(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct2(nextChar) || isPunctChar2(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace2(lastChar);
      isNextWhiteSpace = isWhiteSpace2(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline2.prototype.Token = Token2;
    module.exports = StateInline2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    "use strict";
    var Ruler2 = require_ruler();
    var _rules4 = [
      ["text", require_text()],
      ["linkify", require_linkify2()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules23 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline2() {
      var i;
      this.ruler = new Ruler2();
      for (i = 0; i < _rules4.length; i++) {
        this.ruler.push(_rules4[i][0], _rules4[i][1]);
      }
      this.ruler2 = new Ruler2();
      for (i = 0; i < _rules23.length; i++) {
        this.ruler2.push(_rules23[i][0], _rules23[i][1]);
      }
    }
    ParserInline2.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            if (pos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline2.prototype.tokenize = function(state) {
      var ok, i, prevPos, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        prevPos = state.pos;
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              if (prevPos >= state.pos) {
                throw new Error("inline rule didn't increment state.pos");
              }
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline2.prototype.parse = function(str, md2, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md2, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline2.prototype.State = require_state_inline();
    module.exports = ParserInline2;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/node_modules/linkify-it/lib/re.js"(exports, module) {
    "use strict";
    module.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex().source;
      re.src_Cc = require_regex2().source;
      re.src_Z = require_regex3().source;
      re.src_P = require_regex4().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><ï½œ]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + re.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + re.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/node_modules/linkify-it/index.js
var require_linkify_it2 = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/node_modules/linkify-it/index.js"(exports, module) {
    "use strict";
    function assign3(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class3(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString3(obj) {
      return _class3(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class3(obj) === "[object Object]";
    }
    function isRegExp2(obj) {
      return _class3(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class3(obj) === "[object Function]";
    }
    function escapeRE3(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions2 = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj2(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions2.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas2 = {
      "http:": {
        validate: function(text4, pos, self) {
          var tail = text4.slice(pos);
          if (!self.re.http) {
            self.re.http = new RegExp(
              "^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path,
              "i"
            );
          }
          if (self.re.http.test(tail)) {
            return tail.match(self.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text4, pos, self) {
          var tail = text4.slice(pos);
          if (!self.re.no_http) {
            self.re.no_http = new RegExp(
              "^" + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path,
              "i"
            );
          }
          if (self.re.no_http.test(tail)) {
            if (pos >= 3 && text4[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text4[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text4, pos, self) {
          var tail = text4.slice(pos);
          if (!self.re.mailto) {
            self.re.mailto = new RegExp(
              "^" + self.re.src_email_name + "@" + self.re.src_host_strict,
              "i"
            );
          }
          if (self.re.mailto.test(tail)) {
            return tail.match(self.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re2 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default2 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
    function resetScanCache2(self) {
      self.__index__ = -1;
      self.__text_cache__ = "";
    }
    function createValidator2(re) {
      return function(text4, pos) {
        var tail = text4.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer2() {
      return function(match2, self) {
        self.normalize(match2);
      };
    }
    function compile2(self) {
      var re = self.re = require_re()(self.__opts__);
      var tlds3 = self.__tlds__.slice();
      self.onCompile();
      if (!self.__tlds_replaced__) {
        tlds3.push(tlds_2ch_src_re2);
      }
      tlds3.push(re.src_xn);
      re.src_tlds = tlds3.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self.__compiled__ = {};
      function schemaError(name7, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name7 + '": ' + val);
      }
      Object.keys(self.__schemas__).forEach(function(name7) {
        var val = self.__schemas__[name7];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self.__compiled__[name7] = compiled;
        if (isObject2(val)) {
          if (isRegExp2(val.validate)) {
            compiled.validate = createValidator2(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name7, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer2();
          } else {
            schemaError(name7, val);
          }
          return;
        }
        if (isString3(val)) {
          aliases.push(name7);
          return;
        }
        schemaError(name7, val);
      });
      aliases.forEach(function(alias) {
        if (!self.__compiled__[self.__schemas__[alias]]) {
          return;
        }
        self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
        self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
      });
      self.__compiled__[""] = { validate: null, normalize: createNormalizer2() };
      var slist = Object.keys(self.__compiled__).filter(function(name7) {
        return name7.length > 0 && self.__compiled__[name7];
      }).map(escapeRE3).join("|");
      self.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self.re.schema_at_start = RegExp("^" + self.re.schema_search.source, "i");
      self.re.pretest = RegExp(
        "(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache2(self);
    }
    function Match2(self, shift) {
      var start = self.__index__, end = self.__last_index__, text4 = self.__text_cache__.slice(start, end);
      this.schema = self.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text4;
      this.text = text4;
      this.url = text4;
    }
    function createMatch2(self, shift) {
      var match2 = new Match2(self, shift);
      self.__compiled__[match2.schema].normalize(match2, self);
      return match2;
    }
    function LinkifyIt3(schemas, options) {
      if (!(this instanceof LinkifyIt3)) {
        return new LinkifyIt3(schemas, options);
      }
      if (!options) {
        if (isOptionsObj2(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign3({}, defaultOptions2, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign3({}, defaultSchemas2, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default2;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile2(this);
    }
    LinkifyIt3.prototype.add = function add2(schema2, definition) {
      this.__schemas__[schema2] = definition;
      compile2(this);
      return this;
    };
    LinkifyIt3.prototype.set = function set2(options) {
      this.__opts__ = assign3(this.__opts__, options);
      return this;
    };
    LinkifyIt3.prototype.test = function test2(text4) {
      this.__text_cache__ = text4;
      this.__index__ = -1;
      if (!text4.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text4)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text4)) !== null) {
          len = this.testSchemaAt(text4, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text4.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text4.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text4.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text4.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt3.prototype.pretest = function pretest2(text4) {
      return this.re.pretest.test(text4);
    };
    LinkifyIt3.prototype.testSchemaAt = function testSchemaAt2(text4, schema2, pos) {
      if (!this.__compiled__[schema2.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema2.toLowerCase()].validate(text4, pos, this);
    };
    LinkifyIt3.prototype.match = function match2(text4) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text4) {
        result.push(createMatch2(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text4.slice(shift) : text4;
      while (this.test(tail)) {
        result.push(createMatch2(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt3.prototype.matchAtStart = function matchAtStart2(text4) {
      this.__text_cache__ = text4;
      this.__index__ = -1;
      if (!text4.length)
        return null;
      var m = this.re.schema_at_start.exec(text4);
      if (!m)
        return null;
      var len = this.testSchemaAt(text4, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch2(this, 0);
    };
    LinkifyIt3.prototype.tlds = function tlds3(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile2(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile2(this);
      return this;
    };
    LinkifyIt3.prototype.normalize = function normalize3(match2) {
      if (!match2.schema) {
        match2.url = "http://" + match2.url;
      }
      if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
        match2.url = "mailto:" + match2.url;
      }
    };
    LinkifyIt3.prototype.onCompile = function onCompile2() {
    };
    module.exports = LinkifyIt3;
  }
});

// node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  decode: () => decode,
  default: () => punycode_es6_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "node_modules/punycode/punycode.es6.js"() {
    "use strict";
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7F]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
        // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
        quotes: "â€œâ€â€˜â€™",
        /* â€œâ€â€˜â€™ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
        // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
        quotes: "â€œâ€â€˜â€™",
        /* â€œâ€â€˜â€™ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
        // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
        quotes: "â€œâ€â€˜â€™",
        /* â€œâ€â€˜â€™ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/lib/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer2 = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock2 = require_parser_block();
    var ParserInline2 = require_parser_inline();
    var LinkifyIt3 = require_linkify_it2();
    var mdurl = require_mdurl();
    var punycode3 = (init_punycode_es6(), __toCommonJS(punycode_es6_exports));
    var config2 = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE2 = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE2 = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink2(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE2.test(str) ? GOOD_DATA_RE2.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR2 = ["http:", "https:", "mailto:"];
    function normalizeLink2(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR2.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode3.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText2(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR2.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode3.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt3(presetName, options) {
      if (!(this instanceof MarkdownIt3)) {
        return new MarkdownIt3(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline2();
      this.block = new ParserBlock2();
      this.core = new ParserCore();
      this.renderer = new Renderer2();
      this.linkify = new LinkifyIt3();
      this.validateLink = validateLink2;
      this.normalizeLink = normalizeLink2;
      this.normalizeLinkText = normalizeLinkText2;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt3.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt3.prototype.configure = function(presets) {
      var self = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config2[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name7) {
          if (presets.components[name7].rules) {
            self[name7].ruler.enableOnly(presets.components[name7].rules);
          }
          if (presets.components[name7].rules2) {
            self[name7].ruler2.enableOnly(presets.components[name7].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt3.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name7) {
        return result.indexOf(name7) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name7) {
        return result.indexOf(name7) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt3.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt3.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt3;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/@atlaskit/editor-markdown-transformer/node_modules/markdown-it/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/markdown-it-table/dist/es/table.js
var require_table2 = __commonJS({
  "node_modules/markdown-it-table/dist/es/table.js"(exports, module) {
    function isSpace2(code4) {
      switch (code4) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function getLine2(state, line) {
      var pos = state.bMarks[line] + state.blkIndent, max = state.eMarks[line];
      return state.src.substr(pos, max - pos);
    }
    function escapedSplit2(str) {
      var result = [], pos = 0, max = str.length, ch, escapes = 0, lastPos = 0, backTicked = false, lastBackTick = 0;
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 96) {
          if (backTicked) {
            backTicked = false;
            lastBackTick = pos;
          } else if (escapes % 2 === 0) {
            backTicked = true;
            lastBackTick = pos;
          }
        } else if (ch === 124 && escapes % 2 === 0 && !backTicked) {
          result.push(str.substring(lastPos, pos));
          lastPos = pos + 1;
        }
        if (ch === 92) {
          escapes++;
        } else {
          escapes = 0;
        }
        pos++;
        if (pos === max && backTicked) {
          backTicked = false;
          pos = lastBackTick + 1;
        }
        ch = str.charCodeAt(pos);
      }
      result.push(str.substring(lastPos));
      return result;
    }
    module.exports = function table5(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch !== 124 && ch !== 45 && ch !== 58) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace2(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit2(lineText.replace(/^\||\|$/g, ""));
      columnCount = columns.length;
      if (columnCount > aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        token.map = [startLine, startLine + 1];
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("paragraph_open", "p", 1);
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.map = [startLine, startLine + 1];
        token.children = [];
        token = state.push("paragraph_close", "p", -1);
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token.map = tbodyLines = [startLine + 2, 0];
      var oldLineMax = state.lineMax;
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (lineText.indexOf("|") === -1) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit2(lineText.replace(/^\||\|$/g, ""));
        token = state.push("tr_open", "tr", 1);
        for (var _i = 0, offset = 1; _i < columns.length; _i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[_i]) {
            token.attrs = [["style", "text-align:" + aligns[_i]]];
          }
          var shift = columns[_i][0] === " " || /^(\d+\.|\*|-)$/.test(columns[_i].trim()) ? 1 : 0;
          state.bMarks[nextLine] += offset + shift;
          offset = (columns[_i] || "").length + (shift ? 0 : 1);
          state.eMarks[nextLine] = state.bMarks[nextLine] + offset - 1;
          state.lineMax = 1;
          state.md.block.tokenize(state, nextLine, nextLine + 1);
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      state.lineMax = oldLineMax;
      token = state.push("table_close", "table", -1);
      tableLines[1] = tbodyLines[1] = nextLine;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/createPMSpecFactory.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var createPMNodeSpecFactory = function createPMNodeSpecFactory2(nodeSpec) {
  return function(_ref) {
    var parseDOM = _ref.parseDOM, toDOM69 = _ref.toDOM, toDebugString = _ref.toDebugString;
    return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, nodeSpec), parseDOM && {
      parseDOM
    }), toDOM69 && {
      toDOM: toDOM69
    }), toDebugString && {
      toDebugString
    });
  };
};
var createPMMarkSpecFactory = function createPMMarkSpecFactory2(markSpec) {
  return function(_ref2) {
    var parseDOM = _ref2.parseDOM, toDOM69 = _ref2.toDOM, toDebugString = _ref2.toDebugString;
    return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, markSpec), parseDOM && {
      parseDOM
    }), toDOM69 && {
      toDOM: toDOM69
    }), toDebugString && {
      toDebugString
    });
  };
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/next-schema/generated/nodeTypes.js
var blockCard = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    url: {
      default: null
    },
    datasource: {
      default: null
    },
    width: {
      default: null
    },
    layout: {
      default: null
    },
    data: {
      default: null
    }
  },
  selectable: true,
  draggable: true
});
var blockquote = createPMNodeSpecFactory({
  content: "(paragraph | orderedList | bulletList | unsupportedBlock | codeBlock | mediaGroup | mediaSingle)+",
  group: "block",
  selectable: false,
  defining: true
});
var blockquoteLegacy = createPMNodeSpecFactory({
  content: "(paragraph | unsupportedBlock)+",
  group: "block",
  selectable: false,
  defining: true
});
var blockquoteWithoutNestedCodeblockOrMedia = createPMNodeSpecFactory({
  content: "(paragraph | orderedList | bulletList | unsupportedBlock)+",
  group: "block",
  selectable: false,
  defining: true
});
var bodiedExtension = createPMNodeSpecFactory({
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock)+",
  marks: "dataConsumer fragment",
  group: "block",
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    layout: {
      default: "default"
    },
    localId: {
      default: null
    }
  },
  selectable: true,
  defining: true,
  isolating: true
});
var bodiedExtensionWithMarks = createPMNodeSpecFactory({
  marks: "dataConsumer fragment",
  group: "block",
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    layout: {
      default: "default"
    },
    localId: {
      default: null
    }
  },
  selectable: true,
  defining: true,
  isolating: true
});
var bulletList = createPMNodeSpecFactory({
  content: "listItem+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  selectable: false
});
var caption = createPMNodeSpecFactory({
  content: "(hardBreak | mention | emoji | date | placeholder | inlineCard | status | text | unsupportedInline)*",
  marks: "_",
  selectable: false,
  isolating: true
});
var codeBlock = createPMNodeSpecFactory({
  content: "(text | unsupportedInline)*",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    language: {
      default: null
    },
    uniqueId: {
      default: null
    }
  },
  code: true,
  defining: true
});
var codeBlockWithNoMarks = createPMNodeSpecFactory({
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    language: {
      default: null
    },
    uniqueId: {
      default: null
    }
  },
  code: true,
  defining: true
});
var confluenceJiraIssue = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  atom: true,
  attrs: {
    issueKey: {
      default: ""
    },
    macroId: {
      default: null
    },
    schemaVersion: {
      default: null
    },
    server: {
      default: null
    },
    serverId: {
      default: null
    }
  }
});
var confluenceUnsupportedBlock = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    cxhtml: {
      default: null
    }
  }
});
var confluenceUnsupportedInline = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  atom: true,
  attrs: {
    cxhtml: {
      default: null
    }
  }
});
var date = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    timestamp: {
      default: ""
    }
  },
  selectable: true
});
var dateStage0 = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    timestamp: {
      default: ""
    }
  },
  selectable: true
});
var decisionItem = createPMNodeSpecFactory({
  content: "inline*",
  marks: "_",
  attrs: {
    localId: {
      default: ""
    },
    state: {
      default: "DECIDED"
    }
  },
  defining: true
});
var decisionList = createPMNodeSpecFactory({
  content: "(decisionItem | unsupportedBlock)+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    localId: {
      default: ""
    }
  },
  selectable: false,
  defining: true
});
var doc = createPMNodeSpecFactory({
  content: "(block | layoutSection | blockRootOnly)+",
  marks: "unsupportedMark unsupportedNodeAttribute alignment indentation dataConsumer fragment breakout"
});
var embedCard = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    url: {
      default: ""
    },
    layout: {
      default: "center"
    },
    width: {
      default: 100
    },
    originalHeight: {
      default: null
    },
    originalWidth: {
      default: null
    }
  },
  selectable: true
});
var emoji = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    shortName: {
      default: ""
    },
    id: {
      default: ""
    },
    text: {
      default: ""
    }
  },
  selectable: true
});
var emojiStage0 = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    shortName: {
      default: ""
    },
    id: {
      default: ""
    },
    text: {
      default: ""
    }
  },
  selectable: true
});
var expand = createPMNodeSpecFactory({
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock | nestedExpand)+",
  marks: "unsupportedMark unsupportedNodeAttribute fragment dataConsumer",
  group: "block",
  attrs: {
    title: {
      default: ""
    },
    __expanded: {
      default: true
    }
  },
  selectable: true,
  isolating: true
});
var expandWithNoMark = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    title: {
      default: ""
    },
    __expanded: {
      default: true
    }
  },
  selectable: true,
  isolating: true
});
var expandWithoutNestedExpand = createPMNodeSpecFactory({
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock)+",
  marks: "unsupportedMark unsupportedNodeAttribute fragment dataConsumer",
  group: "block",
  attrs: {
    title: {
      default: ""
    },
    __expanded: {
      default: true
    }
  },
  selectable: true,
  isolating: true
});
var extension = createPMNodeSpecFactory({
  group: "block",
  atom: true,
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    layout: {
      default: "default"
    },
    localId: {
      default: null
    }
  },
  selectable: true
});
var extensionWithMarks = createPMNodeSpecFactory({
  group: "block",
  atom: true,
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    layout: {
      default: "default"
    },
    localId: {
      default: null
    }
  },
  selectable: true
});
var extensionFrameStage0 = createPMNodeSpecFactory({
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | extension | bodiedExtension | unsupportedBlock | blockCard | embedCard)+",
  marks: "dataConsumer fragment",
  attrs: {},
  selectable: false,
  definingAsContext: false,
  definingForContent: true,
  isolating: true
});
var hardBreak = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  selectable: false
});
var heading = createPMNodeSpecFactory({
  content: "inline*",
  group: "block",
  attrs: {
    level: {
      default: 1
    },
    localId: {
      default: null
    }
  },
  selectable: false,
  defining: true
});
var headingWithAlignment = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    level: {
      default: 1
    },
    localId: {
      default: null
    }
  },
  selectable: false,
  defining: true
});
var headingWithIndentation = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    level: {
      default: 1
    },
    localId: {
      default: null
    }
  },
  selectable: false,
  defining: true
});
var headingWithNoMarks = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    level: {
      default: 1
    },
    localId: {
      default: null
    }
  },
  selectable: false,
  defining: true
});
var image = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    src: {
      default: ""
    },
    alt: {
      default: ""
    },
    title: {
      default: null
    }
  },
  draggable: true
});
var inlineCard = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    url: {
      default: null
    },
    data: {
      default: null
    }
  },
  selectable: true,
  draggable: true
});
var inlineCardStage0 = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    url: {
      default: null
    },
    data: {
      default: null
    }
  },
  selectable: true,
  draggable: true
});
var inlineExtension = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    localId: {
      default: null
    }
  },
  selectable: true
});
var inlineExtensionWithMarks = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    localId: {
      default: null
    }
  },
  selectable: true
});
var layoutColumn = createPMNodeSpecFactory({
  content: "(block | unsupportedBlock)+",
  marks: "unsupportedMark unsupportedNodeAttribute alignment indentation dataConsumer fragment",
  attrs: {
    width: {
      default: void 0
    }
  },
  selectable: false,
  isolating: true
});
var layoutSection = createPMNodeSpecFactory({
  content: "(layoutColumn | unsupportedBlock){1,3} unsupportedBlock* | unsupportedBlock+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  isolating: true
});
var layoutSectionFull = createPMNodeSpecFactory({
  content: "(layoutColumn | unsupportedBlock){2,3}",
  marks: "unsupportedMark unsupportedNodeAttribute",
  isolating: true
});
var layoutSectionWithSingleColumnStage0 = createPMNodeSpecFactory({
  content: "(layoutColumn | unsupportedBlock){1,3}",
  marks: "unsupportedMark unsupportedNodeAttribute",
  isolating: true
});
var listItem = createPMNodeSpecFactory({
  content: "(paragraph | mediaSingle | codeBlock | unsupportedBlock) (paragraph | bulletList | orderedList | taskList | mediaSingle | codeBlock | unsupportedBlock)*",
  marks: "unsupportedMark unsupportedNodeAttribute",
  selectable: false,
  defining: true
});
var listItemLegacy = createPMNodeSpecFactory({
  content: "(paragraph | mediaSingle | codeBlock | unsupportedBlock) (paragraph | bulletList | orderedList | mediaSingle | codeBlock | unsupportedBlock)*",
  marks: "unsupportedMark unsupportedNodeAttribute",
  selectable: false,
  defining: true
});
var listItemWithNestedDecisionStage0 = createPMNodeSpecFactory({
  content: "(paragraph | mediaSingle | codeBlock | unsupportedBlock | decisionList) (paragraph | bulletList | orderedList | taskList | mediaSingle | codeBlock | unsupportedBlock | decisionList)*",
  marks: "unsupportedMark unsupportedNodeAttribute",
  selectable: false,
  defining: true
});
var media = createPMNodeSpecFactory({
  attrs: {
    type: {
      default: "file"
    },
    id: {
      default: ""
    },
    alt: {
      default: ""
    },
    collection: {
      default: ""
    },
    height: {
      default: null
    },
    occurrenceKey: {
      default: null
    },
    width: {
      default: null
    },
    __contextId: {
      default: null
    },
    __displayType: {
      default: null
    },
    __external: {
      default: false
    },
    __fileMimeType: {
      default: null
    },
    __fileName: {
      default: null
    },
    __fileSize: {
      default: null
    },
    __mediaTraceId: {
      default: null
    },
    url: {
      default: null
    }
  },
  selectable: true
});
var mediaGroup = createPMNodeSpecFactory({
  content: "(media | unsupportedBlock)+",
  marks: "link annotation border unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {},
  selectable: false
});
var mediaInline = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    type: {
      default: "file"
    },
    url: {
      default: null
    },
    id: {
      default: ""
    },
    alt: {
      default: ""
    },
    collection: {
      default: ""
    },
    occurrenceKey: {
      default: null
    },
    width: {
      default: null
    },
    height: {
      default: null
    },
    __fileName: {
      default: null
    },
    __fileSize: {
      default: null
    },
    __fileMimeType: {
      default: null
    },
    __displayType: {
      default: null
    },
    __contextId: {
      default: null
    },
    __mediaTraceId: {
      default: null
    },
    __external: {
      default: false
    }
  },
  selectable: true
});
var mediaSingle = createPMNodeSpecFactory({
  group: "block",
  atom: true,
  attrs: {
    layout: {
      default: "center"
    },
    width: {
      default: null
    }
  },
  selectable: true,
  content: "media|unsupportedBlock+|media unsupportedBlock+",
  marks: "annotation border link unsupportedMark unsupportedNodeAttribute"
});
var mediaSingleCaption = createPMNodeSpecFactory({
  content: "media|unsupportedBlock+|media (caption|unsupportedBlock) unsupportedBlock*",
  marks: "link annotation border unsupportedMark unsupportedNodeAttribute",
  group: "block",
  atom: false,
  attrs: {
    layout: {
      default: "center"
    },
    width: {
      default: null
    }
  },
  selectable: true
});
var mediaSingleFull = createPMNodeSpecFactory({
  content: "media|unsupportedBlock+|media (caption|unsupportedBlock) unsupportedBlock*",
  marks: "link annotation border unsupportedMark unsupportedNodeAttribute",
  group: "block",
  atom: false,
  attrs: {
    width: {
      default: null
    },
    layout: {
      default: "center"
    },
    widthType: {
      default: null
    }
  },
  selectable: true
});
var mediaSingleWidthType = createPMNodeSpecFactory({
  content: "media|unsupportedBlock+|media unsupportedBlock+",
  marks: "link annotation border unsupportedMark unsupportedNodeAttribute",
  group: "block",
  atom: true,
  attrs: {
    width: {
      default: null
    },
    layout: {
      default: "center"
    },
    widthType: {
      default: null
    }
  },
  selectable: true
});
var mention = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    id: {
      default: ""
    },
    localId: {
      default: null
    },
    text: {
      default: ""
    },
    accessLevel: {
      default: ""
    },
    userType: {
      default: null
    }
  },
  selectable: true
});
var mentionStage0 = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    id: {
      default: ""
    },
    localId: {
      default: null
    },
    text: {
      default: ""
    },
    accessLevel: {
      default: ""
    },
    userType: {
      default: null
    }
  },
  selectable: true
});
var multiBodiedExtensionStage0 = createPMNodeSpecFactory({
  content: "extensionFrame+",
  group: "blockRootOnly",
  attrs: {
    extensionKey: {
      default: ""
    },
    extensionType: {
      default: ""
    },
    parameters: {
      default: null
    },
    text: {
      default: null
    },
    layout: {
      default: "default"
    },
    localId: {
      default: null
    }
  },
  selectable: true,
  definingAsContext: true
});
var nestedExpand = createPMNodeSpecFactory({
  content: "(paragraph | heading | mediaSingle | mediaGroup | codeBlock | bulletList | orderedList | taskList | decisionList | rule | panel | blockquote | unsupportedBlock)+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  attrs: {
    title: {
      default: ""
    },
    __expanded: {
      default: true
    }
  },
  selectable: true,
  isolating: true
});
var nestedExpandWithNoMarks = createPMNodeSpecFactory({
  attrs: {
    title: {
      default: ""
    },
    __expanded: {
      default: true
    }
  },
  selectable: true,
  isolating: true
});
var orderedList = createPMNodeSpecFactory({
  content: "listItem+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    order: {
      default: 1
    }
  },
  selectable: false
});
var panel = createPMNodeSpecFactory({
  content: "(paragraph | heading | bulletList | orderedList | blockCard | mediaGroup | mediaSingle | codeBlock | taskList | rule | decisionList | unsupportedBlock)+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    panelType: {
      default: "info"
    },
    panelIcon: {
      default: null
    },
    panelIconId: {
      default: null
    },
    panelIconText: {
      default: null
    },
    panelColor: {
      default: null
    }
  },
  selectable: true
});
var panelLegacy = createPMNodeSpecFactory({
  content: "(paragraph | heading | bulletList | orderedList | blockCard | unsupportedBlock)+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    panelType: {
      default: "info"
    },
    panelIcon: {
      default: null
    },
    panelIconId: {
      default: null
    },
    panelIconText: {
      default: null
    },
    panelColor: {
      default: null
    }
  },
  selectable: true
});
var panelWithNestedBlockquoteStage0 = createPMNodeSpecFactory({
  content: "(paragraph | heading | bulletList | orderedList | blockCard | mediaGroup | mediaSingle | codeBlock | taskList | rule | decisionList | unsupportedBlock | blockquote)+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    panelType: {
      default: "info"
    },
    panelIcon: {
      default: null
    },
    panelIconId: {
      default: null
    },
    panelIconText: {
      default: null
    },
    panelColor: {
      default: null
    }
  },
  selectable: true
});
var paragraph = createPMNodeSpecFactory({
  content: "inline*",
  marks: "link em strong strike subsup underline textColor annotation backgroundColor typeAheadQuery confluenceInlineComment unsupportedNodeAttribute unsupportedMark code dataConsumer fragment border",
  group: "block",
  attrs: {
    localId: {
      default: null
    }
  },
  selectable: false
});
var paragraphWithAlignment = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    localId: {
      default: null
    }
  },
  selectable: false
});
var paragraphWithIndentation = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    localId: {
      default: null
    }
  },
  selectable: false
});
var paragraphWithNoMarks = createPMNodeSpecFactory({
  group: "block",
  attrs: {
    localId: {
      default: null
    }
  },
  selectable: false
});
var placeholder = createPMNodeSpecFactory({
  marks: "",
  group: "inline",
  inline: true,
  attrs: {
    text: {
      default: ""
    }
  },
  selectable: false
});
var rule = createPMNodeSpecFactory({
  group: "block"
});
var status = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    text: {
      default: ""
    },
    color: {
      default: ""
    },
    localId: {
      default: ""
    },
    style: {
      default: ""
    }
  },
  selectable: true
});
var statusStage0 = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    text: {
      default: ""
    },
    color: {
      default: ""
    },
    localId: {
      default: ""
    },
    style: {
      default: ""
    }
  },
  selectable: true
});
var table = createPMNodeSpecFactory({
  content: "tableRow+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    displayMode: {
      default: null
    },
    isNumberColumnEnabled: {
      default: false
    },
    layout: {
      default: "default"
    },
    localId: {
      default: ""
    },
    width: {
      default: null
    },
    __autoSize: {
      default: false
    }
  },
  selectable: true,
  isolating: true,
  tableRole: "table"
});
var tableCell = createPMNodeSpecFactory({
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle | mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand | unsupportedBlock)+",
  marks: "alignment unsupportedMark unsupportedNodeAttribute dataConsumer fragment",
  attrs: {
    colspan: {
      default: 1
    },
    rowspan: {
      default: 1
    },
    colwidth: {
      default: null
    },
    background: {
      default: null
    }
  },
  selectable: false,
  isolating: true,
  tableRole: "cell"
});
var tableHeader = createPMNodeSpecFactory({
  content: "(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle | mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand)+",
  marks: "alignment unsupportedMark unsupportedNodeAttribute dataConsumer fragment",
  attrs: {
    colspan: {
      default: 1
    },
    rowspan: {
      default: 1
    },
    colwidth: {
      default: null
    },
    background: {
      default: null
    }
  },
  selectable: false,
  isolating: true,
  tableRole: "header_cell"
});
var tableRow = createPMNodeSpecFactory({
  content: "(tableCell | tableHeader)+",
  marks: "unsupportedMark unsupportedNodeAttribute",
  selectable: false,
  tableRole: "row"
});
var taskItem = createPMNodeSpecFactory({
  content: "inline*",
  marks: "_",
  attrs: {
    localId: {
      default: ""
    },
    state: {
      default: "TODO"
    }
  },
  selectable: false,
  defining: true
});
var taskList = createPMNodeSpecFactory({
  content: "(taskItem | unsupportedBlock)+ (taskItem | taskList | unsupportedBlock)*",
  marks: "unsupportedMark unsupportedNodeAttribute",
  group: "block",
  attrs: {
    localId: {
      default: ""
    }
  },
  selectable: false,
  defining: true
});
var text = createPMNodeSpecFactory({
  group: "inline"
});
var textCodeInline = createPMNodeSpecFactory({
  group: "inline"
});
var textFormatted = createPMNodeSpecFactory({
  group: "inline"
});
var unsupportedBlock = createPMNodeSpecFactory({
  group: "block",
  atom: true,
  attrs: {
    originalValue: {
      default: {}
    }
  },
  selectable: true
});
var unsupportedInline = createPMNodeSpecFactory({
  group: "inline",
  inline: true,
  attrs: {
    originalValue: {
      default: {}
    }
  },
  selectable: true
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/expand.js
function getExpandAttrs(domNode) {
  var dom = domNode;
  return {
    title: dom.getAttribute("data-title"),
    __expanded: true
  };
}
var nodeSpecOptions = {
  parseDOM: [{
    context: "table//",
    tag: 'div[data-node-type="expand"]',
    getAttrs: getExpandAttrs
  }, {
    context: "expand//",
    tag: '[data-node-type="expand"]',
    skip: true
  }, {
    context: "nestedExpand//",
    tag: '[data-node-type="expand"]',
    skip: true
  }, {
    tag: '[data-node-type="nestedExpand"] button',
    ignore: true
  }, {
    tag: '[data-node-type="expand"] button',
    ignore: true
  }, {
    tag: 'div[data-node-type="expand"]',
    getAttrs: getExpandAttrs
  }],
  toDOM: function toDOM(node) {
    var attrs10 = {
      "data-node-type": "expand",
      "data-title": node.attrs.title,
      "data-expanded": node.attrs.__expanded
    };
    return ["div", attrs10, 0];
  }
};
var expand2 = expandWithoutNestedExpand(nodeSpecOptions);
var expandWithNestedExpand = expand(nodeSpecOptions);

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/confluence-jira-issue.js
var name = "confluenceJiraIssue";
var confluenceJiraIssue2 = confluenceJiraIssue({
  parseDOM: [{
    tag: 'span[data-node-type="'.concat(name, '"]'),
    getAttrs: function getAttrs(domNode) {
      var dom = domNode;
      return {
        issueKey: dom.textContent,
        macroId: dom.dataset && dom.dataset.macroId,
        schemaVersion: dom.dataset && dom.dataset.schemaVersion,
        server: dom.dataset && dom.dataset.server,
        serverId: dom.dataset && dom.dataset.serverId
      };
    }
  }],
  toDOM: function toDOM2(node) {
    var attrs10 = {
      "data-node-type": name,
      "data-macro-id": node.attrs.macroId,
      "data-schema-version": node.attrs.schemaVersion,
      "data-server": node.attrs.server,
      "data-server-id": node.attrs.serverId,
      "data-jira-issue": node.attrs.issueKey
    };
    return ["span", attrs10, node.attrs.issueKey];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/confluence-unsupported-block.js
var name2 = "confluenceUnsupportedBlock";
var confluenceUnsupportedBlock2 = confluenceUnsupportedBlock({
  toDOM: function toDOM3(node) {
    var attrs10 = {
      "data-node-type": name2,
      "data-confluence-unsupported": "block",
      "data-confluence-unsupported-block-cxhtml": node.attrs["cxhtml"]
    };
    return ["div", attrs10, "Unsupported content"];
  },
  parseDOM: [{
    tag: 'div[data-node-type="'.concat(name2, '"]'),
    getAttrs: function getAttrs2(dom) {
      return {
        cxhtml: dom.getAttribute("data-confluence-unsupported-block-cxhtml")
      };
    }
  }]
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/confluence-unsupported-inline.js
var name3 = "confluenceUnsupportedInline";
var confluenceUnsupportedInline2 = confluenceUnsupportedInline({
  toDOM: function toDOM4(node) {
    var attrs10 = {
      "data-node-type": name3,
      "data-confluence-unsupported": "inline",
      "data-confluence-unsupported-inline-cxhtml": node.attrs["cxhtml"]
    };
    return ["div", attrs10, "Unsupported content"];
  },
  parseDOM: [{
    tag: 'div[data-node-type="'.concat(name3, '"]'),
    getAttrs: function getAttrs3(dom) {
      return {
        cxhtml: dom.getAttribute("data-confluence-unsupported-inline-cxhtml")
      };
    }
  }]
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/doc.js
var doc2 = doc({});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/blockquote.js
var nodeSpecOptions2 = {
  parseDOM: [{
    tag: "blockquote"
  }],
  toDOM: function toDOM5() {
    return ["blockquote", 0];
  }
};
var blockquote2 = blockquoteLegacy(nodeSpecOptions2);
var blockquoteWithNestedCodeblockOrMedia = blockquote(nodeSpecOptions2);
var blockquoteWithList = blockquoteWithoutNestedCodeblockOrMedia({
  parseDOM: [{
    tag: "blockquote"
  }],
  toDOM: function toDOM6() {
    return ["blockquote", 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/bullet-list.js
var bulletListSelector = ".ak-ul";
var bulletList2 = bulletList({
  parseDOM: [{
    tag: "ul"
  }],
  toDOM: function toDOM7() {
    var attrs10 = {
      class: bulletListSelector.substr(1)
    };
    return ["ul", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/code-block.js
var getLanguageFromEditorStyle = function getLanguageFromEditorStyle2(dom) {
  return dom.getAttribute("data-language") || void 0;
};
var getLanguageFromBitbucketStyle = function getLanguageFromBitbucketStyle2(dom) {
  if (dom && dom.classList.contains("codehilite")) {
    return extractLanguageFromClass(dom.className);
  }
  return;
};
var getLanguageFromCode = function getLanguageFromCode2(dom) {
  var firstChild = dom.firstElementChild;
  if (firstChild && firstChild.nodeName === "CODE") {
    return firstChild.getAttribute("data-language") || void 0;
  }
};
var extractLanguageFromClass = function extractLanguageFromClass2(className) {
  var languageRegex = /(?:^|\s)language-([^\s]+)/;
  var result = languageRegex.exec(className);
  if (result && result[1]) {
    return result[1];
  }
  return;
};
var removeLastNewLine = function removeLastNewLine2(dom) {
  var parent = dom && dom.parentElement;
  if (parent && parent.classList.contains("codehilite")) {
    dom.textContent = dom.textContent.replace(/\n$/, "");
  }
  return dom;
};
function parseCodeFromHtml(node) {
  var code4 = "";
  node.childNodes.forEach(function(child) {
    if (child.nodeType === Node.TEXT_NODE) {
      code4 += child.nodeValue;
    } else if (child.nodeType === Node.ELEMENT_NODE && child instanceof Element) {
      var tagName = child.tagName.toLowerCase();
      if (tagName === "div" || tagName === "p") {
        if (child.previousElementSibling !== null) {
          code4 += "\n";
        }
      }
      if (tagName === "br") {
        code4 += "\n";
      } else {
        code4 += parseCodeFromHtml(child);
      }
    }
  });
  return code4;
}
var codeBlock2 = codeBlock({
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: function getAttrs4(domNode) {
        var dom = domNode;
        var language = getLanguageFromBitbucketStyle(dom.parentElement) || getLanguageFromEditorStyle(dom.parentElement) || getLanguageFromCode(dom) || dom.getAttribute("data-language");
        dom = removeLastNewLine(dom);
        return {
          language
        };
      }
    },
    // Handle VSCode, Android Studio paste
    // Checking `white-space: pre-wrap` is too aggressive @see ED-2627
    {
      tag: "div[style]",
      preserveWhitespace: "full",
      getAttrs: function getAttrs5(domNode) {
        var dom = domNode;
        if (dom.style.whiteSpace === "pre" || dom.style.fontFamily && dom.style.fontFamily.toLowerCase().indexOf("monospace") > -1) {
          return {};
        }
        return false;
      },
      getContent: function getContent(domNode, schema2) {
        if (getBooleanFF("platform.editor.codeblock.parsedom-divstyle-improve_5ib4n")) {
          var _code = parseCodeFromHtml(domNode);
          return _code ? Fragment.from(schema2.text(_code)) : Fragment.empty;
        }
        var dom = domNode;
        var code4 = Array.from(dom.children).map(function(child) {
          return child.textContent;
        }).filter(function(x) {
          return x !== void 0;
        }).join("\n");
        return code4 ? Fragment.from(schema2.text(code4)) : Fragment.empty;
      }
    },
    // Handle GitHub/Gist paste
    {
      tag: "table[style]",
      preserveWhitespace: "full",
      getAttrs: function getAttrs6(dom) {
        if (dom.querySelector('td[class*="blob-code"]')) {
          return {};
        }
        return false;
      }
    },
    {
      tag: "div.code-block",
      preserveWhitespace: "full",
      getAttrs: function getAttrs7(domNode) {
        var dom = domNode;
        var lineNumber = dom.querySelectorAll(".react-syntax-highlighter-line-number");
        if (lineNumber.length > 0) {
          lineNumber.forEach(function(line) {
            return line.remove();
          });
        }
        return {};
      }
    }
  ],
  toDOM: function toDOM8(node) {
    return ["pre", ["code", {
      "data-language": node.attrs.language
    }, 0]];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/hard-break.js
var hardBreak2 = hardBreak({
  parseDOM: [{
    tag: "br"
  }],
  toDOM: function toDOM9() {
    return ["br"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/heading.js
var getAttrs8 = function getAttrs9(level) {
  return function(domNode) {
    var _heading$attrs, _heading$attrs$localI;
    return {
      level,
      localId: domNode.getAttribute("data-local-id") || ((_heading$attrs = heading2.attrs) === null || _heading$attrs === void 0 ? void 0 : (_heading$attrs$localI = _heading$attrs.localId) === null || _heading$attrs$localI === void 0 ? void 0 : _heading$attrs$localI.default)
    };
  };
};
var heading2 = heading({
  parseDOM: [{
    tag: "h1",
    getAttrs: getAttrs8(1)
  }, {
    tag: "h2",
    getAttrs: getAttrs8(2)
  }, {
    tag: "h3",
    getAttrs: getAttrs8(3)
  }, {
    tag: "h4",
    getAttrs: getAttrs8(4)
  }, {
    tag: "h5",
    getAttrs: getAttrs8(5)
  }, {
    tag: "h6",
    getAttrs: getAttrs8(6)
  }],
  toDOM: function toDOM10(node) {
    var _node$attrs = node.attrs, level = _node$attrs.level, localId = _node$attrs.localId;
    var name7 = "h" + level;
    var attrs10 = localId !== void 0 && localId !== null ? [{
      "data-local-id": localId
    }] : [];
    return [name7].concat(attrs10, [0]);
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/rule.js
var hrDOM = ["hr"];
var rule2 = rule({
  parseDOM: [{
    tag: "hr"
  }],
  toDOM: function toDOM11() {
    return hrDOM;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/ordered-list.js
var orderedListSelector = ".ak-ol";
var orderedList2 = orderedList({
  parseDOM: [{
    tag: "ol"
  }],
  toDOM: function toDOM12() {
    var attrs10 = {
      class: orderedListSelector.substr(1)
    };
    return ["ol", attrs10, 0];
  }
});
var resolveStart = function resolveStart2(start) {
  var num = Number(start);
  if (Number.isNaN(num)) {
    return;
  }
  if (num < 0) {
    return;
  }
  return Math.floor(Math.max(num, 0));
};
var orderedListWithOrder = orderedList({
  parseDOM: [{
    tag: "ol",
    getAttrs: function getAttrs10(domNode) {
      var dom = domNode;
      var startDOMAttr = dom.getAttribute("start");
      if (startDOMAttr) {
        var start = resolveStart(startDOMAttr);
        if (typeof start === "number") {
          return {
            order: start
          };
        }
      }
      return null;
    }
  }],
  toDOM: function toDOM13(node) {
    var _node$attrs;
    var start = resolveStart(node === null || node === void 0 ? void 0 : (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.order);
    var attrs10 = {
      start: typeof start === "number" ? String(start) : void 0,
      class: orderedListSelector.substr(1)
    };
    return ["ol", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/paragraph.js
var paragraph2 = paragraph({
  parseDOM: [{
    tag: "p",
    getAttrs: function getAttrs11(domNode) {
      var _paragraph$attrs, _paragraph$attrs$loca;
      var dom = domNode;
      var attrs10 = {
        localId: dom.getAttribute("data-local-id") || ((_paragraph$attrs = paragraph2.attrs) === null || _paragraph$attrs === void 0 ? void 0 : (_paragraph$attrs$loca = _paragraph$attrs.localId) === null || _paragraph$attrs$loca === void 0 ? void 0 : _paragraph$attrs$loca.default)
      };
      return attrs10;
    }
  }],
  toDOM: function toDOM14(node) {
    var localId = node.attrs.localId;
    var name7 = "p";
    var attrs10 = localId !== void 0 && localId !== null ? [{
      "data-local-id": localId
    }] : [];
    return [name7].concat(attrs10, [0]);
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/confluence/emoji.js
var DEFAULT_EMOJI_ID = "2b50";
var HC_EMOTICON_PREFIX = "atlassian-";
var acNameToEmojiMap = {
  smile: ["1f642", ":slight_smile:", "ğŸ™‚"],
  sad: ["1f641", ":slight_frown:", "ğŸ™"],
  cheeky: ["1f61b", ":stuck_out_tongue:", "ğŸ˜›"],
  laugh: ["1f600", ":grinning:", "ğŸ˜€"],
  wink: ["1f609", ":wink:", "ğŸ˜‰"],
  information: ["2139", ":information_source:", "â„¹"],
  tick: ["2705", ":white_check_mark:", "âœ…"],
  cross: ["274c", ":x:", "âŒ"],
  warning: ["26a0", ":warning:", "âš "],
  plus: ["2795", ":heavy_plus_sign:", "â•"],
  minus: ["2796", ":heavy_minus_sign:", "â–"],
  question: ["2753", ":question:", "?"],
  "thumbs-up": ["1f44d", ":thumbsup:", "ğŸ‘"],
  "thumbs-down": ["1f44e", ":thumbsdown:", "ğŸ‘"],
  "light-on": ["1f4a1", ":bulb:", "ğŸ’¡"],
  "yellow-star": ["2b50", ":star:", "ğŸ’›"],
  "light-off": ["1f6ab", ":no_entry_sign:", "ğŸš«"],
  "red-star": ["2764", ":heart:", "â¤ï¸"],
  "green-star": ["1f49a", ":green_heart:", "ğŸ’š"],
  "blue-star": ["1f499", ":blue_heart:", "ğŸ’™"],
  heart: ["2764", ":heart:", "â¤ï¸"],
  "broken-heart": ["1f494", ":broken_heart:", "ğŸ’”"]
};
function acNameToEmoji(acName) {
  var emojiData = acNameToEmojiMap[acName];
  return emojiData ? {
    id: emojiData[0],
    shortName: emojiData[1],
    text: emojiData[2]
  } : {
    id: DEFAULT_EMOJI_ID,
    shortName: ":".concat(acName, ":"),
    text: ""
  };
}
function acShortcutToEmoji(hipchatEmoticonShortName) {
  return {
    id: "".concat(HC_EMOTICON_PREFIX).concat(hipchatEmoticonShortName),
    shortName: ":".concat(hipchatEmoticonShortName, ":"),
    text: ""
  };
}

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/emoji.js
var emoji2 = emoji({
  parseDOM: [
    // Handle copy/paste beautiful panel from renderer />
    {
      tag: "div.ak-editor-panel__icon span",
      ignore: true
    },
    {
      tag: "span[data-emoji-short-name]",
      getAttrs: function getAttrs12(domNode) {
        var dom = domNode;
        return {
          shortName: dom.getAttribute("data-emoji-short-name") || emoji2.attrs.shortName.default,
          id: dom.getAttribute("data-emoji-id") || emoji2.attrs.id.default,
          text: dom.getAttribute("data-emoji-text") || emoji2.attrs.text.default
        };
      }
    },
    // Handle copy/paste from old <ac:emoticon />
    {
      tag: "img[data-emoticon-name]",
      getAttrs: function getAttrs13(dom) {
        return acNameToEmoji(dom.getAttribute("data-emoticon-name"));
      }
    },
    // Handle copy/paste from old <ac:hipchat-emoticons />
    {
      tag: "img[data-hipchat-emoticon]",
      getAttrs: function getAttrs14(dom) {
        return acShortcutToEmoji(dom.getAttribute("data-hipchat-emoticon"));
      }
    },
    // Handle copy/paste from bitbucket's <img class="emoji" />
    {
      tag: "img.emoji[data-emoji-short-name]",
      getAttrs: function getAttrs15(domNode) {
        var dom = domNode;
        return {
          shortName: dom.getAttribute("data-emoji-short-name") || emoji2.attrs.shortName.default,
          id: dom.getAttribute("data-emoji-id") || emoji2.attrs.id.default,
          text: dom.getAttribute("data-emoji-text") || emoji2.attrs.text.default
        };
      }
    }
  ],
  toDOM: function toDOM15(node) {
    var _node$attrs = node.attrs, shortName = _node$attrs.shortName, id = _node$attrs.id, text4 = _node$attrs.text;
    var attrs10 = {
      "data-emoji-short-name": shortName,
      "data-emoji-id": id,
      "data-emoji-text": text4,
      contenteditable: "false"
    };
    return ["span", attrs10, text4];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/image.js
var image2 = image({
  parseDOM: [{
    tag: 'img[src^="data:image/"]',
    ignore: true
  }, {
    tag: "img[src]",
    getAttrs: function getAttrs16(domNode) {
      var dom = domNode;
      return {
        src: dom.getAttribute("src"),
        alt: dom.getAttribute("alt"),
        title: dom.getAttribute("title")
      };
    }
  }],
  toDOM: function toDOM16(node) {
    return ["img", node.attrs];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/uuid.js
var generateUuid = function generateUuid2() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    return (c === "x" ? r : r & 3 | 8).toString(16);
  });
};
var staticValue = false;
var uuid = {
  setStatic: function setStatic(value) {
    staticValue = value;
  },
  generate: function generate() {
    return staticValue || generateUuid();
  }
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/colors.js
var R50 = "#FFEBE6";
var R75 = "#FFBDAD";
var R100 = "#FF8F73";
var R300 = "#FF5630";
var R500 = "#BF2600";
var Y50 = "#FFFAE6";
var Y75 = "#FFF0B3";
var Y200 = "#FFC400";
var Y400 = "#FF991F";
var G50 = "#E3FCEF";
var G75 = "#ABF5D1";
var G200 = "#57D9A3";
var G300 = "#36B37E";
var G500 = "#006644";
var B50 = "#DEEBFF";
var B75 = "#B3D4FF";
var B100 = "#4C9AFF";
var B400 = "#0052CC";
var B500 = "#0747A6";
var L200 = "#D3F1A7";
var N0 = "#FFFFFF";
var N20 = "#F4F5F7";
var N30 = "#EBECF0";
var N60 = "#B3BAC5";
var N80 = "#97A0AF";
var Neutral300 = "#DCDFE4";
var N300A = "#091E4224";
var N600 = "#758195";
var N800 = "#172B4D";
var N1000 = "#172B4D";
var M200 = "#FDD0EC";
var O200 = "#FEDEC8";
var P50 = "#EAE6FF";
var P75 = "#C0B6F2";
var P100 = "#998DD9";
var P200 = "#DFD8FD";
var P300 = "#6554C0";
var P500 = "#403294";
var T50 = "#E6FCFF";
var T75 = "#B3F5FF";
var T100 = "#79E2F2";
var T200 = "#C6EDFB";
var T300 = "#00B8D9";
var T500 = "#008DA6";
function normalizeHexColor(color, defaultColor) {
  if (!color) {
    return null;
  }
  color = color.trim().toLowerCase();
  if (isHex(color)) {
    if (color.length === 4) {
      color = color.split("").map(function(c) {
        return c === "#" ? "#" : "".concat(c).concat(c);
      }).join("");
    }
  } else if (isRgb(color)) {
    return rgbToHex(color);
  } else {
    if (color === "default") {
      return null;
    } else if (css_color_names_default && css_color_names_default[color]) {
      color = css_color_names_default[color];
    } else if (css_color_names_exports && css_color_names_exports[color]) {
      color = css_color_names_exports[color];
    } else {
      return null;
    }
  }
  if (color === defaultColor) {
    return null;
  }
  return color;
}
function hexToRgba(rawColor, alpha) {
  var color = normalizeHexColor(rawColor);
  if (!color) {
    return null;
  }
  var hex2rgb = function hex2rgb2(color2) {
    return color2.match(/[a-z0-9]{2}/gi).map(function(hex) {
      return parseInt(hex, 16);
    });
  };
  return "rgba(".concat(hex2rgb(color).concat(alpha).join(","), ")");
}
function rgbToHex(value) {
  var matches = value.match(/(0?\.?\d{1,3})%?\b/g);
  if (matches && matches.length >= 3) {
    var _matches$map = matches.map(Number), _matches$map2 = _slicedToArray(_matches$map, 3), red = _matches$map2[0], green = _matches$map2[1], blue = _matches$map2[2];
    return "#" + (blue | green << 8 | red << 16 | 1 << 24).toString(16).slice(1);
  }
  return null;
}
function isRgb(color) {
  return /rgba?\(/.test(color);
}
function isHex(color) {
  return /^#([A-Fa-f0-9]{3}){1,2}$/.test(color);
}

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/url.js
var import_linkify_it = __toESM(require_linkify_it());
var whitelistedURLPatterns = [
  /^https?:\/\//im,
  /^ftps?:\/\//im,
  /^gopher:\/\//im,
  /^integrity:\/\//im,
  /^file:\/\//im,
  /^smb:\/\//im,
  /^dynamicsnav:\/\//im,
  /^jamfselfservice:\/\//im,
  /^\//im,
  /^mailto:/im,
  /^skype:/im,
  /^callto:/im,
  /^facetime:/im,
  /^git:/im,
  /^irc6?:/im,
  /^news:/im,
  /^nntp:/im,
  /^feed:/im,
  /^cvs:/im,
  /^svn:/im,
  /^mvn:/im,
  /^ssh:/im,
  /^scp:\/\//im,
  /^sftp:\/\//im,
  /^itms:/im,
  // This is not a valid notes link, but we support this pattern for backwards compatibility
  /^notes:/im,
  /^notes:\/\//im,
  /^hipchat:\/\//im,
  // This is not a valid sourcetree link, but we support this pattern for backwards compatibility
  /^sourcetree:/im,
  /^sourcetree:\/\//im,
  /^urn:/im,
  /^tel:/im,
  /^xmpp:/im,
  /^telnet:/im,
  /^vnc:/im,
  /^rdp:/im,
  /^whatsapp:/im,
  /^slack:/im,
  /^sips?:/im,
  /^magnet:/im,
  /^#/im
];
var isSafeUrl = function isSafeUrl2(url) {
  var urlTrimmed = url.trim();
  if (urlTrimmed.length === 0) {
    return true;
  }
  return whitelistedURLPatterns.some(function(p) {
    return p.test(urlTrimmed);
  });
};
var linkify = (0, import_linkify_it.default)();
linkify.add("sourcetree:", "http:");
linkify.add("jamfselfservice:", "http:");
var urlWithoutSpacesValidator = {
  validate: /[^\s]+/
};
linkify.add("tel:", urlWithoutSpacesValidator);
linkify.add("file:", urlWithoutSpacesValidator);
linkify.add("notes:", "http:");
var tlds = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
var tlds2Char = "a[cdefgilmnoqrtuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrtuvwxyz]|n[acefgilopruz]|om|p[aefghkmnrtw]|qa|r[eosuw]|s[abcdegijklmnrtuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
tlds.push(tlds2Char);
linkify.tlds(tlds, false);
var LINK_REGEXP = /(https?|ftp|jamfselfservice|gopher|dynamicsnav|integrity|file|smb):\/\/[^\s]+/;
var linkifyMatch = function linkifyMatch2(text4) {
  if (!LINK_REGEXP.test(text4)) {
    return [];
  }
  var matches = [];
  var startpos = 0;
  var substr;
  while (substr = text4.substr(startpos)) {
    var link4 = (substr.match(LINK_REGEXP) || [""])[0];
    if (link4) {
      var index = substr.search(LINK_REGEXP);
      var start = index >= 0 ? index + startpos : index;
      var end = start + link4.length;
      matches.push({
        index: start,
        lastIndex: end,
        raw: link4,
        url: link4,
        text: link4,
        schema: ""
      });
      startpos += end;
    } else {
      break;
    }
  }
  return matches;
};
function getLinkMatch(str) {
  if (!str) {
    return null;
  }
  var match2 = linkifyMatch(str);
  if (!match2.length) {
    match2 = linkify.match(str);
  }
  return match2 && match2[0];
}
function normalizeUrl(url) {
  var match2 = getLinkMatch(url);
  return match2 && match2.url || "";
}
function isRootRelative(url) {
  return url.startsWith("/");
}

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/lch-color-inversion.js
var clamp = function clamp2(i, min, max) {
  return Math.round(Math.min(Math.max(i, min), max));
};
var expandShorthandHex = function expandShorthandHex2(input) {
  return input.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
    return r + r + g + g + b + b;
  });
};
var rgbFromHex = function rgbFromHex2(input) {
  var fullHex = expandShorthandHex(input);
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHex);
  return result === null ? null : {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  };
};
var rgbToHex2 = function rgbToHex3(_ref) {
  var r = _ref.r, g = _ref.g, b = _ref.b;
  var convertComponent = function convertComponent2(c) {
    var cBase16 = c.toString(16);
    return cBase16.length === 1 ? "0".concat(cBase16) : cBase16;
  };
  return "#".concat(convertComponent(r)).concat(convertComponent(g)).concat(convertComponent(b));
};
var rgbToXyz = function rgbToXyz2(rgb) {
  var convertRgbComponent = function convertRgbComponent2(c) {
    return c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92;
  };
  var convertXyzComponent = function convertXyzComponent2(c) {
    return c > 8856452e-9 ? Math.pow(c, 1 / 3) : c / 0.12841855 + 0.137931034;
  };
  var r = convertRgbComponent(rgb.r / 255);
  var g = convertRgbComponent(rgb.g / 255);
  var b = convertRgbComponent(rgb.b / 255);
  return {
    x: convertXyzComponent((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / 0.95047),
    y: convertXyzComponent(0.2126729 * r + 0.7151522 * g + 0.072175 * b),
    z: convertXyzComponent((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / 1.08883)
  };
};
var xyzToLab = function xyzToLab2(_ref2) {
  var x = _ref2.x, y = _ref2.y, z = _ref2.z;
  return {
    l: Math.max(116 * y - 16, 0),
    a: 500 * (x - y),
    b: 200 * (y - z)
  };
};
var labToLch = function labToLch2(_ref3) {
  var l = _ref3.l, a = _ref3.a, b = _ref3.b;
  var h = (Math.atan2(b, a) * (180 / Math.PI) + 360) % 360;
  var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
  if (Math.round(c * 1e4) === 0)
    h = Number.NaN;
  return {
    l,
    c,
    h
  };
};
var lchToLab = function lchToLab2(_ref4) {
  var l = _ref4.l, c = _ref4.c, h = _ref4.h;
  var convertH = Number.isNaN(h) ? 0 : h * (Math.PI / 180);
  return {
    l,
    a: Math.cos(convertH) * c,
    b: Math.sin(convertH) * c
  };
};
var labToXyz = function labToXyz2(_ref5) {
  var l = _ref5.l, a = _ref5.a, b = _ref5.b;
  var convertComponent = function convertComponent2(c) {
    return c > 0.206896552 ? Math.pow(c, 3) : 0.12841855 * (c - 0.137931034);
  };
  var y = (l + 16) / 116;
  var x = a / 500 + y;
  var z = y - b / 200;
  return {
    x: convertComponent(x) * 0.95047,
    y: convertComponent(y),
    z: convertComponent(z) * 1.08883
  };
};
var xyzToRgb = function xyzToRgb2(_ref6) {
  var x = _ref6.x, y = _ref6.y, z = _ref6.z;
  var convertComponent = function convertComponent2(c) {
    return 255 * (c <= 304e-5 ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055);
  };
  return {
    r: clamp(convertComponent(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), 0, 255),
    g: clamp(convertComponent(-0.969266 * x + 1.8760108 * y + 0.041556 * z), 0, 255),
    b: clamp(convertComponent(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), 0, 255)
  };
};
var rgbToLch = function rgbToLch2(rgb) {
  return labToLch(xyzToLab(rgbToXyz(rgb)));
};
var lchToRgb = function lchToRgb2(lch) {
  return xyzToRgb(labToXyz(lchToLab(lch)));
};
var clampLightness = function clampLightness2(color, newPercent) {
  var rgb = rgbFromHex(color);
  if (rgb === null) {
    return color;
  }
  var lch = rgbToLch(rgb);
  lch.l = clamp(newPercent, 0, 100);
  return rgbToHex2(lchToRgb(lch));
};
var getLightness = function getLightness2(color) {
  var rgb = rgbFromHex(color);
  if (rgb === null) {
    return 0;
  }
  var lch = rgbToLch(rgb);
  return lch.l;
};
var getDarkModeLCHColor = function getDarkModeLCHColor2(currentBackgroundColor) {
  var lightness = getLightness(currentBackgroundColor);
  var newLightness = Math.abs(100 - lightness);
  return clampLightness(currentBackgroundColor, newLightness).toUpperCase();
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/mention.js
var USER_TYPES = function(USER_TYPES2) {
  USER_TYPES2["DEFAULT"] = "DEFAULT";
  USER_TYPES2["SPECIAL"] = "SPECIAL";
  USER_TYPES2["APP"] = "APP";
  return USER_TYPES2;
}({});
var mention2 = mention({
  parseDOM: [{
    tag: "span[data-mention-id]",
    getAttrs: function getAttrs17(domNode) {
      var dom = domNode;
      var attrs10 = {
        id: dom.getAttribute("data-mention-id") || mention2.attrs.id.default,
        text: dom.textContent || mention2.attrs.text.default,
        accessLevel: dom.getAttribute("data-access-level") || mention2.attrs.accessLevel.default,
        localId: uuid.generate()
      };
      var userType = dom.getAttribute("data-user-type");
      if (USER_TYPES[userType]) {
        attrs10.userType = userType;
      }
      return attrs10;
    }
  }],
  toDOM: function toDOM17(node) {
    var _node$attrs = node.attrs, id = _node$attrs.id, accessLevel = _node$attrs.accessLevel, text4 = _node$attrs.text, userType = _node$attrs.userType, localId = _node$attrs.localId;
    var attrs10 = {
      "data-mention-id": id,
      "data-access-level": accessLevel,
      contenteditable: "false"
    };
    if (localId) {
      attrs10["data-local-id"] = localId;
    }
    if (userType) {
      attrs10["data-user-type"] = userType;
    }
    return ["span", attrs10, text4];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/list-item.js
var listItem2 = listItemLegacy({
  parseDOM: [{
    tag: "li"
  }],
  toDOM: function toDOM18() {
    return ["li", 0];
  }
});
var listItemWithTask = listItem({
  parseDOM: [{
    tag: "li"
  }],
  toDOM: function toDOM19() {
    return ["li", 0];
  }
});
var listItemWithDecisionStage0 = listItemWithNestedDecisionStage0({
  parseDOM: [{
    tag: "li"
  }],
  toDOM: function toDOM20() {
    return ["li", 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/panel.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var PanelType = function(PanelType2) {
  PanelType2["INFO"] = "info";
  PanelType2["NOTE"] = "note";
  PanelType2["TIP"] = "tip";
  PanelType2["WARNING"] = "warning";
  PanelType2["ERROR"] = "error";
  PanelType2["SUCCESS"] = "success";
  PanelType2["CUSTOM"] = "custom";
  return PanelType2;
}({});
var getDomAttrs = function getDomAttrs2(nodeAttrs) {
  var attrs10 = {
    "data-panel-type": nodeAttrs.panelType,
    "data-panel-icon": nodeAttrs.panelIcon,
    "data-panel-icon-id": nodeAttrs.panelIconId,
    "data-panel-icon-text": nodeAttrs.panelIconText,
    "data-panel-color": nodeAttrs.panelColor
  };
  return attrs10;
};
var getParseDOMAttrs = function getParseDOMAttrs2(allowCustomPanel, dom) {
  var parseDOMAttrs = {
    panelType: dom.getAttribute("data-panel-type")
  };
  if (allowCustomPanel) {
    parseDOMAttrs = _objectSpread2(_objectSpread2({}, parseDOMAttrs), {}, {
      panelIcon: dom.getAttribute("data-panel-icon"),
      panelIconId: dom.getAttribute("data-panel-icon-id"),
      panelIconText: dom.getAttribute("data-panel-icon-text"),
      panelColor: dom.getAttribute("data-panel-color")
    });
  } else {
    parseDOMAttrs.panelType = parseDOMAttrs.panelType === PanelType.CUSTOM ? PanelType.INFO : parseDOMAttrs.panelType;
  }
  return parseDOMAttrs;
};
var extendedPanel = function extendedPanel2(allowCustomPanel) {
  var panelNodeSpec = panel({
    parseDOM: [{
      tag: "div[data-panel-type]",
      getAttrs: function getAttrs58(dom) {
        return getParseDOMAttrs(allowCustomPanel, dom);
      }
    }],
    toDOM: function toDOM69(node) {
      var attrs10 = getDomAttrs(node.attrs);
      var contentAttrs = {
        "data-panel-content": "true"
      };
      return ["div", attrs10, ["div", contentAttrs, 0]];
    }
  });
  return panelNodeSpec;
};
var panelWithBlockquoteStage0 = function panelWithBlockquoteStage02(allowCustomPanel) {
  var panelNodeSpec = panelWithNestedBlockquoteStage0({
    parseDOM: [{
      tag: "div[data-panel-type]",
      getAttrs: function getAttrs58(dom) {
        return getParseDOMAttrs(allowCustomPanel, dom);
      }
    }],
    toDOM: function toDOM69(node) {
      var attrs10 = getDomAttrs(node.attrs);
      var contentAttrs = {
        "data-panel-content": "true"
      };
      return ["div", attrs10, ["div", contentAttrs, 0]];
    }
  });
  return panelNodeSpec;
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/text.js
var text2 = text({
  toDebugString: true ? void 0 : function() {
    return "text_node";
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/unknown-block.js
var name4 = "unknownBlock";
var unknown_block_default = {
  group: "block",
  content: "inline+",
  marks: "_",
  toDOM: function toDOM21() {
    return ["div", {
      "data-node-type": name4
    }, 0];
  },
  parseDOM: [{
    tag: 'div[data-node-type="'.concat(name4, '"]')
  }]
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/caption.js
var caption2 = caption({
  parseDOM: [{
    tag: "figcaption[data-caption]"
  }],
  toDOM: function toDOM22() {
    var attrs10 = {
      "data-caption": "true"
    };
    return ["figcaption", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media.js
var defaultAttrs = media({}).attrs;
var createMediaSpec = function createMediaSpec2(attributes) {
  var inline2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var domNodeType = inline2 ? "span" : "div";
  var nodeName = inline2 ? "mediaInline" : "media";
  var parseDOM = [
    {
      tag: "".concat(domNodeType, '[data-node-type="').concat(nodeName, '"]'),
      getAttrs: function getAttrs58(dom) {
        var attrs10 = {};
        if (attributes) {
          Object.keys(attributes).forEach(function(k) {
            var key = camelCaseToKebabCase(k).replace(/^__/, "");
            var value = dom.getAttribute("data-".concat(key)) || "";
            if (value) {
              attrs10[k] = value;
            }
          });
        }
        if (attrs10.__fileSize) {
          attrs10.__fileSize = +attrs10.__fileSize;
        }
        var width = Number(attrs10.width);
        if (typeof width !== "undefined" && !isNaN(width)) {
          attrs10.width = width;
        }
        var height = Number(attrs10.height);
        if (typeof height !== "undefined" && !isNaN(height)) {
          attrs10.height = height;
        }
        return attrs10;
      }
    },
    // Don't match data URI
    {
      tag: 'img[src^="data:image"]',
      ignore: true
    }
  ];
  var toDOM69 = function toDOM70(node) {
    var attrs10 = {
      "data-id": node.attrs.id,
      "data-node-type": "".concat(nodeName),
      "data-type": node.attrs.type,
      "data-collection": node.attrs.collection,
      "data-occurrence-key": node.attrs.occurrenceKey,
      "data-width": node.attrs.width,
      "data-height": node.attrs.height,
      "data-url": node.attrs.url,
      "data-alt": node.attrs.alt,
      // toDOM is used for static rendering as well as editor rendering. This comes into play for
      // emails, copy/paste, etc, so the title and styling here *is* useful (despite a React-based
      // node view being used for editing).
      title: "Attachment",
      // Manually kept in sync with the style of media cards. The goal is to render a plain gray
      // rectangle that provides an affordance for media.
      style: "display: inline-block; border-radius: 3px; background: ".concat(N30, "; box-shadow: 0 1px 1px rgba(9, 30, 66, 0.2), 0 0 1px 0 rgba(9, 30, 66, 0.24);")
    };
    copyPrivateAttributes(node.attrs, attrs10, function(key) {
      return "data-".concat(camelCaseToKebabCase(key.slice(2)));
    });
    return ["".concat(domNodeType), attrs10];
  };
  if (inline2) {
    return mediaInline({
      parseDOM,
      toDOM: toDOM69
    });
  }
  return media({
    parseDOM: [].concat(parseDOM, [{
      // media-inline.ts uses this same function to generate the nodespec
      // this ensures that we don't make a media inline out of a copied image
      // https://product-fabric.atlassian.net/browse/EDM-2996
      tag: "img:not(.smart-link-icon)",
      getAttrs: function getAttrs58(dom) {
        return {
          type: "external",
          url: dom.getAttribute("src") || "",
          alt: dom.getAttribute("alt") || ""
        };
      }
    }]),
    toDOM: toDOM69
  });
};
var media2 = createMediaSpec(defaultAttrs, false);
var camelCaseToKebabCase = function camelCaseToKebabCase2(str) {
  return str.replace(/([^A-Z]+)([A-Z])/g, function(_, x, y) {
    return "".concat(x, "-").concat(y.toLowerCase());
  });
};
var copyPrivateAttributes = function copyPrivateAttributes2(from, to, map3) {
  if (media2.attrs) {
    Object.keys(media2.attrs).forEach(function(key) {
      if (key[0] === "_" && key[1] === "_" && from[key]) {
        to[map3 ? map3(key) : key] = from[key];
      }
    });
  }
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media-group.js
var mediaGroup2 = mediaGroup({
  parseDOM: [{
    tag: 'div[data-node-type="mediaGroup"]'
  }, {
    tag: 'div[class="MediaGroup"]'
  }],
  toDOM: function toDOM23() {
    return ["div", {
      "data-node-type": "mediaGroup"
    }, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media-inline.js
var mediaInline2 = createMediaSpec(mediaInline({}).attrs, true);

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/types/rich-media-common.js
var WidthType = function(WidthType2) {
  WidthType2["PIXEL"] = "pixel";
  WidthType2["PERCENTAGE"] = "percentage";
  return WidthType2;
}({});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/parseDOM.js
var isDOMElement = function isDOMElement2(maybeNode) {
  return maybeNode instanceof Node && maybeNode.nodeType === Node.ELEMENT_NODE;
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/media-single.js
function ownKeys3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var mediaSingleSpec = function mediaSingleSpec2(_ref) {
  var _ref$withCaption = _ref.withCaption, withCaption = _ref$withCaption === void 0 ? false : _ref$withCaption, _ref$withExtendedWidt = _ref.withExtendedWidthTypes, withExtendedWidthTypes = _ref$withExtendedWidt === void 0 ? false : _ref$withExtendedWidt;
  var getAttrs58 = function getAttrs59(dom) {
    if (!isDOMElement(dom)) {
      return {
        layout: "center"
      };
    }
    var layout = dom.getAttribute("data-layout") || "center";
    var width = Number(dom.getAttribute("data-width")) || null;
    var widthType = dom.getAttribute("data-width-type");
    if (withExtendedWidthTypes) {
      return {
        layout,
        width,
        widthType
      };
    } else if (widthType === WidthType.PIXEL) {
      return {
        layout
      };
    } else {
      return {
        layout,
        width
      };
    }
  };
  var getAttrsFromNode = function getAttrsFromNode2(node) {
    var _node$attrs = node.attrs, layout = _node$attrs.layout, width = _node$attrs.width;
    var attrs10 = {
      "data-node-type": "mediaSingle",
      "data-layout": layout,
      "data-width": ""
    };
    if (width) {
      attrs10["data-width"] = isFinite(width) && Math.floor(width) === width ? width : width.toFixed(2);
    }
    if (withExtendedWidthTypes && node.attrs.widthType) {
      var widthType = node.attrs.widthType;
      return _objectSpread3(_objectSpread3({}, attrs10), {}, {
        "data-width-type": widthType || WidthType.PERCENTAGE
      });
    }
    return attrs10;
  };
  if (withExtendedWidthTypes && withCaption) {
    return mediaSingleFull({
      parseDOM: [{
        tag: 'div[data-node-type="mediaSingle"]',
        getAttrs: getAttrs58
      }],
      toDOM: function toDOM69(node) {
        return ["div", getAttrsFromNode(node), 0];
      }
    });
  }
  if (withExtendedWidthTypes && !withCaption) {
    return mediaSingleWidthType({
      parseDOM: [{
        tag: 'div[data-node-type="mediaSingle"]',
        getAttrs: getAttrs58
      }],
      toDOM: function toDOM69(node) {
        return ["div", getAttrsFromNode(node), 0];
      }
    });
  }
  if (!withExtendedWidthTypes && withCaption) {
    return mediaSingleCaption({
      parseDOM: [{
        tag: 'div[data-node-type="mediaSingle"]',
        getAttrs: getAttrs58
      }],
      toDOM: function toDOM69(node) {
        return ["div", getAttrsFromNode(node), 0];
      }
    });
  }
  return mediaSingle({
    parseDOM: [{
      tag: 'div[data-node-type="mediaSingle"]',
      getAttrs: getAttrs58
    }],
    toDOM: function toDOM69(node) {
      return ["div", getAttrsFromNode(node), 0];
    }
  });
};
var mediaSingle2 = mediaSingleSpec({
  withCaption: false,
  withExtendedWidthTypes: false
});
var mediaSingleWithCaption = mediaSingleSpec({
  withCaption: true,
  withExtendedWidthTypes: false
});
var mediaSingleWithWidthType = mediaSingleSpec({
  withCaption: false,
  withExtendedWidthTypes: true
});
var mediaSingleFull2 = mediaSingleSpec({
  withCaption: true,
  withExtendedWidthTypes: true
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/editor-palette.js
function hexToEditorBorderPaletteColor(hexColor) {
  return editorBorderPalette[hexColor.toUpperCase()];
}
var editorBorderPalette = {
  /** gray - subtle */
  "#091E4224": "var(--ds-border, #091E4224)",
  /** gray */
  "#758195": "var(--ds-border-bold, #758195)",
  /** gray - bold */
  "#172B4D": "var(--ds-text, #172B4D)"
};
function hexToEditorTextPaletteColor(hexColor) {
  return editorTextPalette[hexColor.toUpperCase()];
}
var editorTextPalette = {
  /** blue - light */
  "#B3D4FF": "var(--ds-background-accent-blue-subtler, #B3D4FF)",
  /** blue - medium */
  "#4C9AFF": "var(--ds-icon-accent-blue, #4C9AFF)",
  /** blue - strong */
  "#0747A6": "var(--ds-text-accent-blue, #0747A6)",
  /** teal - light */
  "#B3F5FF": "var(--ds-background-accent-teal-subtler, #B3F5FF)",
  /** teal - medium */
  "#00B8D9": "var(--ds-icon-accent-teal, #00B8D9)",
  /** teal - strong */
  "#008DA6": "var(--ds-text-accent-teal, #008DA6)",
  /** green - light */
  "#ABF5D1": "var(--ds-background-accent-green-subtler, #ABF5D1)",
  /** green - medium */
  "#36B37E": "var(--ds-icon-accent-green, #36B37E)",
  /** green - strong */
  "#006644": "var(--ds-text-accent-green, #006644)",
  /** yellowOrange - light */
  "#FFF0B3": "var(--ds-background-accent-yellow-subtler, #FFF0B3)",
  /** yellowOrange - medium */
  "#FFC400": "var(--ds-background-accent-orange-subtle, #FFC400)",
  /** yellowOrange - strong */
  "#FF991F": "var(--ds-icon-accent-orange, #FF991F)",
  /** red - light */
  "#FFBDAD": "var(--ds-background-accent-red-subtler, #FFBDAD)",
  /** red - medium */
  "#FF5630": "var(--ds-icon-accent-red, #FF5630)",
  /** red - strong */
  "#BF2600": "var(--ds-text-accent-red, #BF2600)",
  /** purple - light */
  "#EAE6FF": "var(--ds-background-accent-purple-subtler, #EAE6FF)",
  /** purple - medium */
  "#6554C0": "var(--ds-icon-accent-purple, #6554C0)",
  /** purple - strong */
  "#403294": "var(--ds-text-accent-purple, #403294)",
  /** whiteGray - light */
  "#FFFFFF": "var(--ds-text-inverse, #FFFFFF)",
  /** whiteGray - medium */
  "#97A0AF": "var(--ds-icon-accent-gray, #97A0AF)",
  /** whiteGray - strong */
  "#172B4D": "var(--ds-text, #172B4D)"
};
function hexToEditorTextBackgroundPaletteColor(hexColor) {
  return textBackgroundColorPalette[hexColor.toUpperCase()];
}
var textBackgroundColorPalette = {
  /** Gray - light */
  "#DCDFE4": "var(--ds-background-accent-gray-subtler, #DCDFE4)",
  /** Teal - light */
  "#C6EDFB": "var(--ds-background-accent-teal-subtler, #C6EDFB)",
  /** Lime - light */
  "#D3F1A7": "var(--ds-background-accent-lime-subtler, #D3F1A7)",
  /** Orange - light */
  "#FEDEC8": "var(--ds-background-accent-orange-subtler, #FEDEC8)",
  /** Magenta - light */
  "#FDD0EC": "var(--ds-background-accent-magenta-subtler, #FDD0EC)",
  /** Purple - light */
  "#DFD8FD": "var(--ds-background-accent-purple-subtler, #DFD8FD)"
};
function hexToEditorBackgroundPaletteRawValue(hexColor) {
  var tokenData = editorBackgroundPalette[hexColor.toUpperCase()];
  return tokenData ? tokenData.getValue(hexColor) : void 0;
}
var editorBackgroundPalette = {
  /** blue - light */
  "#DEEBFF": {
    getValue: function getValue() {
      return "#DEEBFF";
    },
    token: "var(--ds-background-accent-blue-subtlest, #DEEBFF)"
  },
  /** blue - medium */
  "#B3D4FF": {
    getValue: function getValue2() {
      return "#B3D4FF";
    },
    token: "var(--ds-background-accent-blue-subtler, #B3D4FF)"
  },
  /** blue - strong */
  "#4C9AFF": {
    getValue: function getValue3() {
      return "#4C9AFF";
    },
    token: "var(--ds-background-accent-blue-subtle, #4C9AFF)"
  },
  /** teal - light */
  "#E6FCFF": {
    getValue: function getValue4() {
      return "#E6FCFF";
    },
    token: "var(--ds-background-accent-teal-subtlest, #E6FCFF)"
  },
  /** teal - medium */
  "#B3F5FF": {
    getValue: function getValue5() {
      return "#B3F5FF";
    },
    token: "var(--ds-background-accent-teal-subtler, #B3F5FF)"
  },
  /** teal - strong */
  "#79E2F2": {
    getValue: function getValue6() {
      return "#79E2F2";
    },
    token: "var(--ds-background-accent-teal-subtle, #79E2F2)"
  },
  /** green - light */
  "#E3FCEF": {
    getValue: function getValue7() {
      return "#E3FCEF";
    },
    token: "var(--ds-background-accent-green-subtlest, #E3FCEF)"
  },
  /** green - medium */
  "#ABF5D1": {
    getValue: function getValue8() {
      return "#ABF5D1";
    },
    token: "var(--ds-background-accent-green-subtler, #ABF5D1)"
  },
  /** green - strong */
  "#57D9A3": {
    getValue: function getValue9() {
      return "#57D9A3";
    },
    token: "var(--ds-background-accent-green-subtle, #57D9A3)"
  },
  /** yellowOrange - light */
  "#FFFAE6": {
    getValue: function getValue10() {
      return "#FFFAE6";
    },
    token: "var(--ds-background-accent-yellow-subtlest, #FFFAE6)"
  },
  /** yellowOrange - medium */
  "#FFF0B3": {
    getValue: function getValue11() {
      return "#FFF0B3";
    },
    token: "var(--ds-background-accent-yellow-subtler, #FFF0B3)"
  },
  /** yellowOrange - strong */
  "#FFC400": {
    getValue: function getValue12() {
      return "#FFC400";
    },
    token: "var(--ds-background-accent-orange-subtle, #FFC400)"
  },
  /** red - light */
  "#FFEBE6": {
    getValue: function getValue13() {
      return "#FFEBE6";
    },
    token: "var(--ds-background-accent-red-subtlest, #FFEBE6)"
  },
  /** red - medium */
  "#FFBDAD": {
    getValue: function getValue14() {
      return "#FFBDAD";
    },
    token: "var(--ds-background-accent-red-subtler, #FFBDAD)"
  },
  /** red - strong */
  "#FF8F73": {
    getValue: function getValue15() {
      return "#FF8F73";
    },
    token: "var(--ds-background-accent-red-subtle, #FF8F73)"
  },
  /** purple - light */
  "#EAE6FF": {
    getValue: function getValue16() {
      return "#EAE6FF";
    },
    token: "var(--ds-background-accent-purple-subtlest, #EAE6FF)"
  },
  /** purple - medium */
  "#C0B6F2": {
    getValue: function getValue17() {
      return "#C0B6F2";
    },
    token: "var(--ds-background-accent-purple-subtler, #C0B6F2)"
  },
  /** purple - strong */
  "#998DD9": {
    getValue: function getValue18() {
      return "#998DD9";
    },
    token: "var(--ds-background-accent-purple-subtle, #998DD9)"
  },
  /** whiteGray - light */
  "#FFFFFF": {
    getValue: function getValue19() {
      return "#FFFFFF";
    },
    token: "var(--ds-surface, #FFFFFF)"
  },
  /** whiteGray - medium */
  "#F4F5F7": {
    getValue: function getValue20() {
      return "#F4F5F7";
    },
    token: "var(--ds-background-accent-gray-subtlest, #F4F5F7)"
  },
  /** whiteGray - strong */
  "#B3BAC5": {
    getValue: function getValue21() {
      return "#B3BAC5";
    },
    token: "var(--ds-background-accent-gray-subtle, #B3BAC5)"
  }
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/tableNodes.js
var tablePrefixSelector = "pm-table";
var tableCellSelector = "".concat(tablePrefixSelector, "-cell-content-wrap");
var tableHeaderSelector = "".concat(tablePrefixSelector, "-header-content-wrap");
var tableCellContentWrapperSelector = "".concat(tablePrefixSelector, "-cell-nodeview-wrapper");
var tableCellContentDomSelector = "".concat(tablePrefixSelector, "-cell-nodeview-content-dom");
var DEFAULT_TABLE_HEADER_CELL_BACKGROUND = N20.toLocaleLowerCase();
var getCellAttrs = function getCellAttrs2(dom) {
  var defaultValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var widthAttr = dom.getAttribute("data-colwidth");
  var width = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map(function(str) {
    return Number(str);
  }) : null;
  var colspan = Number(dom.getAttribute("colspan") || 1);
  var backgroundColor3 = dom.style.backgroundColor;
  var dataCellBackground = dom.getAttribute("data-cell-background");
  var dataCellBackgroundHexCode = dataCellBackground && isHex(dataCellBackground) ? dataCellBackground : void 0;
  if (backgroundColor3.includes("--ds-background-neutral")) {
    backgroundColor3 = "";
  } else {
    if (backgroundColor3 && isRgb(backgroundColor3)) {
      var result = rgbToHex(backgroundColor3);
      if (result !== null) {
        backgroundColor3 = result;
      }
    }
  }
  var backgroundHexCode = dataCellBackgroundHexCode || (backgroundColor3 && backgroundColor3 !== defaultValues["background"] ? backgroundColor3 : null);
  return {
    colspan,
    rowspan: Number(dom.getAttribute("rowspan") || 1),
    colwidth: width && width.length === colspan ? width : null,
    background: backgroundHexCode
  };
};
var testGlobalTheme;
var getGlobalTheme = function getGlobalTheme2() {
  if (testGlobalTheme) {
    return {
      colorMode: testGlobalTheme
    };
  }
  var element = document.documentElement;
  var colorMode = element.getAttribute("data-color-mode") || "";
  return {
    colorMode
  };
};
var cssVariablePattern = /^var\(--.*\)$/;
var getCellDomAttrs = function getCellDomAttrs2(node) {
  var attrs10 = {};
  var nodeType = node.type.name;
  if (node.attrs.colspan !== 1) {
    attrs10.colspan = node.attrs.colspan;
  }
  if (node.attrs.rowspan !== 1) {
    attrs10.rowspan = node.attrs.rowspan;
  }
  if (node.attrs.colwidth) {
    attrs10["data-colwidth"] = node.attrs.colwidth.join(",");
  }
  if (node.attrs.background) {
    var background = node.attrs.background;
    var ignored = nodeType === "tableHeader" && background === tableBackgroundColorNames.get("light gray") || nodeType === "tableCell" && background === tableBackgroundColorNames.get("white") || nodeType === "tableHeader" && background.includes("--ds-background-neutral");
    if (ignored) {
      attrs10.style = "";
    } else {
      var color = isRgb(background) && rgbToHex(background) ? rgbToHex(background) : background;
      var tokenColor = hexToEditorBackgroundPaletteRawValue(color);
      if (tokenColor) {
        attrs10.style = "background-color: ".concat(tokenColor, ";");
      } else if (
        /**
         * There was previously a bug in dark mode where we would attempt to invert
         * a design token in `getDarkModeLCHColor` causing issues.
         * If it's a design token we should return it as is.
         */
        cssVariablePattern.test(color)
      ) {
        attrs10.style = "background-color: ".concat(color, ";");
      } else {
        if (getGlobalTheme().colorMode === "dark") {
          attrs10.style = "background-color: ".concat(getDarkModeLCHColor(color), ";");
        } else {
          attrs10.style = "background-color: ".concat(background, ";");
        }
      }
      if (color) {
        attrs10["data-cell-background"] = color;
      }
      attrs10.colorname = tableBackgroundColorPalette.get(color);
    }
  }
  if (nodeType === "tableHeader") {
    attrs10.class = tableHeaderSelector;
  } else {
    attrs10.class = tableCellSelector;
  }
  return attrs10;
};
var tableBackgroundColorPalette = /* @__PURE__ */ new Map();
var tableBackgroundBorderColor = hexToRgba(N800, 0.12) || N0;
var tableBackgroundColorNames = /* @__PURE__ */ new Map();
[[N0, "White"], [B50, "Light blue"], [T50, "Light teal"], [G50, "Light green"], [Y50, "Light yellow"], [R50, "Light red"], [P50, "Light purple"], [N20, "Light gray"], [B75, "Blue"], [T75, "Teal"], [G75, "Green"], [Y75, "Yellow"], [R75, "Red"], [P75, "Purple"], [N60, "Gray"], [B100, "Dark blue"], [T100, "Dark teal"], [G200, "Dark green"], [Y200, "Dark yellow"], [R100, "Dark red"], [P100, "Dark purple"]].forEach(function(_ref) {
  var _ref2 = _slicedToArray(_ref, 2), colorValue = _ref2[0], colorName = _ref2[1];
  tableBackgroundColorPalette.set(colorValue.toLowerCase(), colorName);
  tableBackgroundColorNames.set(colorName.toLowerCase(), colorValue.toLowerCase());
});
var createTableSpec = function createTableSpec2() {
  return table({
    parseDOM: [{
      tag: "table",
      getAttrs: function getAttrs58(node) {
        var _dom$parentElement;
        var dom = node;
        var breakoutWrapper = (_dom$parentElement = dom.parentElement) === null || _dom$parentElement === void 0 ? void 0 : _dom$parentElement.parentElement;
        return {
          isNumberColumnEnabled: dom.getAttribute("data-number-column") === "true",
          layout: (
            // copying from editor
            dom.getAttribute("data-layout") || // copying from renderer
            (breakoutWrapper === null || breakoutWrapper === void 0 ? void 0 : breakoutWrapper.getAttribute("data-layout")) || "default"
          ),
          __autoSize: dom.getAttribute("data-autosize") === "true",
          localId: dom.getAttribute("data-table-local-id") || uuid.generate(),
          width: Number(dom.getAttribute("data-table-width")) || null,
          displayMode: dom.getAttribute("data-table-display-mode") || null
        };
      }
    }],
    toDOM: function toDOM69(node) {
      var attrs10 = {
        "data-number-column": node.attrs.isNumberColumnEnabled,
        "data-layout": node.attrs.layout,
        "data-autosize": node.attrs.__autoSize,
        "data-table-local-id": node.attrs.localId,
        "data-table-width": node.attrs.width,
        "data-table-display-mode": node.attrs.displayMode
      };
      return ["table", attrs10, ["tbody", 0]];
    }
  });
};
var table2 = createTableSpec();
var tableWithCustomWidth = createTableSpec();
var tableStage0 = createTableSpec();
var tableRow2 = tableRow({
  parseDOM: [{
    tag: "tr"
  }],
  toDOM: function toDOM24() {
    return ["tr", 0];
  }
});
var tableCell2 = tableCell({
  parseDOM: [
    // Ignore number cell copied from renderer
    {
      tag: ".ak-renderer-table-number-column",
      ignore: true
    },
    {
      tag: "td",
      getAttrs: function getAttrs18(dom) {
        return getCellAttrs(dom);
      }
    }
  ],
  toDOM: function toDOM25(node) {
    return ["td", getCellDomAttrs(node), 0];
  }
});
var tableHeader2 = tableHeader({
  parseDOM: [{
    tag: "th",
    getAttrs: function getAttrs19(dom) {
      return getCellAttrs(dom, {
        background: DEFAULT_TABLE_HEADER_CELL_BACKGROUND
      });
    }
  }],
  toDOM: function toDOM26(node) {
    return ["th", getCellDomAttrs(node), 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/decision-list.js
var name5 = "decisionList";
var decisionListSelector = '[data-node-type="'.concat(name5, '"]');
var decisionList2 = decisionList({
  parseDOM: [{
    tag: "ol".concat(decisionListSelector),
    // Default priority is 50. We normally don't change this but since this node type is
    // also used by ordered-list we need to make sure that we run this parser first.
    priority: 100,
    getAttrs: function getAttrs20() {
      return {
        localId: uuid.generate()
      };
    }
  }],
  toDOM: function toDOM27(node) {
    var localId = node.attrs.localId;
    var attrs10 = {
      "data-node-type": name5,
      "data-decision-list-local-id": localId || "local-decision-list",
      style: "list-style: none; padding-left: 0"
    };
    return ["ol", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/decision-item.js
var decisionItem2 = decisionItem({
  parseDOM: [{
    tag: "li[data-decision-local-id]",
    // Default priority is 50. We normally don't change this but since this node type is
    // also used by list-item we need to make sure that we run this parser first.
    priority: 100,
    getAttrs: function getAttrs21(dom) {
      return {
        localId: uuid.generate(),
        state: dom.getAttribute("data-decision-state")
      };
    }
  }],
  toDOM: function toDOM28(node) {
    var _node$attrs = node.attrs, localId = _node$attrs.localId, state = _node$attrs.state;
    var attrs10 = {
      "data-decision-local-id": localId || "local-decision",
      "data-decision-state": state
    };
    return ["li", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/task-list.js
var name6 = "actionList";
var taskListSelector = '[data-node-type="'.concat(name6, '"]');
var taskList2 = taskList({
  parseDOM: [{
    tag: "div".concat(taskListSelector),
    // Default priority is 50. We normally don't change this but since this node type is
    // also used by ordered-list we need to make sure that we run this parser first.
    priority: 100,
    getAttrs: function getAttrs22() {
      return {
        localId: uuid.generate()
      };
    }
  }],
  toDOM: function toDOM29(node) {
    var localId = node.attrs.localId;
    var attrs10 = {
      "data-node-type": name6,
      "data-task-list-local-id": localId || "local-task-list",
      style: "list-style: none; padding-left: 0"
    };
    return ["div", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/task-item.js
var taskItem2 = taskItem({
  parseDOM: [{
    tag: "div[data-task-local-id]",
    // Default priority is 50. We normally don't change this but since this node type is
    // also used by list-item we need to make sure that we run this parser first.
    priority: 100,
    getAttrs: function getAttrs23(dom) {
      return {
        localId: uuid.generate(),
        state: dom.getAttribute("data-task-state") || "TODO"
      };
    }
  }],
  toDOM: function toDOM30(node) {
    var _node$attrs = node.attrs, localId = _node$attrs.localId, state = _node$attrs.state;
    var attrs10 = {
      "data-task-local-id": localId || "local-task",
      "data-task-state": state || "TODO"
    };
    return ["div", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/date.js
var date2 = date({
  parseDOM: [{
    tag: 'span[data-node-type="date"]',
    getAttrs: function getAttrs24(dom) {
      return {
        timestamp: dom.getAttribute("data-timestamp")
      };
    }
  }],
  toDOM: function toDOM31(node) {
    var attrs10 = {
      "data-node-type": "date",
      "data-timestamp": node.attrs.timestamp
    };
    return ["span", attrs10];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/placeholder.js
var placeholder2 = placeholder({
  parseDOM: [{
    tag: "span[data-placeholder]",
    getAttrs: function getAttrs25(dom) {
      return {
        text: dom.getAttribute("data-placeholder") || placeholder2.attrs.text.default
      };
    }
  }],
  toDOM: function toDOM32(node) {
    var text4 = node.attrs.text;
    var attrs10 = {
      "data-placeholder": text4,
      // Needs to be edtiable for mobile to not close keyboard
      contenteditable: "true"
    };
    return ["span", attrs10, text4];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/layout-section.js
var layoutSection2 = layoutSection({
  parseDOM: [{
    context: "layoutSection//|layoutColumn//",
    tag: "div[data-layout-section]",
    skip: true
  }, {
    tag: "div[data-layout-section]"
  }],
  toDOM: function toDOM33() {
    var attrs10 = {
      "data-layout-section": "true"
    };
    return ["div", attrs10, 0];
  }
});
var layoutSectionFull2 = layoutSectionFull({
  parseDOM: [{
    context: "layoutSection//|layoutColumn//",
    tag: "div[data-layout-section]",
    skip: true
  }, {
    tag: "div[data-layout-section]"
  }],
  toDOM: function toDOM34() {
    var attrs10 = {
      "data-layout-section": "true"
    };
    return ["div", attrs10, 0];
  }
});
var layoutSectionWithSingleColumn = layoutSection({
  parseDOM: [{
    context: "layoutSection//|layoutColumn//",
    tag: "div[data-layout-section]",
    skip: true
  }, {
    tag: "div[data-layout-section]"
  }],
  toDOM: function toDOM35() {
    var attrs10 = {
      "data-layout-section": "true"
    };
    return ["div", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/layout-column.js
var layoutColumn2 = layoutColumn({
  parseDOM: [{
    context: "layoutColumn//",
    tag: "div[data-layout-column]",
    skip: true
  }, {
    tag: "div[data-layout-column]",
    getAttrs: function getAttrs26(domNode) {
      var dom = domNode;
      return {
        width: Number(dom.getAttribute("data-column-width")) || void 0
      };
    }
  }],
  toDOM: function toDOM36(node) {
    var attrs10 = {
      "data-layout-column": "true"
    };
    var width = node.attrs.width;
    if (width) {
      attrs10["style"] = "flex-basis: ".concat(width, "%");
      attrs10["data-column-width"] = "".concat(width);
    }
    var contentAttrs = {
      "data-layout-content": "true"
    };
    return ["div", attrs10, ["div", contentAttrs, 0]];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/inline-card.js
var inlineCard2 = inlineCard({
  parseDOM: [
    {
      tag: "a[data-inline-card], span[data-inline-card]",
      // bump priority higher than hyperlink
      priority: 100,
      getAttrs: function getAttrs27(dom) {
        var anchor = dom;
        var data = anchor.getAttribute("data-card-data");
        return {
          url: anchor.getAttribute("href") || anchor.getAttribute("data-card-url") || null,
          data: data ? JSON.parse(data) : null
        };
      }
    },
    // for renderer
    {
      tag: "div[data-inline-card]",
      getAttrs: function getAttrs28(dom) {
        var anchor = dom;
        var data = anchor.getAttribute("data-card-data");
        return {
          url: anchor.getAttribute("data-card-url"),
          data: data ? JSON.parse(data) : null
        };
      }
    }
  ],
  toDOM: function toDOM37(node) {
    var attrs10 = {
      "data-inline-card": "",
      href: node.attrs.url || "",
      "data-card-data": node.attrs.data ? JSON.stringify(node.attrs.data) : ""
    };
    if (node.attrs.url) {
      return ["a", attrs10, node.attrs.url];
    } else {
      return ["a", attrs10];
    }
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/block-card.js
function ownKeys4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var getCommonAttributesFromDom = function getCommonAttributesFromDom2(dom) {
  var anchor = dom;
  var data = anchor.getAttribute("data-card-data");
  var datasource = anchor.getAttribute("data-datasource");
  return {
    data: data ? JSON.parse(data) : void 0,
    layout: datasource ? dom.getAttribute("data-layout") || void 0 : void 0,
    width: Number(dom.getAttribute("data-width")) || void 0,
    datasource: datasource ? JSON.parse(datasource) : void 0
  };
};
var blockCard2 = blockCard({
  parseDOM: [{
    tag: "a[data-block-card]",
    // bump priority higher than hyperlink
    priority: 100,
    getAttrs: function getAttrs29(dom) {
      var anchor = dom;
      return _objectSpread4({
        url: anchor.getAttribute("href") || void 0
      }, getCommonAttributesFromDom(dom));
    }
  }, {
    tag: "div[data-block-card]",
    getAttrs: function getAttrs30(dom) {
      var anchor = dom;
      return _objectSpread4({
        url: anchor.getAttribute("data-card-url") || void 0
      }, getCommonAttributesFromDom(dom));
    }
  }],
  toDOM: function toDOM38(node) {
    var _node$attrs;
    var _ref = node.attrs, url = _ref.url;
    var _ref2 = node.attrs, data = _ref2.data;
    var _ref3 = node.attrs, layout = _ref3.layout, width = _ref3.width, datasource = _ref3.datasource;
    var attrs10 = {
      "data-block-card": "",
      href: url || "",
      "data-card-data": data ? JSON.stringify(data) : "",
      "data-datasource": datasource ? JSON.stringify(datasource) : "",
      "data-layout": layout,
      "data-width": "".concat(width)
    };
    return ["a", attrs10, (node === null || node === void 0 ? void 0 : (_node$attrs = node.attrs) === null || _node$attrs === void 0 ? void 0 : _node$attrs.url) || " "];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/unsupported-block.js
var unsupportedBlock2 = unsupportedBlock({
  parseDOM: [{
    tag: '[data-node-type="unsupportedBlock"]',
    getAttrs: function getAttrs31(dom) {
      return {
        originalValue: JSON.parse(dom.getAttribute("data-original-value") || "{}")
      };
    }
  }],
  toDOM: function toDOM39(node) {
    var attrs10 = {
      "data-node-type": "unsupportedBlock",
      "data-original-value": JSON.stringify(node.attrs.originalValue)
    };
    return ["div", attrs10, "Unsupported content"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/unsupported-inline.js
var unsupportedInline2 = unsupportedInline({
  parseDOM: [{
    tag: '[data-node-type="unsupportedInline"]',
    getAttrs: function getAttrs32(dom) {
      return {
        originalValue: JSON.parse(dom.getAttribute("data-original-value") || "{}")
      };
    }
  }],
  toDOM: function toDOM40(node) {
    var attrs10 = {
      "data-node-type": "unsupportedInline",
      "data-original-value": JSON.stringify(node.attrs.originalValue)
    };
    return ["span", attrs10, "Unsupported content"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/status.js
var status2 = status({
  parseDOM: [{
    tag: 'span[data-node-type="status"]',
    getAttrs: function getAttrs33(domNode) {
      var dom = domNode;
      return {
        text: dom.textContent.replace(/\n/, "").trim(),
        color: dom.getAttribute("data-color"),
        localId: uuid.generate(),
        style: dom.getAttribute("data-style")
      };
    }
  }],
  toDOM: function toDOM41(node) {
    var _node$attrs = node.attrs, text4 = _node$attrs.text, color = _node$attrs.color, localId = _node$attrs.localId, style = _node$attrs.style;
    var attrs10 = {
      "data-node-type": "status",
      "data-color": color,
      "data-local-id": localId,
      "data-style": style,
      contenteditable: "false"
    };
    return ["span", attrs10, text4];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/nested-expand.js
var nestedExpand2 = nestedExpand({
  parseDOM: [{
    context: "nestedExpand//",
    tag: '[data-node-type="nestedExpand"]',
    skip: true
  }, {
    tag: '[data-node-type="nestedExpand"] button',
    ignore: true
  }, {
    tag: '[data-node-type="expand"] button',
    ignore: true
  }, {
    tag: 'div[data-node-type="nestedExpand"]',
    getAttrs: function getAttrs34(domNode) {
      var dom = domNode;
      return {
        title: dom.getAttribute("data-title"),
        __expanded: true
      };
    }
  }],
  toDOM: function toDOM42(node) {
    var attrs10 = {
      "data-node-type": "nestedExpand",
      "data-title": node.attrs.title,
      "data-expanded": node.attrs.__expanded
    };
    return ["div", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/embed-card.js
var embedCard2 = embedCard({
  parseDOM: [{
    tag: "div[data-embed-card]",
    getAttrs: function getAttrs35(dom) {
      return {
        url: dom.getAttribute("data-card-url"),
        layout: dom.getAttribute("data-layout") || "center",
        width: Number(dom.getAttribute("data-width")) || null,
        originalWidth: Number(dom.getAttribute("data-card-original-width")) || null,
        originalHeight: Number(dom.getAttribute("data-card-original-height")) || null
      };
    }
  }],
  toDOM: function toDOM43(node) {
    var _node$attrs = node.attrs, url = _node$attrs.url, layout = _node$attrs.layout, width = _node$attrs.width, originalWidth = _node$attrs.originalWidth, originalHeight = _node$attrs.originalHeight;
    var attrs10 = {
      "data-embed-card": "",
      "data-card-url": url,
      "data-layout": layout,
      "data-width": width,
      "data-original-width": originalWidth,
      "data-original-height": originalHeight
    };
    return ["div", attrs10];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/utils/extensions.js
var isValidLayout = function isValidLayout2(name7) {
  return !!name7 && ["default", "wide", "full-width"].includes(name7);
};
var getExtensionAttrs = function getExtensionAttrs2(dom) {
  var isInline = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var extensionType = dom.getAttribute("data-extension-type");
  var extensionKey = dom.getAttribute("data-extension-key");
  if (!extensionType || !extensionKey) {
    return false;
  }
  var attrs10 = {
    extensionType,
    extensionKey,
    text: dom.getAttribute("data-text") || void 0,
    parameters: JSON.parse(dom.getAttribute("data-parameters") || "{}"),
    localId: dom.getAttribute("data-local-id") || void 0
  };
  if (!isInline) {
    var rawLayout = dom.getAttribute("data-layout");
    attrs10.layout = isValidLayout(rawLayout) ? rawLayout : "default";
  }
  return attrs10;
};

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/extension.js
var extension2 = extension({
  parseDOM: [{
    tag: '[data-node-type="extension"]',
    getAttrs: function getAttrs36(domNode) {
      return getExtensionAttrs(domNode);
    }
  }],
  toDOM: function toDOM44(node) {
    var attrs10 = {
      "data-node-type": "extension",
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      "data-layout": node.attrs.layout,
      "data-local-id:": node.attrs.localId
    };
    return ["div", attrs10];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/inline-extension.js
var inlineExtension2 = inlineExtensionWithMarks({
  parseDOM: [{
    tag: "span[data-extension-type]",
    getAttrs: function getAttrs37(domNode) {
      return getExtensionAttrs(domNode, true);
    }
  }],
  toDOM: function toDOM45(node) {
    var attrs10 = {
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      "data-local-id:": node.attrs.localId,
      contenteditable: "false"
    };
    return ["span", attrs10];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/bodied-extension.js
var bodiedExtension2 = bodiedExtension({
  parseDOM: [{
    context: "bodiedExtension//",
    tag: '[data-node-type="bodied-extension"]',
    skip: true
  }, {
    tag: '[data-node-type="bodied-extension"]',
    getAttrs: function getAttrs38(domNode) {
      return getExtensionAttrs(domNode);
    }
  }],
  toDOM: function toDOM46(node) {
    var attrs10 = {
      "data-node-type": "bodied-extension",
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      "data-layout": node.attrs.layout,
      "data-local-id:": node.attrs.localId
    };
    return ["div", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/nodes/multi-bodied-extension.js
var extensionFrame = extensionFrameStage0({
  parseDOM: [{
    context: "extensionFrame//",
    tag: "div[data-extension-frame]",
    skip: true
  }, {
    tag: "div[data-extension-frame]"
  }],
  toDOM: function toDOM47() {
    var attrs10 = {
      "data-extension-frame": "true"
    };
    return ["div", attrs10, 0];
  }
});
var multiBodiedExtension = multiBodiedExtensionStage0({
  parseDOM: [{
    context: "multiBodiedExtension//",
    tag: '[data-node-type="multi-bodied-extension"]',
    skip: true
  }, {
    tag: '[data-node-type="multi-bodied-extension"]',
    getAttrs: function getAttrs39(domNode) {
      return getExtensionAttrs(domNode);
    }
  }],
  toDOM: function toDOM48(node) {
    var attrs10 = {
      "data-node-type": "multi-bodied-extension",
      "data-extension-type": node.attrs.extensionType,
      "data-extension-key": node.attrs.extensionKey,
      "data-text": node.attrs.text,
      "data-parameters": JSON.stringify(node.attrs.parameters),
      "data-layout": node.attrs.layout,
      "data-local-id:": node.attrs.localId
    };
    return ["div", attrs10, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/groups.js
var FONT_STYLE = "fontStyle";
var SEARCH_QUERY = "searchQuery";
var LINK = "link";
var COLOR = "color";

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/next-schema/generated/markTypes.js
var alignment = createPMMarkSpecFactory({
  attrs: {
    align: {}
  },
  excludes: "alignment indentation",
  group: "alignment"
});
var annotation = createPMMarkSpecFactory({
  attrs: {
    id: {
      default: ""
    },
    annotationType: {
      default: "inlineComment"
    }
  },
  inclusive: true,
  excludes: "",
  group: "annotation"
});
var backgroundColor = createPMMarkSpecFactory({
  attrs: {
    color: {}
  },
  inclusive: true,
  excludes: "color",
  group: "color"
});
var border = createPMMarkSpecFactory({
  attrs: {
    size: {},
    color: {}
  },
  inclusive: false
});
var breakout = createPMMarkSpecFactory({
  attrs: {
    mode: {
      default: "wide"
    }
  },
  inclusive: false,
  spanning: false
});
var code = createPMMarkSpecFactory({
  inclusive: true,
  excludes: "fontStyle link searchQuery color"
});
var confluenceInlineComment = createPMMarkSpecFactory({
  attrs: {
    reference: {
      default: ""
    }
  },
  inclusive: false,
  excludes: ""
});
var dataConsumer = createPMMarkSpecFactory({
  attrs: {
    sources: {
      default: []
    }
  }
});
var em = createPMMarkSpecFactory({
  inclusive: true,
  group: "fontStyle"
});
var fragment = createPMMarkSpecFactory({
  attrs: {
    localId: {
      default: ""
    },
    name: {
      default: null
    }
  },
  inclusive: false,
  excludes: ""
});
var indentation = createPMMarkSpecFactory({
  attrs: {
    level: {}
  },
  excludes: "indentation alignment",
  group: "indentation"
});
var link = createPMMarkSpecFactory({
  attrs: {
    href: {},
    __confluenceMetadata: {
      default: null
    }
  },
  inclusive: false,
  excludes: "link",
  group: "link"
});
var strike = createPMMarkSpecFactory({
  inclusive: true,
  group: "fontStyle"
});
var strong = createPMMarkSpecFactory({
  inclusive: true,
  group: "fontStyle"
});
var subsup = createPMMarkSpecFactory({
  attrs: {
    type: {
      default: "sub"
    }
  },
  inclusive: true,
  group: "fontStyle"
});
var textColor = createPMMarkSpecFactory({
  attrs: {
    color: {}
  },
  inclusive: true,
  group: "color"
});
var typeAheadQuery = createPMMarkSpecFactory({
  attrs: {
    trigger: {
      default: ""
    }
  },
  inclusive: true,
  group: "searchQuery"
});
var underline = createPMMarkSpecFactory({
  inclusive: true,
  group: "fontStyle"
});
var unsupportedMark = createPMMarkSpecFactory({
  attrs: {
    originalValue: {}
  },
  excludes: ""
});
var unsupportedNodeAttribute = createPMMarkSpecFactory({
  attrs: {
    unsupported: {},
    type: {}
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/em.js
var emDOM = ["em"];
var em2 = em({
  parseDOM: [{
    tag: "i"
  }, {
    tag: "em"
  }, {
    style: "font-style=italic"
  }],
  toDOM: function toDOM49() {
    return emDOM;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/code.js
var code2 = code({
  parseDOM: [{
    tag: "span.code",
    preserveWhitespace: true
  }, {
    tag: "code",
    preserveWhitespace: true
  }, {
    tag: "tt",
    preserveWhitespace: true
  }, {
    tag: "span",
    preserveWhitespace: true,
    getAttrs: function getAttrs40(domNode) {
      var dom = domNode;
      if (dom.style.whiteSpace === "pre") {
        return {};
      }
      if (dom.style.fontFamily && dom.style.fontFamily.toLowerCase().indexOf("monospace") >= 0) {
        return {};
      }
      return false;
    }
  }],
  toDOM: function toDOM50() {
    return ["span", {
      class: "code",
      spellcheck: "false"
    }];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/strike.js
var strike2 = strike({
  parseDOM: [{
    tag: "strike"
  }, {
    tag: "s"
  }, {
    tag: "del"
  }, {
    style: "text-decoration",
    getAttrs: function getAttrs41(value) {
      return value === "line-through" && null;
    }
  }],
  toDOM: function toDOM51() {
    return ["s"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/strong.js
var strongDOM = ["strong"];
var strong2 = strong({
  parseDOM: [
    {
      tag: "strong"
    },
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: function getAttrs42(node) {
        var element = node;
        return element.style.fontWeight !== "normal" && null;
      }
    },
    {
      tag: "span",
      getAttrs: function getAttrs43(node) {
        var element = node;
        var fontWeight = element.style.fontWeight;
        return typeof fontWeight === "string" && (fontWeight === "bold" || fontWeight === "bolder" || /^(bold(er)?|[5-9]\d{2,})$/.test(fontWeight)) && null;
      }
    }
  ],
  toDOM: function toDOM52() {
    return strongDOM;
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/underline.js
var underline2 = underline({
  parseDOM: [{
    tag: "u"
  }, {
    style: "text-decoration",
    getAttrs: function getAttrs44(value) {
      return value === "underline" && null;
    }
  }],
  toDOM: function toDOM53() {
    return ["u"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/link.js
function ownKeys5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var getLinkAttrs = function getLinkAttrs2(attribute2) {
  return function(domNode) {
    var dom = domNode;
    var href = dom.getAttribute(attribute2) || "";
    var attrs10 = {
      __confluenceMetadata: dom.hasAttribute("__confluenceMetadata") ? JSON.parse(dom.getAttribute("__confluenceMetadata") || "") : void 0
    };
    if (!isSafeUrl(href)) {
      return false;
    }
    if (isRootRelative(href)) {
      attrs10.href = href;
      return attrs10;
    }
    attrs10.href = normalizeUrl(href);
    return attrs10;
  };
};
var link2 = link({
  parseDOM: [{
    tag: "[data-block-link]",
    getAttrs: getLinkAttrs("data-block-link"),
    contentElement: function contentElement(node) {
      var clone = node.cloneNode(true);
      clone.removeAttribute("data-block-link");
      clone.setAttribute("data-skip-paste", "true");
      var wrapper = document.createElement("div");
      wrapper.appendChild(clone);
      return wrapper;
    }
  }, {
    tag: "a[href]",
    getAttrs: getLinkAttrs("href")
  }],
  toDOM: function toDOM54(node, isInline) {
    var attrs10 = Object.keys(node.attrs).reduce(function(attrs11, key) {
      if (key === "__confluenceMetadata") {
        if (node.attrs[key] !== null) {
          attrs11[key] = JSON.stringify(node.attrs[key]);
        }
      } else if (key === "href") {
        attrs11[key] = isSafeUrl(node.attrs[key]) ? node.attrs[key] : void 0;
      } else {
        attrs11[key] = node.attrs[key];
      }
      return attrs11;
    }, {});
    if (isInline) {
      return ["a", attrs10];
    }
    return ["a", _objectSpread5(_objectSpread5({}, attrs10), {}, _defineProperty(_defineProperty({}, "data-block-link", "true"), "class", "blockLink")), 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/type-ahead-query.js
var typeAheadQuery2 = typeAheadQuery({
  parseDOM: [{
    tag: "span[data-type-ahead-query]"
  }],
  toDOM: function toDOM55(node) {
    return ["span", {
      "data-type-ahead-query": "true",
      "data-trigger": node.attrs.trigger,
      style: "color: ".concat(B400)
    }];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/subsup.js
function getAttrFromVerticalAlign(node) {
  if (node === "sub") {
    return {
      type: "sub"
    };
  }
  if (node === "super") {
    return {
      type: "sup"
    };
  }
  return false;
}
var subsup2 = subsup({
  parseDOM: [{
    tag: "sub",
    attrs: {
      type: "sub"
    }
  }, {
    tag: "sup",
    attrs: {
      type: "sup"
    }
  }, {
    // Special case for pasting from Google Docs
    // Google Docs uses vertical align to denote subscript and super script
    style: "vertical-align=super",
    getAttrs: function getAttrs45(node) {
      return getAttrFromVerticalAlign(node);
    }
  }, {
    style: "vertical-align=sub",
    getAttrs: function getAttrs46(node) {
      return getAttrFromVerticalAlign(node);
    }
  }],
  toDOM: function toDOM56(mark) {
    return [mark.attrs.type];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/text-color.js
var colorArrayPalette = [
  // default row - first color is added programatically
  // [N800, 'Squid ink'], // default dark gray
  [B500, "Dark blue"],
  // Chore coat
  [T500, "Dark teal"],
  // Shabby chic
  [G500, "Dark green"],
  // Keen green
  [Y400, "Orange"],
  // Cheezy blasters
  [R500, "Dark red"],
  // Dragon's blood
  [P500, "Dark purple"],
  // Prince
  // row 2
  [N80, "Light gray"],
  // Spooky ghost
  [B100, "Blue"],
  // Arvo breeze
  [T300, "Teal"],
  // Tamarama
  [G300, "Green"],
  // Fine pine
  [Y200, "Yellow"],
  // Pub mix
  [R300, "Red"],
  // Poppy surprise
  [P300, "Purple"],
  // Da' juice
  // row 3
  [N0, "White"],
  [B75, "Light blue"],
  // Schwag
  [T75, "Light teal"],
  // Arctic chill
  [G75, "Light green"],
  // Mintie
  [Y75, "Light yellow"],
  // Dandelion whisper
  [R75, "Light red"],
  // Bondi sunburn
  [P50, "Light purple"]
  // Lavender secret
];
var colorPalette = /* @__PURE__ */ new Map();
colorArrayPalette.forEach(function(_ref) {
  var _ref2 = _slicedToArray(_ref, 2), color = _ref2[0], label = _ref2[1];
  return colorPalette.set(color.toLowerCase(), label);
});
var testGlobalTheme2;
var getGlobalTheme3 = function getGlobalTheme4() {
  if (testGlobalTheme2) {
    return {
      colorMode: testGlobalTheme2
    };
  }
  var element = document.documentElement;
  var colorMode = element.getAttribute("data-color-mode") || "";
  return {
    colorMode
  };
};
var textColor2 = textColor({
  parseDOM: [
    {
      style: "color",
      getAttrs: function getAttrs47(maybeValue) {
        var value = maybeValue;
        var hexColor;
        if (value.match(/^rgb/i)) {
          hexColor = rgbToHex(value);
        } else if (value[0] === "#") {
          hexColor = value.toLowerCase();
        }
        return hexColor && colorPalette.has(hexColor) ? {
          color: hexColor
        } : false;
      }
    },
    // This rule ensures when loading from a renderer or editor where the
    // presented text color does not match the stored hex color -- that the
    // text color is preserved.
    //
    // This was initially introduced to ensure text-color marks were not lost
    // when text-color was used inside a link, and is now also used to support
    // where the hex color stored in ADF is used as an ID for a design system
    // token (and based on theme mode -- the presented color will change).
    {
      tag: ".fabric-text-color-mark",
      getAttrs: function getAttrs48(maybeElement) {
        if (!(maybeElement instanceof HTMLElement)) {
          return false;
        }
        var hexColor = maybeElement.dataset.textCustomColor;
        return hexColor && colorPalette.has(hexColor) ? {
          color: hexColor
        } : false;
      }
    }
  ],
  toDOM: function toDOM57(mark) {
    var paletteColorValue;
    var tokenColor = hexToEditorTextPaletteColor(mark.attrs.color);
    if (tokenColor) {
      paletteColorValue = tokenColor;
    } else {
      if (getGlobalTheme3().colorMode === "dark") {
        paletteColorValue = getDarkModeLCHColor(mark.attrs.color);
      } else {
        paletteColorValue = mark.attrs.color;
      }
    }
    return ["span", _defineProperty({
      class: "fabric-text-color-mark",
      // Editor common has a common style which uses this css variable as the value for
      // the color property using the `fabric-text-color-mark` selector applied above.
      style: "--custom-palette-color: ".concat(paletteColorValue)
    }, "data-text-custom-color", mark.attrs.color)];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/confluence-inline-comment.js
var confluenceInlineComment2 = confluenceInlineComment({
  parseDOM: [{
    tag: 'span[data-mark-type="confluenceInlineComment"]'
  }],
  toDOM: function toDOM58(node) {
    return ["span", {
      "data-mark-type": "confluenceInlineComment",
      "data-reference": node.attrs.reference
    }];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/breakout.js
var allowedTypes = ["wide", "full-width"];
var breakout2 = breakout({
  parseDOM: [{
    tag: "div.fabric-editor-breakout-mark",
    getAttrs: function getAttrs49(dom) {
      var mode = dom.getAttribute("data-mode");
      return {
        mode: allowedTypes.indexOf(mode || "") === -1 ? "wide" : mode
      };
    }
  }],
  toDOM: function toDOM59(mark) {
    return ["div", {
      class: "fabric-editor-breakout-mark",
      "data-mode": mark.attrs.mode
    }, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/alignment.js
var alignment2 = alignment({
  parseDOM: [{
    tag: "div.fabric-editor-block-mark",
    getAttrs: function getAttrs50(dom) {
      var align = dom.getAttribute("data-align");
      return align ? {
        align
      } : false;
    }
  }],
  toDOM: function toDOM60(mark) {
    return ["div", {
      class: "fabric-editor-block-mark fabric-editor-alignment fabric-editor-align-".concat(mark.attrs.align),
      "data-align": mark.attrs.align
    }, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/indentation.js
var indentation2 = indentation({
  parseDOM: [{
    tag: "div.fabric-editor-indentation-mark",
    getAttrs: function getAttrs51(dom) {
      var level = +(dom.getAttribute("data-level") || "0");
      return {
        level: level > 6 ? 6 : level < 1 ? false : level
      };
    }
  }],
  toDOM: function toDOM61(mark) {
    return ["div", {
      class: "fabric-editor-block-mark fabric-editor-indentation-mark",
      "data-level": mark.attrs.level
    }, 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/annotation.js
function ownKeys6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var AnnotationTypes = function(AnnotationTypes2) {
  AnnotationTypes2["INLINE_COMMENT"] = "inlineComment";
  return AnnotationTypes2;
}({});
var AnnotationMarkStates = function(AnnotationMarkStates2) {
  AnnotationMarkStates2["RESOLVED"] = "resolved";
  AnnotationMarkStates2["ACTIVE"] = "active";
  return AnnotationMarkStates2;
}({});
function buildDataAttributes(_ref) {
  var id = _ref.id, annotationType = _ref.annotationType, state = _ref.state;
  var data = {
    "data-mark-type": "annotation",
    "data-mark-annotation-type": annotationType,
    "data-id": id
  };
  if (state) {
    return _objectSpread6(_objectSpread6({}, data), {}, {
      "data-mark-annotation-state": state
    });
  }
  return data;
}
var annotation2 = annotation({
  parseDOM: [{
    tag: 'span[data-mark-type="annotation"]',
    mark: "annotation",
    getAttrs: function getAttrs52(domNode) {
      var dom = domNode;
      var attrs10 = {
        id: dom.getAttribute("data-id"),
        annotationType: dom.getAttribute("data-mark-annotation-type")
      };
      return attrs10;
    }
  }],
  toDOM: function toDOM62(node) {
    return ["span", _objectSpread6({
      // Prettier will remove the quotes around class. This would cause some browsers
      // to not add this attribute properly, as its a reserved word.
      // prettier-ignore
      "class": "fabric-editor-annotation"
    }, buildDataAttributes({
      id: node.attrs.id,
      annotationType: node.attrs.annotationType
    })), 0];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/unsupported-mark.js
var unsupportedMark2 = unsupportedMark({
  toDOM: function toDOM63() {
    return ["span"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/unsupported-node-attributes.js
var unsupportedNodeAttribute2 = unsupportedNodeAttribute({
  toDOM: function toDOM64() {
    return ["span"];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/data-consumer.js
var parseDataConsumer = function parseDataConsumer2(maybeValue) {
  var sources = isDOMElement(maybeValue) && maybeValue.getAttribute("data-sources");
  try {
    return sources ? {
      sources: JSON.parse(sources)
    } : false;
  } catch (_unused) {
    return false;
  }
};
var dataConsumer2 = dataConsumer({
  parseDOM: [{
    tag: '[data-mark-type="dataConsumer"]',
    getAttrs: function getAttrs53(maybeValue) {
      return parseDataConsumer(maybeValue);
    }
  }],
  toDOM: function toDOM65(mark, inline2) {
    var wrapperStyle = inline2 ? "span" : "div";
    return [wrapperStyle, {
      "data-mark-type": "dataConsumer",
      "data-sources": JSON.stringify(mark.attrs.sources)
    }];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/fragment.js
var parseFragment = function parseFragment2(maybeValue) {
  var _maybeValue$getAttrib;
  if (!isDOMElement(maybeValue)) {
    return false;
  }
  var name7 = (_maybeValue$getAttrib = maybeValue.getAttribute("data-name")) !== null && _maybeValue$getAttrib !== void 0 ? _maybeValue$getAttrib : void 0;
  var localId = maybeValue.getAttribute("data-localId");
  if (!localId) {
    return false;
  }
  return {
    localId,
    name: name7
  };
};
var fragment2 = fragment({
  parseDOM: [{
    tag: '[data-mark-type="fragment"]',
    getAttrs: function getAttrs54(maybeValue) {
      return parseFragment(maybeValue);
    }
  }],
  toDOM: function toDOM66(mark, inline2) {
    var wrapperStyle = inline2 ? "span" : "div";
    return [wrapperStyle, {
      "data-mark-type": "fragment",
      "data-name": mark.attrs.name,
      "data-localId": mark.attrs.localId
    }];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/border.js
var borderColorArrayPalette = [[N300A, "Subtle gray"], [N600, "Gray"], [N1000, "Bold gray"]];
var borderColorPalette = /* @__PURE__ */ new Map();
borderColorArrayPalette.forEach(function(_ref) {
  var _ref2 = _slicedToArray(_ref, 2), color = _ref2[0], label = _ref2[1];
  return borderColorPalette.set(color.toLowerCase(), label);
});
var border2 = border({
  parseDOM: [{
    tag: '[data-mark-type="border"]',
    getAttrs: function getAttrs55(domNode) {
      var _dom$getAttribute, _dom$getAttribute2;
      var dom = domNode;
      var color = ((_dom$getAttribute = dom.getAttribute("data-color")) !== null && _dom$getAttribute !== void 0 ? _dom$getAttribute : "").toLowerCase();
      var size = +((_dom$getAttribute2 = dom.getAttribute("data-size")) !== null && _dom$getAttribute2 !== void 0 ? _dom$getAttribute2 : "0");
      return {
        size: size > 3 ? 3 : size < 1 ? false : size,
        color: borderColorPalette.has(color) ? color : false
      };
    }
  }],
  toDOM: function toDOM67(mark, isInline) {
    var wrapperStyle = isInline ? "span" : "div";
    var paletteColorValue = hexToEditorBorderPaletteColor(mark.attrs.color) || mark.attrs.color;
    return [wrapperStyle, {
      "data-mark-type": "border",
      "data-color": mark.attrs.color,
      "data-size": mark.attrs.size,
      style: "--custom-palette-color: ".concat(paletteColorValue)
    }];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/marks/background-color.js
var colorArrayPalette2 = [
  [Neutral300, "Gray"],
  // token: color.background.accent.gray.subtler
  [T200, "Teal"],
  // token: color.background.accent.teal.subtler
  [L200, "Lime"],
  // token: color.background.accent.lime.subtler
  [O200, "Orange"],
  // token: color.background.accent.orange.subtler
  [M200, "Magenta"],
  // token: color.background.accent.magenta.subtler
  [P200, "Purple"]
  // token: color.background.accent.purple.subtler
];
var backgroundColorPalette = /* @__PURE__ */ new Map();
colorArrayPalette2.forEach(function(_ref) {
  var _ref2 = _slicedToArray(_ref, 2), color = _ref2[0], label = _ref2[1];
  return backgroundColorPalette.set(color.toLowerCase(), label);
});
var backgroundColor2 = backgroundColor({
  parseDOM: [
    {
      style: "background-color",
      getAttrs: function getAttrs56(maybeValue) {
        var value = maybeValue;
        var hexColor;
        if (value.match(/^rgb/i)) {
          hexColor = rgbToHex(value);
        } else if (value[0] === "#") {
          hexColor = value.toLowerCase();
        }
        return hexColor && backgroundColorPalette.has(hexColor) ? {
          color: hexColor
        } : false;
      }
    },
    // This rule ensures when loading from a renderer or editor where the
    // presented text color does not match the stored hex color -- that the
    // text color is preserved.
    //
    // This is used to support the work-around that converts the hex color to
    // a design system token to enable light / dark mode (through a CSS variable --custom-palette-color)
    {
      tag: ".fabric-background-color-mark",
      getAttrs: function getAttrs57(maybeElement) {
        if (!(maybeElement instanceof HTMLElement)) {
          return false;
        }
        var hexColor = maybeElement.dataset.backgroundCustomColor;
        return hexColor && backgroundColorPalette.has(hexColor) ? {
          color: hexColor
        } : false;
      }
    }
  ],
  toDOM: function toDOM68(mark) {
    var paletteColorValue;
    var tokenColor = hexToEditorTextBackgroundPaletteColor(mark.attrs.color);
    if (tokenColor) {
      paletteColorValue = tokenColor;
    } else {
      if (getGlobalTheme3().colorMode === "dark") {
        paletteColorValue = getDarkModeLCHColor(mark.attrs.color);
      } else {
        paletteColorValue = mark.attrs.color;
      }
    }
    return ["span", _defineProperty({
      class: "fabric-background-color-mark",
      // Editor common has a common style which uses this css variable as the value for
      // the color property using the `fabric-text-background-color-mark` selector applied above.
      style: "--custom-palette-color: ".concat(paletteColorValue)
    }, "data-background-custom-color", mark.attrs.color)];
  }
});

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/create-schema.js
function ownKeys7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys7(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function addItems(builtInItems, config2) {
  var customSpecs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!config2) {
    return {};
  }
  var items = builtInItems.reduce(function(items2, _ref) {
    var name7 = _ref.name, spec = _ref.spec;
    if (config2.indexOf(name7) !== -1) {
      items2[name7] = customSpecs[name7] || spec;
    }
    return items2;
  }, {});
  return Object.keys(customSpecs).reduce(function(items2, name7) {
    if (items2[name7]) {
      return items2;
    }
    items2[name7] = customSpecs[name7];
    return items2;
  }, items);
}
function groupDeclaration(name7) {
  return {
    name: "__".concat(name7, "GroupDeclaration"),
    spec: {
      group: name7
    }
  };
}
var markGroupDeclarations = [groupDeclaration(COLOR), groupDeclaration(FONT_STYLE), groupDeclaration(SEARCH_QUERY), groupDeclaration(LINK)];
var markGroupDeclarationsNames = markGroupDeclarations.map(function(groupMark) {
  return groupMark.name;
});
var nodesInOrder = [{
  name: "doc",
  spec: doc2
}, {
  name: "paragraph",
  spec: paragraph2
}, {
  name: "text",
  spec: text2
}, {
  name: "bulletList",
  spec: bulletList2
}, {
  name: "orderedList",
  spec: orderedListWithOrder
}, {
  name: "listItem",
  spec: listItemWithTask
}, {
  name: "heading",
  spec: heading2
}, {
  name: "blockquote",
  spec: blockquoteWithNestedCodeblockOrMedia
}, {
  name: "codeBlock",
  spec: codeBlock2
}, {
  name: "panel",
  spec: extendedPanel(true)
}, {
  name: "rule",
  spec: rule2
}, {
  name: "image",
  spec: image2
}, {
  name: "mention",
  spec: mention2
}, {
  name: "caption",
  spec: caption2
}, {
  name: "media",
  spec: media2
}, {
  name: "mediaGroup",
  spec: mediaGroup2
}, {
  name: "mediaSingle",
  spec: mediaSingleFull2
}, {
  name: "mediaInline",
  spec: mediaInline2
}, {
  name: "placeholder",
  spec: placeholder2
}, {
  name: "layoutSection",
  spec: layoutSection2
}, {
  name: "layoutColumn",
  spec: layoutColumn2
}, {
  name: "hardBreak",
  spec: hardBreak2
}, {
  name: "emoji",
  spec: emoji2
}, {
  name: "table",
  spec: table2
}, {
  name: "tableCell",
  spec: tableCell2
}, {
  name: "tableRow",
  spec: tableRow2
}, {
  name: "tableHeader",
  spec: tableHeader2
}, {
  name: "confluenceJiraIssue",
  spec: confluenceJiraIssue2
}, {
  name: "confluenceUnsupportedInline",
  spec: confluenceUnsupportedInline2
}, {
  name: "confluenceUnsupportedBlock",
  spec: confluenceUnsupportedBlock2
}, {
  name: "decisionList",
  spec: decisionList2
}, {
  name: "decisionItem",
  spec: decisionItem2
}, {
  name: "taskList",
  spec: taskList2
}, {
  name: "taskItem",
  spec: taskItem2
}, {
  name: "date",
  spec: date2
}, {
  name: "status",
  spec: status2
}, {
  name: "expand",
  spec: expandWithNestedExpand
}, {
  name: "nestedExpand",
  spec: nestedExpand2
}, {
  name: "extension",
  spec: extension2
}, {
  name: "inlineExtension",
  spec: inlineExtension2
}, {
  name: "bodiedExtension",
  spec: bodiedExtension2
}, {
  name: "multiBodiedExtension",
  spec: multiBodiedExtension
}, {
  name: "extensionFrame",
  spec: extensionFrame
}, {
  name: "inlineCard",
  spec: inlineCard2
}, {
  name: "blockCard",
  spec: blockCard2
}, {
  name: "embedCard",
  spec: embedCard2
}, {
  name: "unknownBlock",
  spec: unknown_block_default
}, {
  name: "unsupportedBlock",
  spec: unsupportedBlock2
}, {
  name: "unsupportedInline",
  spec: unsupportedInline2
}];
var marksInOrder = [{
  name: "link",
  spec: link2
}, {
  name: "em",
  spec: em2
}, {
  name: "strong",
  spec: strong2
}, {
  name: "textColor",
  spec: textColor2
}, {
  name: "backgroundColor",
  spec: backgroundColor2
}, {
  name: "strike",
  spec: strike2
}, {
  name: "subsup",
  spec: subsup2
}, {
  name: "underline",
  spec: underline2
}, {
  name: "code",
  spec: code2
}, {
  name: "typeAheadQuery",
  spec: typeAheadQuery2
}, {
  name: "alignment",
  spec: alignment2
}, {
  name: "annotation",
  spec: annotation2
}, {
  name: "confluenceInlineComment",
  spec: confluenceInlineComment2
}].concat(markGroupDeclarations, [{
  name: "breakout",
  spec: breakout2
}, {
  name: "dataConsumer",
  spec: dataConsumer2
}, {
  name: "fragment",
  spec: fragment2
}, {
  name: "indentation",
  spec: indentation2
}, {
  name: "border",
  spec: border2
}, {
  name: "unsupportedMark",
  spec: unsupportedMark2
}, {
  name: "unsupportedNodeAttribute",
  spec: unsupportedNodeAttribute2
}]);
function createSchema(config2) {
  var customNodeSpecs = config2.customNodeSpecs, customMarkSpecs = config2.customMarkSpecs;
  var nodesConfig = Object.keys(customNodeSpecs || {}).concat(config2.nodes);
  var marksConfig = Object.keys(customMarkSpecs || {}).concat(config2.marks || []).concat(markGroupDeclarationsNames);
  var nodes = addItems(nodesInOrder, nodesConfig, customNodeSpecs);
  var marks = addItems(marksInOrder, marksConfig, customMarkSpecs);
  nodes = sanitizeNodes(nodes, marks);
  return new Schema({
    nodes,
    marks
  });
}
function sanitizeNodes(nodes, supportedMarks) {
  var nodeNames = Object.keys(nodes);
  nodeNames.forEach(function(nodeKey) {
    var nodeSpec = _objectSpread7({}, nodes[nodeKey]);
    if (nodeSpec.marks && nodeSpec.marks !== "_") {
      nodeSpec.marks = nodeSpec.marks.split(" ").filter(function(mark) {
        return !!supportedMarks[mark];
      }).join(" ");
    }
    if (nodeSpec.content) {
      nodeSpec.content = sanitizeNodeSpecContent(nodes, nodeSpec.content);
    }
    nodes[nodeKey] = nodeSpec;
  });
  return nodes;
}
function sanitizeNodeSpecContent(nodes, rawContent) {
  var content = rawContent.replace(/\W/g, " ");
  var contentKeys = content.split(" ");
  var unsupportedContentKeys = contentKeys.filter(function(contentKey) {
    return !isContentSupported(nodes, contentKey);
  });
  return unsupportedContentKeys.reduce(function(newContent, nodeName) {
    return sanitizedContent(newContent, nodeName);
  }, rawContent);
}
function sanitizedContent(content, invalidContent) {
  if (!invalidContent.length) {
    return content || "";
  }
  if (!content || !content.match(/\w/)) {
    return "";
  }
  var pattern = "(".concat(invalidContent, "((\\s)*\\|)+)|((\\|(\\s)*)+").concat(invalidContent, ")|(").concat(invalidContent, "$)|(").concat(invalidContent, "(\\+|\\*))");
  return content.replace(new RegExp(pattern, "g"), "").replace("  ", " ").trim();
}
function isContentSupported(nodes, contentKey) {
  var nodeKeys = Object.keys(nodes);
  if (nodeKeys.indexOf(contentKey) > -1) {
    return true;
  }
  for (var supportedKey in nodes) {
    var nodeSpec = nodes[supportedKey];
    if (nodeSpec && nodeSpec.group === contentKey) {
      return true;
    }
  }
  return false;
}

// node_modules/@atlaskit/editor-markdown-transformer/node_modules/@atlaskit/adf-schema/dist/esm/schema/default-schema.js
var getDefaultSchemaConfig = function getDefaultSchemaConfig2() {
  var defaultSchemaConfig2 = {
    nodes: ["doc", "paragraph", "text", "bulletList", "orderedList", "listItem", "heading", "blockquote", "codeBlock", "panel", "rule", "image", "caption", "mention", "media", "mediaGroup", "mediaSingle", "mediaInline", "confluenceUnsupportedBlock", "confluenceUnsupportedInline", "confluenceJiraIssue", "expand", "nestedExpand", "extension", "inlineExtension", "bodiedExtension", "hardBreak", "emoji", "table", "tableCell", "tableHeader", "tableRow", "decisionList", "decisionItem", "taskList", "taskItem", "unknownBlock", "date", "status", "placeholder", "layoutSection", "layoutColumn", "inlineCard", "blockCard", "embedCard", "unsupportedBlock", "unsupportedInline"],
    marks: [
      "link",
      "em",
      "strong",
      "strike",
      "subsup",
      "underline",
      "code",
      "textColor",
      "backgroundColor",
      "confluenceInlineComment",
      "breakout",
      "alignment",
      "indentation",
      "annotation",
      "dataConsumer",
      "border",
      "unsupportedMark",
      "unsupportedNodeAttribute",
      "typeAheadQuery",
      // https://product-fabric.atlassian.net/browse/ED-10214,
      "fragment"
    ]
  };
  return defaultSchemaConfig2;
};
var defaultSchemaConfig = getDefaultSchemaConfig();
var getSchemaBasedOnStage = memoizeOne(function() {
  var stage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "final";
  var defaultSchemaConfig2 = getDefaultSchemaConfig();
  if (stage === "stage0") {
    defaultSchemaConfig2.customNodeSpecs = {
      layoutSection: layoutSectionWithSingleColumn,
      multiBodiedExtension,
      extensionFrame,
      expand: expandWithNestedExpand,
      blockquote: blockquoteWithNestedCodeblockOrMedia,
      listItem: listItemWithDecisionStage0,
      panel: panelWithBlockquoteStage0(true)
    };
  }
  return createSchema(defaultSchemaConfig2);
});
var defaultSchema = getSchemaBasedOnStage();

// node_modules/@atlaskit/editor-markdown-transformer/dist/esm/index.js
var import_markdown_it2 = __toESM(require_markdown_it());

// node_modules/markdown-it-table/dist/es/index.js
var import_table = __toESM(require_table2());
var markdownItTable = function markdownItTable2(md2, options) {
  md2.block.ruler.before("paragraph", "table", import_table.default, {
    alt: ["paragraph", "reference"]
  });
};

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/utils.mjs
var utils_exports = {};
__export(utils_exports, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint2,
  has: () => has,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// node_modules/prosemirror-markdown/node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format,
  parse: () => parse_default
});

// node_modules/prosemirror-markdown/node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode2(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode2.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "ï¿½ï¿½";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "ï¿½ï¿½ï¿½";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "ï¿½ï¿½ï¿½ï¿½";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "ï¿½";
    }
    return result;
  });
}
decode2.defaultChars = ";/?:@&=+$,#";
decode2.componentChars = "";
var decode_default = decode2;

// node_modules/prosemirror-markdown/node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode2(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode2.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string.length; i < l; i++) {
    const code4 = string.charCodeAt(i);
    if (keepEscaped && code4 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code4 < 128) {
      result += cache[code4];
      continue;
    }
    if (code4 >= 55296 && code4 <= 57343) {
      if (code4 >= 55296 && code4 <= 56319 && i + 1 < l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode2.componentChars = "-_.!~*'()";
var encode_default = encode2;

// node_modules/prosemirror-markdown/node_modules/mdurl/lib/format.mjs
function format(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}

// node_modules/prosemirror-markdown/node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url)
    return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// node_modules/prosemirror-markdown/node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// node_modules/prosemirror-markdown/node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// node_modules/prosemirror-markdown/node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// node_modules/prosemirror-markdown/node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// node_modules/prosemirror-markdown/node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// node_modules/prosemirror-markdown/node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/prosemirror-markdown/node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code4) {
  return code4 >= CharCodes.ZERO && code4 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code4) {
  return code4 >= CharCodes.UPPER_A && code4 <= CharCodes.UPPER_F || code4 >= CharCodes.LOWER_A && code4 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code4) {
  return code4 >= CharCodes.UPPER_A && code4 <= CharCodes.UPPER_Z || code4 >= CharCodes.LOWER_A && code4 <= CharCodes.LOWER_Z || isNumber(code4);
}
function isEntityInAttributeInvalidEnd(code4) {
  return code4 === CharCodes.EQUALS || isAsciiAlphaNumeric(code4);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors3) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors3;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base3) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base3, digitCount) + parseInt(str.substr(start, digitCount), base3);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function getEscaper(regex, map3) {
  return function escape3(data) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data)) {
      if (lastIdx !== match2.index) {
        result += data.substring(lastIdx, match2.index);
      }
      result += map3.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint2(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match2, name7) {
  if (name7.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name7)) {
    const code4 = name7[1].toLowerCase() === "x" ? parseInt(name7.slice(2), 16) : parseInt(name7.slice(1), 10);
    if (isValidEntityCode(code4)) {
      return fromCodePoint2(code4);
    }
    return match2;
  }
  const decoded = decodeHTML(match2);
  if (decoded !== match2) {
    return decoded;
  }
  return match2;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match2, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code4) {
  switch (code4) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code4) {
  if (code4 >= 8192 && code4 <= 8202) {
    return true;
  }
  switch (code4) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("áº".toLowerCase() === "á¹¾") {
    str = str.replace(/áº/g, "ÃŸ");
  }
  return str.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str, start, max) {
  let code4;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code4 = str.charCodeAt(pos);
      if (code4 === 10) {
        return result;
      }
      if (code4 === 60) {
        return result;
      }
      if (code4 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code4 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code4 = str.charCodeAt(pos);
    if (code4 === 32) {
      break;
    }
    if (code4 < 32 || code4 === 127) {
      break;
    }
    if (code4 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code4 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code4 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str, start, max, prev_state) {
  let code4;
  let pos = start;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code4 = str.charCodeAt(pos);
    if (code4 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code4 === 40 && state.marker === 41) {
      return state;
    } else if (code4 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start, pos));
  return state;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer_default = Renderer;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name7) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name7) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self = this;
  const chains = [""];
  self.__rules__.forEach(function(rule3) {
    if (!rule3.enabled) {
      return;
    }
    rule3.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self.__cache__ = {};
  chains.forEach(function(chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function(rule3) {
      if (!rule3.enabled) {
        return;
      }
      if (chain && rule3.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule3.fn);
    });
  });
};
Ruler.prototype.at = function(name7, fn, options) {
  const index = this.__find__(name7);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name7);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name7) {
    const idx = this.__find__(name7);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name7);
    }
    this.__rules__[idx].enabled = true;
    result.push(name7);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule3) {
    rule3.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name7) {
    const idx = this.__find__(name7);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name7);
    }
    this.__rules__[idx].enabled = false;
    result.push(name7);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/token.mjs
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name7) {
  if (!this.attrs) {
    return -1;
  }
  const attrs10 = this.attrs;
  for (let i = 0, len = attrs10.length; i < len; i++) {
    if (attrs10[i][0] === name7) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name7, value) {
  const idx = this.attrIndex(name7);
  const attrData = [name7, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name7) {
  const idx = this.attrIndex(name7);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name7, value) {
  const idx = this.attrIndex(name7);
  if (idx < 0) {
    this.attrPush([name7, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md2, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md2;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "ï¿½");
  state.src = str;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/block.mjs
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify2(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text4 = currentToken.content;
        let links = state.md.linkify.match(text4);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text4.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text4.length) {
          const token = new state.Token("text", "", 0);
          token.content = text4.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "Â©",
  r: "Â®",
  tm: "â„¢"
};
function replaceFn(match2, name7) {
  return SCOPED_ABBR[name7.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "â€™";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text4 = token.content;
    let pos = 0;
    let max = text4.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text4);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text4.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text4.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text4 = token.content;
              max = text4.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state) {
  let curr, last;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline")
      continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify2],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md2, env, tokens) {
  this.src = src;
  this.md = md2;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token = new token_default(type, tag, nesting);
  token.block = true;
  if (nesting < 0)
    this.level--;
  token.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code4) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code4) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code4, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code4 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i = 0, line = begin; line < end; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first = lineStart;
    let last;
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table4(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/code.mjs
function code3(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote3(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
      return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str = state.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null)
      break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/heading.mjs
function heading3(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph3(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table4, ["paragraph", "reference"]],
  ["code", code3],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote3, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading3, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph3]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok)
      throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md2, env, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md2, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md2, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md2;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text3(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify3(state, silent) {
  if (!state.md.options.linkify)
    return false;
  if (state.linkLevel > 0)
    return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max)
    return false;
  if (state.src.charCodeAt(pos) !== 58)
    return false;
  if (state.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state.src.charCodeAt(pos + 2) !== 47)
    return false;
  const match2 = state.pending.match(SCHEME_RE);
  if (!match2)
    return false;
  const proto = match2[1];
  const link4 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link4)
    return false;
  let url = link4.url;
  if (url.length <= proto.length)
    return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape2(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max)
    return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1))
        break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker;
  state.pos += openerLength;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess2(state, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess2(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/link.mjs
function link3(state, silent) {
  let code4, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code4 = state.src.charCodeAt(pos);
      if (!isSpace(code4) && code4 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code4 = state.src.charCodeAt(pos);
        if (!isSpace(code4) && code4 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code4 = state.src.charCodeAt(pos);
          if (!isSpace(code4) && code4 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs10 = [["href", href]];
    token_o.attrs = attrs10;
    if (title) {
      attrs10.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/image.mjs
function image3(state, silent) {
  let code4, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code4 = state.src.charCodeAt(pos);
      if (!isSpace(code4) && code4 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code4 = state.src.charCodeAt(pos);
      if (!isSpace(code4) && code4 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code4 = state.src.charCodeAt(pos);
        if (!isSpace(code4) && code4 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs10 = [["src", href], ["alt", ""]];
    token.attrs = attrs10;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs10.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose2(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match2[0];
    if (isLinkOpen2(token.content))
      state.linkLevel++;
    if (isLinkClose2(token.content))
      state.linkLevel--;
  }
  state.pos += match2[0].length;
  return true;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max)
    return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match2 = state.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        const code4 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code4) ? fromCodePoint2(code4) : fromCodePoint2(65533);
        token.markup = match2[0];
        token.info = "entity";
      }
      state.pos += match2[0].length;
      return true;
    }
  } else {
    const match2 = state.src.slice(pos).match(NAMED_RE);
    if (match2) {
      const decoded = decodeHTML(match2[0]);
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match2[0];
          token.info = "entity";
        }
        state.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max)
    return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state) {
  let curr, last;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text3],
  ["linkify", linkify3],
  ["newline", newline],
  ["escape", escape2],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link3],
  ["image", image3],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules3.length; i++) {
    this.ruler.push(_rules3[i][0], _rules3[i][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i = 0; i < _rules22.length; i++) {
    this.ruler2.push(_rules22[i][0], _rules22[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md2, env, outTokens) {
  const state = new this.State(str, md2, env, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// node_modules/prosemirror-markdown/node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><ï½œ]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + re.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + re.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// node_modules/prosemirror-markdown/node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class2(obj) === "[object String]";
}
function isObject(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text4, pos, self) {
      const tail = text4.slice(pos);
      if (!self.re.http) {
        self.re.http = new RegExp(
          "^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path,
          "i"
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text4, pos, self) {
      const tail = text4.slice(pos);
      if (!self.re.no_http) {
        self.re.no_http = new RegExp(
          "^" + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path,
          "i"
        );
      }
      if (self.re.no_http.test(tail)) {
        if (pos >= 3 && text4[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text4[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text4, pos, self) {
      const tail = text4.slice(pos);
      if (!self.re.mailto) {
        self.re.mailto = new RegExp(
          "^" + self.re.src_email_name + "@" + self.re.src_host_strict,
          "i"
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = "";
}
function createValidator(re) {
  return function(text4, pos) {
    const tail = text4.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self) {
    self.normalize(match2);
  };
}
function compile(self) {
  const re = self.re = re_default(self.__opts__);
  const tlds3 = self.__tlds__.slice();
  self.onCompile();
  if (!self.__tlds_replaced__) {
    tlds3.push(tlds_2ch_src_re);
  }
  tlds3.push(re.src_xn);
  re.src_tlds = tlds3.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases = [];
  self.__compiled__ = {};
  function schemaError(name7, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name7 + '": ' + val);
  }
  Object.keys(self.__schemas__).forEach(function(name7) {
    const val = self.__schemas__[name7];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self.__compiled__[name7] = compiled;
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name7, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name7, val);
      }
      return;
    }
    if (isString2(val)) {
      aliases.push(name7);
      return;
    }
    schemaError(name7, val);
  });
  aliases.forEach(function(alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      return;
    }
    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });
  self.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self.__compiled__).filter(function(name7) {
    return name7.length > 0 && self.__compiled__[name7];
  }).map(escapeRE2).join("|");
  self.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self.re.schema_at_start = RegExp("^" + self.re.schema_search.source, "i");
  self.re.pretest = RegExp(
    "(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self);
}
function Match(self, shift) {
  const start = self.__index__;
  const end = self.__last_index__;
  const text4 = self.__text_cache__.slice(start, end);
  this.schema = self.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text4;
  this.text = text4;
  this.url = text4;
}
function createMatch(self, shift) {
  const match2 = new Match(self, shift);
  self.__compiled__[match2.schema].normalize(match2, self);
  return match2;
}
function LinkifyIt2(schemas, options) {
  if (!(this instanceof LinkifyIt2)) {
    return new LinkifyIt2(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt2.prototype.add = function add(schema2, definition) {
  this.__schemas__[schema2] = definition;
  compile(this);
  return this;
};
LinkifyIt2.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt2.prototype.test = function test(text4) {
  this.__text_cache__ = text4;
  this.__index__ = -1;
  if (!text4.length) {
    return false;
  }
  let m, ml, me, len, shift, next, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text4)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text4)) !== null) {
      len = this.testSchemaAt(text4, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text4.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text4.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text4.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text4.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt2.prototype.pretest = function pretest(text4) {
  return this.re.pretest.test(text4);
};
LinkifyIt2.prototype.testSchemaAt = function testSchemaAt(text4, schema2, pos) {
  if (!this.__compiled__[schema2.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema2.toLowerCase()].validate(text4, pos, this);
};
LinkifyIt2.prototype.match = function match(text4) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text4) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text4.slice(shift) : text4;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt2.prototype.matchAtStart = function matchAtStart(text4) {
  this.__text_cache__ = text4;
  this.__index__ = -1;
  if (!text4.length)
    return null;
  const m = this.re.schema_at_start.exec(text4);
  if (!m)
    return null;
  const len = this.testSchemaAt(text4, m[2], m[0].length);
  if (!len)
    return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt2.prototype.tlds = function tlds2(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt2.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt2.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt2;

// node_modules/punycode.js/punycode.es6.js
var maxInt2 = 2147483647;
var base2 = 36;
var tMin2 = 1;
var tMax2 = 26;
var skew2 = 38;
var damp2 = 700;
var initialBias2 = 72;
var initialN2 = 128;
var delimiter2 = "-";
var regexPunycode2 = /^xn--/;
var regexNonASCII2 = /[^\0-\x7F]/;
var regexSeparators2 = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors2 = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin2 = base2 - tMin2;
var floor2 = Math.floor;
var stringFromCharCode2 = String.fromCharCode;
function error2(type) {
  throw new RangeError(errors2[type]);
}
function map2(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain2(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators2, ".");
  const labels = domain.split(".");
  const encoded = map2(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode2(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode2 = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit2 = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base2;
};
var digitToBasic2 = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt2 = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor2(delta / damp2) : delta >> 1;
  delta += floor2(delta / numPoints);
  for (; delta > baseMinusTMin2 * tMax2 >> 1; k += base2) {
    delta = floor2(delta / baseMinusTMin2);
  }
  return floor2(k + (baseMinusTMin2 + 1) * delta / (delta + skew2));
};
var decode3 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN2;
  let bias = initialBias2;
  let basic = input.lastIndexOf(delimiter2);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error2("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base2; ; k += base2) {
      if (index >= inputLength) {
        error2("invalid-input");
      }
      const digit = basicToDigit2(input.charCodeAt(index++));
      if (digit >= base2) {
        error2("invalid-input");
      }
      if (digit > floor2((maxInt2 - i) / w)) {
        error2("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base2 - t;
      if (w > floor2(maxInt2 / baseMinusT)) {
        error2("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt2(i - oldi, out, oldi == 0);
    if (floor2(i / out) > maxInt2 - n) {
      error2("overflow");
    }
    n += floor2(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode3 = function(input) {
  const output = [];
  input = ucs2decode2(input);
  const inputLength = input.length;
  let n = initialN2;
  let delta = 0;
  let bias = initialBias2;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode2(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter2);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt2;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor2((maxInt2 - delta) / handledCPCountPlusOne)) {
      error2("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt2) {
        error2("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base2; ; k += base2) {
          const t = k <= bias ? tMin2 : k >= bias + tMax2 ? tMax2 : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base2 - t;
          output.push(
            stringFromCharCode2(digitToBasic2(t + qMinusT % baseMinusT, 0))
          );
          q = floor2(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode2(digitToBasic2(q, 0)));
        bias = adapt2(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode2 = function(input) {
  return mapDomain2(input, function(string) {
    return regexPunycode2.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII2 = function(input) {
  return mapDomain2(input, function(string) {
    return regexNonASCII2.test(string) ? "xn--" + encode3(string) : string;
  });
};
var punycode2 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode2,
    "encode": ucs2encode2
  },
  "decode": decode3,
  "encode": encode3,
  "toASCII": toASCII2,
  "toUnicode": toUnicode2
};
var punycode_es6_default2 = punycode2;

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// node_modules/prosemirror-markdown/node_modules/markdown-it/lib/index.mjs
var config = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default2.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format(parsed));
}
function normalizeLinkText(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default2.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self = this;
  if (isString(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name7) {
      if (presets.components[name7].rules) {
        self[name7].ruler.enableOnly(presets.components[name7].rules);
      }
      if (presets.components[name7].rules2) {
        self[name7].ruler2.enableOnly(presets.components[name7].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name7) {
    return result.indexOf(name7) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name7) {
    return result.indexOf(name7) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib_default = MarkdownIt;

// node_modules/prosemirror-markdown/dist/index.js
var schema = new Schema({
  nodes: {
    doc: {
      content: "block+"
    },
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return ["p", 0];
      }
    },
    blockquote: {
      content: "block+",
      group: "block",
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return ["blockquote", 0];
      }
    },
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return ["div", ["hr"]];
      }
    },
    heading: {
      attrs: { level: { default: 1 } },
      content: "(text | image)*",
      group: "block",
      defining: true,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } }
      ],
      toDOM(node) {
        return ["h" + node.attrs.level, 0];
      }
    },
    code_block: {
      content: "text*",
      group: "block",
      code: true,
      defining: true,
      marks: "",
      attrs: { params: { default: "" } },
      parseDOM: [{ tag: "pre", preserveWhitespace: "full", getAttrs: (node) => ({ params: node.getAttribute("data-params") || "" }) }],
      toDOM(node) {
        return ["pre", node.attrs.params ? { "data-params": node.attrs.params } : {}, ["code", 0]];
      }
    },
    ordered_list: {
      content: "list_item+",
      group: "block",
      attrs: { order: { default: 1 }, tight: { default: false } },
      parseDOM: [{ tag: "ol", getAttrs(dom) {
        return {
          order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1,
          tight: dom.hasAttribute("data-tight")
        };
      } }],
      toDOM(node) {
        return ["ol", {
          start: node.attrs.order == 1 ? null : node.attrs.order,
          "data-tight": node.attrs.tight ? "true" : null
        }, 0];
      }
    },
    bullet_list: {
      content: "list_item+",
      group: "block",
      attrs: { tight: { default: false } },
      parseDOM: [{ tag: "ul", getAttrs: (dom) => ({ tight: dom.hasAttribute("data-tight") }) }],
      toDOM(node) {
        return ["ul", { "data-tight": node.attrs.tight ? "true" : null }, 0];
      }
    },
    list_item: {
      content: "block+",
      defining: true,
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return ["li", 0];
      }
    },
    text: {
      group: "inline"
    },
    image: {
      inline: true,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null }
      },
      group: "inline",
      draggable: true,
      parseDOM: [{ tag: "img[src]", getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt")
        };
      } }],
      toDOM(node) {
        return ["img", node.attrs];
      }
    },
    hard_break: {
      inline: true,
      group: "inline",
      selectable: false,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return ["br"];
      }
    }
  },
  marks: {
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (m) => m.type.name == "em" }
      ],
      toDOM() {
        return ["em"];
      }
    },
    strong: {
      parseDOM: [
        { tag: "strong" },
        { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (m) => m.type.name == "strong" },
        { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
      ],
      toDOM() {
        return ["strong"];
      }
    },
    link: {
      attrs: {
        href: {},
        title: { default: null }
      },
      inclusive: false,
      parseDOM: [{ tag: "a[href]", getAttrs(dom) {
        return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
      } }],
      toDOM(node) {
        return ["a", node.attrs];
      }
    },
    code: {
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return ["code"];
      }
    }
  }
});
function maybeMerge(a, b) {
  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks))
    return a.withText(a.text + b.text);
}
var MarkdownParseState = class {
  constructor(schema2, tokenHandlers2) {
    this.schema = schema2;
    this.tokenHandlers = tokenHandlers2;
    this.stack = [{ type: schema2.topNodeType, attrs: null, content: [], marks: Mark.none }];
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(elt) {
    if (this.stack.length)
      this.top().content.push(elt);
  }
  // Adds the given text to the current position in the document,
  // using the current marks as styling.
  addText(text4) {
    if (!text4)
      return;
    let top = this.top(), nodes = top.content, last = nodes[nodes.length - 1];
    let node = this.schema.text(text4, top.marks), merged;
    if (last && (merged = maybeMerge(last, node)))
      nodes[nodes.length - 1] = merged;
    else
      nodes.push(node);
  }
  // Adds the given mark to the set of active marks.
  openMark(mark) {
    let top = this.top();
    top.marks = mark.addToSet(top.marks);
  }
  // Removes the given mark from the set of active marks.
  closeMark(mark) {
    let top = this.top();
    top.marks = mark.removeFromSet(top.marks);
  }
  parseTokens(toks) {
    for (let i = 0; i < toks.length; i++) {
      let tok = toks[i];
      let handler = this.tokenHandlers[tok.type];
      if (!handler)
        throw new Error("Token type `" + tok.type + "` not supported by Markdown parser");
      handler(this, tok, toks, i);
    }
  }
  // Add a node at the current position.
  addNode(type, attrs10, content) {
    let top = this.top();
    let node = type.createAndFill(attrs10, content, top ? top.marks : []);
    if (!node)
      return null;
    this.push(node);
    return node;
  }
  // Wrap subsequent content in a node of the given type.
  openNode(type, attrs10) {
    this.stack.push({ type, attrs: attrs10, content: [], marks: Mark.none });
  }
  // Close and return the node that is currently on top of the stack.
  closeNode() {
    let info = this.stack.pop();
    return this.addNode(info.type, info.attrs, info.content);
  }
};
function attrs(spec, token, tokens, i) {
  if (spec.getAttrs)
    return spec.getAttrs(token, tokens, i);
  else if (spec.attrs instanceof Function)
    return spec.attrs(token);
  else
    return spec.attrs;
}
function noCloseToken(spec, type) {
  return spec.noCloseToken || type == "code_inline" || type == "code_block" || type == "fence";
}
function withoutTrailingNewline(str) {
  return str[str.length - 1] == "\n" ? str.slice(0, str.length - 1) : str;
}
function noOp() {
}
function tokenHandlers(schema2, tokens) {
  let handlers = /* @__PURE__ */ Object.create(null);
  for (let type in tokens) {
    let spec = tokens[type];
    if (spec.block) {
      let nodeType = schema2.nodeType(spec.block);
      if (noCloseToken(spec, type)) {
        handlers[type] = (state, tok, tokens2, i) => {
          state.openNode(nodeType, attrs(spec, tok, tokens2, i));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeNode();
        };
      } else {
        handlers[type + "_open"] = (state, tok, tokens2, i) => state.openNode(nodeType, attrs(spec, tok, tokens2, i));
        handlers[type + "_close"] = (state) => state.closeNode();
      }
    } else if (spec.node) {
      let nodeType = schema2.nodeType(spec.node);
      handlers[type] = (state, tok, tokens2, i) => state.addNode(nodeType, attrs(spec, tok, tokens2, i));
    } else if (spec.mark) {
      let markType = schema2.marks[spec.mark];
      if (noCloseToken(spec, type)) {
        handlers[type] = (state, tok, tokens2, i) => {
          state.openMark(markType.create(attrs(spec, tok, tokens2, i)));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeMark(markType);
        };
      } else {
        handlers[type + "_open"] = (state, tok, tokens2, i) => state.openMark(markType.create(attrs(spec, tok, tokens2, i)));
        handlers[type + "_close"] = (state) => state.closeMark(markType);
      }
    } else if (spec.ignore) {
      if (noCloseToken(spec, type)) {
        handlers[type] = noOp;
      } else {
        handlers[type + "_open"] = noOp;
        handlers[type + "_close"] = noOp;
      }
    } else {
      throw new RangeError("Unrecognized parsing spec " + JSON.stringify(spec));
    }
  }
  handlers.text = (state, tok) => state.addText(tok.content);
  handlers.inline = (state, tok) => state.parseTokens(tok.children);
  handlers.softbreak = handlers.softbreak || ((state) => state.addText(" "));
  return handlers;
}
var MarkdownParser = class {
  /**
  Create a parser with the given configuration. You can configure
  the markdown-it parser to parse the dialect you want, and provide
  a description of the ProseMirror entities those tokens map to in
  the `tokens` object, which maps token names to descriptions of
  what to do with them. Such a description is an object, and may
  have the following properties:
  */
  constructor(schema2, tokenizer, tokens) {
    this.schema = schema2;
    this.tokenizer = tokenizer;
    this.tokens = tokens;
    this.tokenHandlers = tokenHandlers(schema2, tokens);
  }
  /**
  Parse a string as [CommonMark](http://commonmark.org/) markup,
  and create a ProseMirror document as prescribed by this parser's
  rules.
  
  The second argument, when given, is passed through to the
  [Markdown
  parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).
  */
  parse(text4, markdownEnv = {}) {
    let state = new MarkdownParseState(this.schema, this.tokenHandlers), doc3;
    state.parseTokens(this.tokenizer.parse(text4, markdownEnv));
    do {
      doc3 = state.closeNode();
    } while (state.stack.length);
    return doc3 || this.schema.topNodeType.createAndFill();
  }
};
function listIsTight(tokens, i) {
  while (++i < tokens.length)
    if (tokens[i].type != "list_item_open")
      return tokens[i].hidden;
  return false;
}
var defaultMarkdownParser = new MarkdownParser(schema, lib_default("commonmark", { html: false }), {
  blockquote: { block: "blockquote" },
  paragraph: { block: "paragraph" },
  list_item: { block: "list_item" },
  bullet_list: { block: "bullet_list", getAttrs: (_, tokens, i) => ({ tight: listIsTight(tokens, i) }) },
  ordered_list: { block: "ordered_list", getAttrs: (tok, tokens, i) => ({
    order: +tok.attrGet("start") || 1,
    tight: listIsTight(tokens, i)
  }) },
  heading: { block: "heading", getAttrs: (tok) => ({ level: +tok.tag.slice(1) }) },
  code_block: { block: "code_block", noCloseToken: true },
  fence: { block: "code_block", getAttrs: (tok) => ({ params: tok.info || "" }), noCloseToken: true },
  hr: { node: "horizontal_rule" },
  image: { node: "image", getAttrs: (tok) => ({
    src: tok.attrGet("src"),
    title: tok.attrGet("title") || null,
    alt: tok.children[0] && tok.children[0].content || null
  }) },
  hardbreak: { node: "hard_break" },
  em: { mark: "em" },
  strong: { mark: "strong" },
  link: { mark: "link", getAttrs: (tok) => ({
    href: tok.attrGet("href"),
    title: tok.attrGet("title") || null
  }) },
  code_inline: { mark: "code", noCloseToken: true }
});
var blankMark = { open: "", close: "", mixable: true };
var MarkdownSerializer = class {
  /**
  Construct a serializer with the given configuration. The `nodes`
  object should map node names in a given schema to function that
  take a serializer state and such a node, and serialize the node.
  */
  constructor(nodes, marks, options = {}) {
    this.nodes = nodes;
    this.marks = marks;
    this.options = options;
  }
  /**
  Serialize the content of the given node to
  [CommonMark](http://commonmark.org/).
  */
  serialize(content, options = {}) {
    options = Object.assign({}, this.options, options);
    let state = new MarkdownSerializerState(this.nodes, this.marks, options);
    state.renderContent(content);
    return state.out;
  }
};
var defaultMarkdownSerializer = new MarkdownSerializer({
  blockquote(state, node) {
    state.wrapBlock("> ", null, node, () => state.renderContent(node));
  },
  code_block(state, node) {
    const backticks = node.textContent.match(/`{3,}/gm);
    const fence2 = backticks ? backticks.sort().slice(-1)[0] + "`" : "```";
    state.write(fence2 + (node.attrs.params || "") + "\n");
    state.text(node.textContent, false);
    state.write("\n");
    state.write(fence2);
    state.closeBlock(node);
  },
  heading(state, node) {
    state.write(state.repeat("#", node.attrs.level) + " ");
    state.renderInline(node, false);
    state.closeBlock(node);
  },
  horizontal_rule(state, node) {
    state.write(node.attrs.markup || "---");
    state.closeBlock(node);
  },
  bullet_list(state, node) {
    state.renderList(node, "  ", () => (node.attrs.bullet || "*") + " ");
  },
  ordered_list(state, node) {
    let start = node.attrs.order || 1;
    let maxW = String(start + node.childCount - 1).length;
    let space = state.repeat(" ", maxW + 2);
    state.renderList(node, space, (i) => {
      let nStr = String(start + i);
      return state.repeat(" ", maxW - nStr.length) + nStr + ". ";
    });
  },
  list_item(state, node) {
    state.renderContent(node);
  },
  paragraph(state, node) {
    state.renderInline(node);
    state.closeBlock(node);
  },
  image(state, node) {
    state.write("![" + state.esc(node.attrs.alt || "") + "](" + node.attrs.src.replace(/[\(\)]/g, "\\$&") + (node.attrs.title ? ' "' + node.attrs.title.replace(/"/g, '\\"') + '"' : "") + ")");
  },
  hard_break(state, node, parent, index) {
    for (let i = index + 1; i < parent.childCount; i++)
      if (parent.child(i).type != node.type) {
        state.write("\\\n");
        return;
      }
  },
  text(state, node) {
    state.text(node.text, !state.inAutolink);
  }
}, {
  em: { open: "*", close: "*", mixable: true, expelEnclosingWhitespace: true },
  strong: { open: "**", close: "**", mixable: true, expelEnclosingWhitespace: true },
  link: {
    open(state, mark, parent, index) {
      state.inAutolink = isPlainURL(mark, parent, index);
      return state.inAutolink ? "<" : "[";
    },
    close(state, mark, parent, index) {
      let { inAutolink } = state;
      state.inAutolink = void 0;
      return inAutolink ? ">" : "](" + mark.attrs.href.replace(/[\(\)"]/g, "\\$&") + (mark.attrs.title ? ` "${mark.attrs.title.replace(/"/g, '\\"')}"` : "") + ")";
    },
    mixable: true
  },
  code: {
    open(_state, _mark, parent, index) {
      return backticksFor(parent.child(index), -1);
    },
    close(_state, _mark, parent, index) {
      return backticksFor(parent.child(index - 1), 1);
    },
    escape: false
  }
});
function backticksFor(node, side) {
  let ticks = /`+/g, m, len = 0;
  if (node.isText)
    while (m = ticks.exec(node.text))
      len = Math.max(len, m[0].length);
  let result = len > 0 && side > 0 ? " `" : "`";
  for (let i = 0; i < len; i++)
    result += "`";
  if (len > 0 && side < 0)
    result += " ";
  return result;
}
function isPlainURL(link4, parent, index) {
  if (link4.attrs.title || !/^\w+:/.test(link4.attrs.href))
    return false;
  let content = parent.child(index);
  if (!content.isText || content.text != link4.attrs.href || content.marks[content.marks.length - 1] != link4)
    return false;
  return index == parent.childCount - 1 || !link4.isInSet(parent.child(index + 1).marks);
}
var MarkdownSerializerState = class {
  /**
  @internal
  */
  constructor(nodes, marks, options) {
    this.nodes = nodes;
    this.marks = marks;
    this.options = options;
    this.delim = "";
    this.out = "";
    this.closed = null;
    this.inAutolink = void 0;
    this.atBlockStart = false;
    this.inTightList = false;
    if (typeof this.options.tightLists == "undefined")
      this.options.tightLists = false;
    if (typeof this.options.hardBreakNodeName == "undefined")
      this.options.hardBreakNodeName = "hard_break";
  }
  /**
  @internal
  */
  flushClose(size = 2) {
    if (this.closed) {
      if (!this.atBlank())
        this.out += "\n";
      if (size > 1) {
        let delimMin = this.delim;
        let trim = /\s+$/.exec(delimMin);
        if (trim)
          delimMin = delimMin.slice(0, delimMin.length - trim[0].length);
        for (let i = 1; i < size; i++)
          this.out += delimMin + "\n";
      }
      this.closed = null;
    }
  }
  /**
  @internal
  */
  getMark(name7) {
    let info = this.marks[name7];
    if (!info) {
      if (this.options.strict !== false)
        throw new Error(`Mark type \`${name7}\` not supported by Markdown renderer`);
      info = blankMark;
    }
    return info;
  }
  /**
  Render a block, prefixing each line with `delim`, and the first
  line in `firstDelim`. `node` should be the node that is closed at
  the end of the block, and `f` is a function that renders the
  content of the block.
  */
  wrapBlock(delim, firstDelim, node, f) {
    let old = this.delim;
    this.write(firstDelim != null ? firstDelim : delim);
    this.delim += delim;
    f();
    this.delim = old;
    this.closeBlock(node);
  }
  /**
  @internal
  */
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  /**
  Ensure the current content ends with a newline.
  */
  ensureNewLine() {
    if (!this.atBlank())
      this.out += "\n";
  }
  /**
  Prepare the state for writing output (closing closed paragraphs,
  adding delimiters, and so on), and then optionally add content
  (unescaped) to the output.
  */
  write(content) {
    this.flushClose();
    if (this.delim && this.atBlank())
      this.out += this.delim;
    if (content)
      this.out += content;
  }
  /**
  Close the block for the given node.
  */
  closeBlock(node) {
    this.closed = node;
  }
  /**
  Add the given text to the document. When escape is not `false`,
  it will be escaped.
  */
  text(text4, escape3 = true) {
    let lines = text4.split("\n");
    for (let i = 0; i < lines.length; i++) {
      this.write();
      if (!escape3 && lines[i][0] == "[" && /(^|[^\\])\!$/.test(this.out))
        this.out = this.out.slice(0, this.out.length - 1) + "\\!";
      this.out += escape3 ? this.esc(lines[i], this.atBlockStart) : lines[i];
      if (i != lines.length - 1)
        this.out += "\n";
    }
  }
  /**
  Render the given node as a block.
  */
  render(node, parent, index) {
    if (this.nodes[node.type.name]) {
      this.nodes[node.type.name](this, node, parent, index);
    } else {
      if (this.options.strict !== false) {
        throw new Error("Token type `" + node.type.name + "` not supported by Markdown renderer");
      } else if (!node.type.isLeaf) {
        if (node.type.inlineContent)
          this.renderInline(node);
        else
          this.renderContent(node);
        if (node.isBlock)
          this.closeBlock(node);
      }
    }
  }
  /**
  Render the contents of `parent` as block nodes.
  */
  renderContent(parent) {
    parent.forEach((node, _, i) => this.render(node, parent, i));
  }
  /**
  Render the contents of `parent` as inline content.
  */
  renderInline(parent, fromBlockStart = true) {
    this.atBlockStart = fromBlockStart;
    let active = [], trailing = "";
    let progress = (node, offset, index) => {
      let marks = node ? node.marks : [];
      if (node && node.type.name === this.options.hardBreakNodeName)
        marks = marks.filter((m) => {
          if (index + 1 == parent.childCount)
            return false;
          let next = parent.child(index + 1);
          return m.isInSet(next.marks) && (!next.isText || /\S/.test(next.text));
        });
      let leading = trailing;
      trailing = "";
      if (node && node.isText && marks.some((mark) => {
        let info = this.getMark(mark.type.name);
        return info && info.expelEnclosingWhitespace && !mark.isInSet(active);
      })) {
        let [_, lead, rest] = /^(\s*)(.*)$/m.exec(node.text);
        if (lead) {
          leading += lead;
          node = rest ? node.withText(rest) : null;
          if (!node)
            marks = active;
        }
      }
      if (node && node.isText && marks.some((mark) => {
        let info = this.getMark(mark.type.name);
        return info && info.expelEnclosingWhitespace && (index == parent.childCount - 1 || !mark.isInSet(parent.child(index + 1).marks));
      })) {
        let [_, rest, trail] = /^(.*?)(\s*)$/m.exec(node.text);
        if (trail) {
          trailing = trail;
          node = rest ? node.withText(rest) : null;
          if (!node)
            marks = active;
        }
      }
      let inner = marks.length ? marks[marks.length - 1] : null;
      let noEsc = inner && this.getMark(inner.type.name).escape === false;
      let len = marks.length - (noEsc ? 1 : 0);
      outer:
        for (let i = 0; i < len; i++) {
          let mark = marks[i];
          if (!this.getMark(mark.type.name).mixable)
            break;
          for (let j = 0; j < active.length; j++) {
            let other = active[j];
            if (!this.getMark(other.type.name).mixable)
              break;
            if (mark.eq(other)) {
              if (i > j)
                marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));
              else if (j > i)
                marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));
              continue outer;
            }
          }
        }
      let keep = 0;
      while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep]))
        ++keep;
      while (keep < active.length)
        this.text(this.markString(active.pop(), false, parent, index), false);
      if (leading)
        this.text(leading);
      if (node) {
        while (active.length < len) {
          let add2 = marks[active.length];
          active.push(add2);
          this.text(this.markString(add2, true, parent, index), false);
          this.atBlockStart = false;
        }
        if (noEsc && node.isText)
          this.text(this.markString(inner, true, parent, index) + node.text + this.markString(inner, false, parent, index + 1), false);
        else
          this.render(node, parent, index);
        this.atBlockStart = false;
      }
      if ((node === null || node === void 0 ? void 0 : node.isText) && node.nodeSize > 0) {
        this.atBlockStart = false;
      }
    };
    parent.forEach(progress);
    progress(null, 0, parent.childCount);
    this.atBlockStart = false;
  }
  /**
  Render a node's content as a list. `delim` should be the extra
  indentation added to all lines except the first in an item,
  `firstDelim` is a function going from an item index to a
  delimiter for the first line of the item.
  */
  renderList(node, delim, firstDelim) {
    if (this.closed && this.closed.type == node.type)
      this.flushClose(3);
    else if (this.inTightList)
      this.flushClose(1);
    let isTight = typeof node.attrs.tight != "undefined" ? node.attrs.tight : this.options.tightLists;
    let prevTight = this.inTightList;
    this.inTightList = isTight;
    node.forEach((child, _, i) => {
      if (i && isTight)
        this.flushClose(1);
      this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));
    });
    this.inTightList = prevTight;
  }
  /**
  Escape the given string so that it can safely appear in Markdown
  content. If `startOfLine` is true, also escape characters that
  have special meaning only at the start of the line.
  */
  esc(str, startOfLine = false) {
    str = str.replace(/[`*\\~\[\]_]/g, (m, i) => m == "_" && i > 0 && i + 1 < str.length && str[i - 1].match(/\w/) && str[i + 1].match(/\w/) ? m : "\\" + m);
    if (startOfLine)
      str = str.replace(/^(\+[ ]|[\-*>])/, "\\$&").replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3").replace(/^(\s*\d+)\.\s/, "$1\\. ");
    if (this.options.escapeExtraCharacters)
      str = str.replace(this.options.escapeExtraCharacters, "\\$&");
    return str;
  }
  /**
  @internal
  */
  quote(str) {
    let wrap = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()";
    return wrap[0] + str + wrap[1];
  }
  /**
  Repeat the given string `n` times.
  */
  repeat(str, n) {
    let out = "";
    for (let i = 0; i < n; i++)
      out += str;
    return out;
  }
  /**
  Get the markdown string for a given opening or closing mark.
  */
  markString(mark, open, parent, index) {
    let info = this.getMark(mark.type.name);
    let value = open ? info.open : info.close;
    return typeof value == "string" ? value : value(this, mark, parent, index);
  }
  /**
  Get leading and trailing whitespace from a string. Values of
  leading or trailing property of the return object will be undefined
  if there is no match.
  */
  getEnclosingWhitespace(text4) {
    return {
      leading: (text4.match(/^(\s+)/) || [void 0])[0],
      trailing: (text4.match(/(\s+)$/) || [void 0])[0]
    };
  }
};

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/@atlaskit/editor-markdown-transformer/dist/esm/media.js
function createRule() {
  var regx = /!\[([^\]]*)\]\(([^)]*?)\s*(?:"([^")]*)"\s*)?\)/g;
  var validParentTokens = ["th_open", "td_open", "list_item_open"];
  return function media3(State) {
    var getUrl = function getUrl2(str) {
      var res = State.md.helpers.parseLinkDestination(str, str.indexOf("(") + 1, str.length);
      if (res.ok) {
        var href = State.md.normalizeLink(res.str);
        if (State.md.validateLink(href)) {
          return href;
        }
      }
      return "";
    };
    var createMediaTokens = function createMediaTokens2(url) {
      var alt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var mediaSingleOpen = new State.Token("media_single_open", "", 1);
      var media4 = new State.Token("media", "", 0);
      media4.attrs = [["url", getUrl(url)], ["type", "external"], ["alt", alt]];
      var mediaSingleClose = new State.Token("media_single_close", "", -1);
      return [mediaSingleOpen, media4, mediaSingleClose];
    };
    var createInlineTokens = function createInlineTokens2(str, openingTokens, closingTokens) {
      if (!str || str.length === 0) {
        return [];
      }
      var inlineBefore = new State.Token("inline", "", 1);
      inlineBefore.content = str;
      inlineBefore.children = [];
      return [].concat(_toConsumableArray(openingTokens), [inlineBefore], _toConsumableArray(closingTokens));
    };
    var processedTokens = [];
    var newTokens = State.tokens.reduce(function(tokens, token, i, arr) {
      var matchAll = Array.from(token.content.matchAll(regx));
      if (token.type === "inline" && matchAll.length) {
        var openingTokens = [];
        var cursor = i - 1;
        var previousToken = arr[cursor];
        var subTree = [];
        while (previousToken && previousToken.level > 0 && validParentTokens.indexOf(previousToken.type) === -1) {
          openingTokens.unshift(previousToken);
          cursor--;
          previousToken = arr[cursor];
        }
        if (validParentTokens.indexOf(previousToken.type) === -1) {
          openingTokens.unshift(previousToken);
        } else {
          cursor++;
        }
        var closingTokens = openingTokens.map(function(token2) {
          return new State.Token(token2.type.replace("_open", "_close"), token2.tag, -1);
        }).reverse();
        var inlineContentStack = token.content;
        matchAll.forEach(function(match2, j) {
          var _match = _slicedToArray(match2, 3), matchString = _match[0], alt = _match[1], url = _match[2];
          var start = inlineContentStack.indexOf(matchString);
          var contentBefore = inlineContentStack.substr(0, start);
          inlineContentStack = inlineContentStack.substr(start + matchString.length);
          subTree = [].concat(_toConsumableArray(subTree), _toConsumableArray(createInlineTokens(contentBefore, openingTokens, closingTokens)), _toConsumableArray(createMediaTokens(url, alt)));
        });
        if (inlineContentStack.length) {
          subTree = [].concat(_toConsumableArray(subTree), _toConsumableArray(createInlineTokens(inlineContentStack, openingTokens, closingTokens)));
        }
        processedTokens = [].concat(_toConsumableArray(processedTokens), _toConsumableArray(closingTokens.map(function(c) {
          return c.type;
        })));
        tokens = [].concat(_toConsumableArray(tokens.slice(0, cursor)), _toConsumableArray(subTree));
      } else if (processedTokens.indexOf(token.type) !== -1) {
        processedTokens.splice(processedTokens.indexOf(token.type), 1);
      } else {
        tokens.push(token);
      }
      return tokens;
    }, []);
    State.tokens = newTokens;
    return true;
  };
}
var markdownItMedia = function markdownItMedia2(md2) {
  md2.core.ruler.before("inline", "media", createRule());
};

// node_modules/@atlaskit/editor-markdown-transformer/dist/esm/index.js
function filterMdToPmSchemaMapping(schema2, map3) {
  return Object.keys(map3).reduce(function(newMap, key) {
    var value = map3[key];
    var block2 = value.block || value.node;
    var mark = value.mark;
    if (block2 && schema2.nodes[block2] || mark && schema2.marks[mark]) {
      newMap[key] = value;
    }
    return newMap;
  }, {});
}
var pmSchemaToMdMapping = {
  nodes: {
    blockquote: "blockquote",
    paragraph: "paragraph",
    rule: "hr",
    // lheading (---, ===)
    heading: ["heading", "lheading"],
    codeBlock: ["code", "fence"],
    listItem: "list",
    image: "image"
  },
  marks: {
    em: "emphasis",
    strong: "text",
    link: ["link", "autolink", "reference", "linkify"],
    strike: "strikethrough",
    code: "backticks"
  }
};
var mdToPmMapping = {
  blockquote: {
    block: "blockquote"
  },
  paragraph: {
    block: "paragraph"
  },
  em: {
    mark: "em"
  },
  strong: {
    mark: "strong"
  },
  link: {
    mark: "link",
    attrs: function attrs2(tok) {
      return {
        href: tok.attrGet("href"),
        title: tok.attrGet("title") || null
      };
    }
  },
  hr: {
    node: "rule"
  },
  heading: {
    block: "heading",
    attrs: function attrs3(tok) {
      return {
        level: +tok.tag.slice(1)
      };
    }
  },
  softbreak: {
    node: "hardBreak"
  },
  hardbreak: {
    node: "hardBreak"
  },
  code_block: {
    block: "codeBlock"
  },
  list_item: {
    block: "listItem"
  },
  bullet_list: {
    block: "bulletList"
  },
  ordered_list: {
    block: "orderedList",
    attrs: function attrs4(tok) {
      return {
        order: typeof tok.attrGet("start") === "number" ? tok.attrGet("start") : 1
      };
    }
  },
  code_inline: {
    mark: "code"
  },
  fence: {
    block: "codeBlock",
    // we trim any whitespaces around language definition
    attrs: function attrs5(tok) {
      return {
        language: tok.info && tok.info.trim() || null
      };
    }
  },
  media_single: {
    block: "mediaSingle",
    attrs: function attrs6() {
      return {};
    }
  },
  media: {
    node: "media",
    attrs: function attrs7(tok) {
      return {
        url: tok.attrGet("url"),
        alt: tok.attrGet("alt"),
        type: "external"
      };
    }
  },
  emoji: {
    node: "emoji",
    attrs: function attrs8(tok) {
      return {
        shortName: ":".concat(tok.markup, ":"),
        text: tok.content
      };
    }
  },
  table: {
    block: "table"
  },
  tr: {
    block: "tableRow"
  },
  th: {
    block: "tableHeader"
  },
  td: {
    block: "tableCell"
  },
  s: {
    mark: "strike"
  },
  task_list: {
    block: "taskList"
  },
  task_item: {
    block: "taskItem",
    attrs: function attrs9(tok) {
      return {
        state: tok.meta
      };
    }
  }
};
var md = (0, import_markdown_it2.default)("zero", {
  html: false
});
md.enable([
  // Process html entity - &#123;, &#xAF;, &quot;, ...
  "entity",
  // Process escaped chars and hardbreaks
  "escape"
]);
var MarkdownTransformer = function() {
  function MarkdownTransformer2() {
    var schema2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultSchema;
    var tokenizer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : md;
    _classCallCheck(this, MarkdownTransformer2);
    ["nodes", "marks"].forEach(function(key) {
      for (var idx in pmSchemaToMdMapping[key]) {
        if (schema2[key][idx]) {
          tokenizer.enable(pmSchemaToMdMapping[key][idx]);
        }
      }
    });
    if (schema2.nodes.table) {
      tokenizer.use(markdownItTable);
    }
    if (schema2.nodes.media && schema2.nodes.mediaSingle) {
      tokenizer.use(markdownItMedia);
    }
    this.markdownParser = new MarkdownParser(schema2, tokenizer, filterMdToPmSchemaMapping(schema2, mdToPmMapping));
  }
  _createClass(MarkdownTransformer2, [{
    key: "encode",
    value: function encode4(_node) {
      throw new Error("This is not implemented yet");
    }
  }, {
    key: "parse",
    value: function parse(content) {
      return this.markdownParser.parse(content);
    }
  }]);
  return MarkdownTransformer2;
}();
export {
  MarkdownTransformer
};
//# sourceMappingURL=@atlaskit_editor-markdown-transformer.js.map
