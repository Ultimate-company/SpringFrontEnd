"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaStage = exports.JSONTransformer = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _isEqual = _interopRequireDefault(require("lodash/isEqual"));
var _adfSchema = require("@atlaskit/adf-schema");
var _schemaDefault = require("@atlaskit/adf-schema/schema-default");
var _markOverrideRules = require("./markOverrideRules");
var _sanitizeNode = require("./sanitize/sanitize-node");
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof3(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof3(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof3(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var SchemaStage = exports.SchemaStage = /*#__PURE__*/function (SchemaStage) {
  SchemaStage["FINAL"] = "final";
  SchemaStage["STAGE_0"] = "stage0";
  return SchemaStage;
}({});
var isType = function isType(type) {
  return function (node) {
    return node.type.name === type;
  };
};
var isCodeBlock = isType('codeBlock');
var isMediaNode = isType('media');
var isMediaInline = isType('mediaInline');
var isMediaSingleNode = isType('mediaSingle');
var isMentionNode = isType('mention');
var isParagraph = isType('paragraph');
var isHeading = isType('heading');
var isTable = isType('table');
var isTableCell = isType('tableCell');
var isTableHeader = isType('tableHeader');
var isLinkMark = isType('link');
var isUnsupportedMark = isType('unsupportedMark');
var isUnsupportedNodeAttributeMark = isType('unsupportedNodeAttribute');
var isExpand = isType('expand');
var isNestedExpand = isType('nestedExpand');
var isUnsupportedNode = function isUnsupportedNode(node) {
  return isType('unsupportedBlock')(node) || isType('unsupportedInline')(node);
};
var isDataConsumer = isType('dataConsumer');
var isFragmentMark = isType('fragment');
var filterNull = function filterNull(subject) {
  var output = _objectSpread({}, subject);
  for (var key in output) {
    var current = output[key];
    if (current === null) {
      var _output = output,
        unusedKey = _output[key],
        filteredObj = (0, _objectWithoutProperties2.default)(_output, [key].map(_toPropertyKey));
      output = filteredObj;
    } else if ((0, _typeof2.default)(current) === 'object' && !Array.isArray(current)) {
      output[key] = filterNull(current);
    }
  }
  return output;
};
var createDocFromContent = function createDocFromContent(content) {
  return {
    version: 1,
    type: 'doc',
    content: content || []
  };
};
var emptyDoc = createDocFromContent([{
  type: 'paragraph',
  content: []
}]);
var toJSON = function toJSON(node) {
  var obj = {
    type: node.type.name
  };
  if (isUnsupportedNode(node)) {
    return node.attrs.originalValue;
  } else if (isMediaNode(node)) {
    obj.attrs = (0, _adfSchema.mediaToJSON)(node).attrs;
  } else if (isMediaSingleNode(node)) {
    obj.attrs = (0, _adfSchema.mediaSingleToJSON)(node).attrs;
  } else if (isMediaInline(node)) {
    obj.attrs = (0, _adfSchema.mediaToJSON)(node).attrs;
  } else if (isMentionNode(node)) {
    obj.attrs = (0, _adfSchema.mentionToJSON)(node).attrs;
  } else if (isCodeBlock(node)) {
    obj.attrs = (0, _adfSchema.codeBlockToJSON)(node).attrs;
  } else if (isTable(node)) {
    obj.attrs = (0, _adfSchema.tableToJSON)(node).attrs;
  } else if (isTableCell(node)) {
    obj.attrs = (0, _adfSchema.toJSONTableCell)(node).attrs;
  } else if (isTableHeader(node)) {
    obj.attrs = (0, _adfSchema.toJSONTableHeader)(node).attrs;
  } else if (isExpand(node) || isNestedExpand(node)) {
    obj.attrs = (0, _adfSchema.expandToJSON)(node).attrs;
  } else if (node.attrs && Object.keys(node.attrs).length) {
    obj.attrs = node.attrs;
  }
  if (obj.attrs) {
    obj.attrs = filterNull(obj.attrs);
  }

  // Remove the attrs property if it's empty, this is currently limited to paragraph nodes.
  if (isParagraph(node) && obj.attrs && !Object.keys(obj.attrs).length) {
    delete obj.attrs;
  }
  if (node.isText) {
    obj.text = node.textContent;
  } else {
    node.content.forEach(function (child) {
      obj.content = obj.content || [];
      obj.content.push(toJSON(child));
    });
  }
  if (isParagraph(node) || isHeading(node)) {
    obj.content = obj.content || [];
  }
  if (node.marks.length) {
    // Run any custom mark serialisers
    var parsedMarks = node.marks.map(function (mark) {
      if (isUnsupportedMark(mark)) {
        return canOverrideMark(mark, node.marks) ? null : mark.attrs.originalValue;
      } else if (isUnsupportedNodeAttributeMark(mark)) {
        return null;
      } else if (isLinkMark(mark)) {
        return (0, _adfSchema.linkToJSON)(mark);
      } else if (isDataConsumer(mark)) {
        var _serialised$attrs$sou;
        var serialised = (0, _adfSchema.dataConsumerToJSON)(mark);
        return !serialised.attrs.sources || ((_serialised$attrs$sou = serialised.attrs.sources) === null || _serialised$attrs$sou === void 0 ? void 0 : _serialised$attrs$sou.length) === 0 ? null : serialised;
      } else if (isFragmentMark(mark)) {
        var fragmentMark = (0, _adfSchema.fragmentToJSON)(mark);
        if (!fragmentMark.attrs.localId) {
          return null;
        }
        return fragmentMark;
      } else {
        return mark.toJSON();
      }
    }).filter(function (maybeMark) {
      return maybeMark !== null;
    });

    // Only set if we have a non-empty array, otherwise explicitly undefine it (as we only run this path if `node.marks.length`)
    obj.marks = (parsedMarks === null || parsedMarks === void 0 ? void 0 : parsedMarks.length) > 0 ? parsedMarks : undefined;
    var nodeAttributeMark = node.marks.find(isUnsupportedNodeAttributeMark);
    if (nodeAttributeMark && nodeAttributeMark.attrs.type.nodeType === obj.type) {
      obj.attrs = _objectSpread({}, getUnwrappedNodeAttributes(node, nodeAttributeMark, obj));
    }
  }
  return obj;
};
var canOverrideMark = function canOverrideMark(mark, existingMarks) {
  if (existingMarks.some(function (e) {
    return mark.attrs.originalValue.type === e.type.name;
  })) {
    return (0, _markOverrideRules.markOverrideRuleFor)(mark.attrs.originalValue.type).canOverrideUnsupportedMark();
  }
  return false;
};
var getUnwrappedNodeAttributes = function getUnwrappedNodeAttributes(node, mark, obj) {
  var nodeAttributes = node.type.spec.attrs;
  var attributes = _objectSpread(_objectSpread({}, mark.attrs.unsupported), obj.attrs);
  for (var key in obj.attrs) {
    if (obj.attrs.hasOwnProperty(key)) {
      var attribute = nodeAttributes ? nodeAttributes[key] : null;
      if (attribute) {
        if (attribute.default === node.attrs[key] && mark.attrs.unsupported[key]) {
          return _objectSpread(_objectSpread({}, attributes), {}, (0, _defineProperty2.default)({}, key, mark.attrs.unsupported[key]));
        }
      }
    }
  }
  return attributes;
};
var JSONTransformer = exports.JSONTransformer = /*#__PURE__*/function () {
  function JSONTransformer() {
    (0, _classCallCheck2.default)(this, JSONTransformer);
  }
  (0, _createClass2.default)(JSONTransformer, [{
    key: "encode",
    value: function encode(node) {
      var content = [];
      node.content.forEach(function (child) {
        content.push((0, _sanitizeNode.sanitizeNode)(toJSON(child)));
      });
      if (!content || (0, _isEqual.default)(content, emptyDoc.content)) {
        return createDocFromContent([]);
      }
      return createDocFromContent(content);
    }
  }, {
    key: "internalParse",
    value: function internalParse(content) {
      var stage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SchemaStage.FINAL;
      var schema = (0, _schemaDefault.getSchemaBasedOnStage)(stage);
      var doc = schema.nodeFromJSON(content);
      doc.check();
      return doc;
    }
  }, {
    key: "parse",
    value: function parse(content, stage) {
      if (content.type !== 'doc') {
        throw new Error('Expected content format to be ADF');
      }
      if (!content.content || content.content.length === 0) {
        return this.internalParse(emptyDoc, stage);
      }
      return this.internalParse(content, stage);
    }

    /**
     * This method is used to encode a single node
     */
  }, {
    key: "encodeNode",
    value: function encodeNode(node) {
      return (0, _sanitizeNode.sanitizeNode)(toJSON(node));
    }
  }]);
  return JSONTransformer;
}();