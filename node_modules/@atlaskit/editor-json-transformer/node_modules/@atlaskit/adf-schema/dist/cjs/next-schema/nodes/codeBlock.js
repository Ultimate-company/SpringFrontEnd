"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codeBlockWithNoMarks = exports.codeBlock = void 0;
var _adfSchemaGenerator = require("@atlaskit/adf-schema-generator");
var _breakout = require("../marks/breakout");
var _unsupportedMark = require("../marks/unsupportedMark");
var _unsupportedNodeAttribute = require("../marks/unsupportedNodeAttribute");
var _text = require("./text");
var _unsupportedInline = require("./unsupportedInline");
var codeBlock = exports.codeBlock = (0, _adfSchemaGenerator.adfNode)('codeBlock').define({
  code: true,
  defining: true,
  marks: [_unsupportedMark.unsupportedMark, _unsupportedNodeAttribute.unsupportedNodeAttribute],
  hasEmptyMarks: true,
  attrs: {
    language: {
      type: 'string',
      default: null,
      optional: true
    },
    uniqueId: {
      type: 'string',
      default: null,
      optional: true
    }
  },
  content: [(0, _adfSchemaGenerator.$zeroPlus)((0, _adfSchemaGenerator.$or)(_text.text, _unsupportedInline.unsupportedInline))],
  DANGEROUS_MANUAL_OVERRIDE: {
    'validator-spec': {
      'props.attrs.props.uniqueId': {
        remove: true,
        reason: '@DSLCompatibilityException - uniqueId is missing in the existing validator spec'
      },
      'props.content.items': {
        value: [['text', {
          props: {
            marks: {
              items: [],
              maxItems: 0,
              optional: true,
              type: 'array'
            }
          }
        }]],
        reason: '@DSLCompatibilityException - text variant is inlined, which is not supported by current transformation'
      }
    }
  }
}).variant('with_marks', {
  marks: [_breakout.breakout, _unsupportedMark.unsupportedMark, _unsupportedNodeAttribute.unsupportedNodeAttribute],
  ignore: ['pm-spec']
}).variant('with_no_marks', {
  content: [],
  marks: [],
  noMarks: true,
  ignore: []
});
var codeBlockWithNoMarks = exports.codeBlockWithNoMarks = codeBlock;